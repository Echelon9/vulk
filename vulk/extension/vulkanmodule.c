
#include <Python.h>
#include <dlfcn.h>

#define VK_NO_PROTOTYPES

#if defined(ANDROID) || defined (__ANDROID__)
  #define VK_USE_PLATFORM_ANDROID_KHR 1
#elif defined(_WIN32)
  #define VK_USE_PLATFORM_WIN32_KHR 1
#elif defined(__linux__)
  #define VK_USE_PLATFORM_XLIB_KHR 1
#endif

#ifdef __unix__

#define LOAD_SDK() dlopen("libvulkan.so", RTLD_NOW);

#elif defined(_WIN32) || defined(WIN32)

#define LOAD_SDK() LoadLibrary("vulkan-1.dll");
#define dlsym GetProcAddress

#endif

// BEGIN VULKAN PLATEFORM
//
// File: vk_platform.h
//
/*
** Copyright (c) 2014-2015 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/


#ifndef VK_PLATFORM_H_
#define VK_PLATFORM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

/*
***************************************************************************************************
*   Platform-specific directives and type declarations
***************************************************************************************************
*/

/* Platform-specific calling convention macros.
 *
 * Platforms should define these so that Vulkan clients call Vulkan commands
 * with the same calling conventions that the Vulkan implementation expects.
 *
 * VKAPI_ATTR - Placed before the return type in function declarations.
 *              Useful for C++11 and GCC/Clang-style function attribute syntax.
 * VKAPI_CALL - Placed after the return type in function declarations.
 *              Useful for MSVC-style calling convention syntax.
 * VKAPI_PTR  - Placed between the '(' and '*' in function pointer types.
 *
 * Function declaration:  VKAPI_ATTR void VKAPI_CALL vkCommand(void);
 * Function pointer type: typedef void (VKAPI_PTR *PFN_vkCommand)(void);
 */
#if defined(_WIN32)
    // On Windows, Vulkan commands use the stdcall convention
    #define VKAPI_ATTR
    #define VKAPI_CALL __stdcall
    #define VKAPI_PTR  VKAPI_CALL
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH < 7
    #error "Vulkan isn't supported for the 'armeabi' NDK ABI"
#elif defined(__ANDROID__) && defined(__ARM_ARCH) && __ARM_ARCH >= 7 && __ARM_32BIT_STATE
    // On Android 32-bit ARM targets, Vulkan functions use the "hardfloat"
    // calling convention, i.e. float parameters are passed in registers. This
    // is true even if the rest of the application passes floats on the stack,
    // as it does by default when compiling for the armeabi-v7a NDK ABI.
    #define VKAPI_ATTR __attribute__((pcs("aapcs-vfp")))
    #define VKAPI_CALL
    #define VKAPI_PTR  VKAPI_ATTR
#else
    // On other platforms, use the default calling convention
    #define VKAPI_ATTR
    #define VKAPI_CALL
    #define VKAPI_PTR
#endif

#include <stddef.h>

#if !defined(VK_NO_STDINT_H)
    #if defined(_MSC_VER) && (_MSC_VER < 1600)
        typedef signed   __int8  int8_t;
        typedef unsigned __int8  uint8_t;
        typedef signed   __int16 int16_t;
        typedef unsigned __int16 uint16_t;
        typedef signed   __int32 int32_t;
        typedef unsigned __int32 uint32_t;
        typedef signed   __int64 int64_t;
        typedef unsigned __int64 uint64_t;
    #else
        #include <stdint.h>
    #endif
#endif // !defined(VK_NO_STDINT_H)

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

// Platform-specific headers required by platform window system extensions.
// These are enabled prior to #including "vulkan.h". The same enable then
// controls inclusion of the extension interfaces in vulkan.h.

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#include <android/native_window.h>
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
#include <mir_toolkit/client_types.h>
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#include <wayland-client.h>
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
#include <windows.h>
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#include <X11/Xlib.h>
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
#include <xcb/xcb.h>
#endif

#endif
// END VULKAN PLATEFORM
// BEGIN VULKAN H
#ifndef VULKAN_H_
#define VULKAN_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

/*
** This header is generated from the Khronos Vulkan XML API Registry.
**
*/


#define VK_VERSION_1_0 1

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0)

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
// Version of this file
#define VK_HEADER_VERSION 25


#define VK_NULL_HANDLE 0
        


#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        


typedef uint32_t VkFlags;
typedef uint32_t VkBool32;
typedef uint64_t VkDeviceSize;
typedef uint32_t VkSampleMask;

VK_DEFINE_HANDLE(VkInstance)
VK_DEFINE_HANDLE(VkPhysicalDevice)
VK_DEFINE_HANDLE(VkDevice)
VK_DEFINE_HANDLE(VkQueue)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
VK_DEFINE_HANDLE(VkCommandBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)

#define VK_LOD_CLAMP_NONE                 1000.0f
#define VK_REMAINING_MIP_LEVELS           (~0U)
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
#define VK_WHOLE_SIZE                     (~0ULL)
#define VK_ATTACHMENT_UNUSED              (~0U)
#define VK_TRUE                           1
#define VK_FALSE                          0
#define VK_QUEUE_FAMILY_IGNORED           (~0U)
#define VK_SUBPASS_EXTERNAL               (~0U)
#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  256
#define VK_UUID_SIZE                      16
#define VK_MAX_MEMORY_TYPES               32
#define VK_MAX_MEMORY_HEAPS               16
#define VK_MAX_EXTENSION_NAME_SIZE        256
#define VK_MAX_DESCRIPTION_SIZE           256


typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FRAGMENTED_POOL,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FRAGMENTED_POOL + 1),
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_VALIDATION_FLAGS_EXT = 1000011002,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;

typedef VkFlags VkInstanceCreateFlags;

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
typedef VkFlags VkFormatFeatureFlags;

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
typedef VkFlags VkImageUsageFlags;

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
typedef VkFlags VkImageCreateFlags;

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
typedef VkFlags VkSampleCountFlags;

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
typedef VkFlags VkQueueFlags;

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
typedef VkFlags VkMemoryPropertyFlags;

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkDeviceCreateFlags;
typedef VkFlags VkDeviceQueueCreateFlags;

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkMemoryMapFlags;

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
typedef VkFlags VkImageAspectFlags;

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
typedef VkFlags VkSparseImageFormatFlags;

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
typedef VkFlags VkSparseMemoryBindFlags;

typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
typedef VkFlags VkFenceCreateFlags;
typedef VkFlags VkSemaphoreCreateFlags;
typedef VkFlags VkEventCreateFlags;
typedef VkFlags VkQueryPoolCreateFlags;

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
typedef VkFlags VkQueryPipelineStatisticFlags;

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
typedef VkFlags VkQueryResultFlags;

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
typedef VkFlags VkBufferCreateFlags;

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferViewCreateFlags;
typedef VkFlags VkImageViewCreateFlags;
typedef VkFlags VkShaderModuleCreateFlags;
typedef VkFlags VkPipelineCacheCreateFlags;

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
typedef VkFlags VkPipelineTessellationStateCreateFlags;
typedef VkFlags VkPipelineViewportStateCreateFlags;
typedef VkFlags VkPipelineRasterizationStateCreateFlags;

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
typedef VkFlags VkCullModeFlags;
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
typedef VkFlags VkPipelineColorBlendStateCreateFlags;

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
typedef VkFlags VkColorComponentFlags;
typedef VkFlags VkPipelineDynamicStateCreateFlags;
typedef VkFlags VkPipelineLayoutCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkSamplerCreateFlags;
typedef VkFlags VkDescriptorSetLayoutCreateFlags;

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFramebufferCreateFlags;
typedef VkFlags VkRenderPassCreateFlags;

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
typedef VkFlags VkAttachmentDescriptionFlags;
typedef VkFlags VkSubpassDescriptionFlags;

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
typedef VkFlags VkAccessFlags;

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
typedef VkFlags VkDependencyFlags;

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
typedef VkFlags VkCommandPoolCreateFlags;

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
typedef VkFlags VkCommandPoolResetFlags;

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
typedef VkFlags VkCommandBufferUsageFlags;

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
typedef VkFlags VkQueryControlFlags;

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
typedef VkFlags VkCommandBufferResetFlags;

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
typedef VkFlags VkStencilFaceFlags;

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    void*        pNext;
    char*        pApplicationName;
    uint32_t           applicationVersion;
    char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkInstanceCreateFlags       flags;
    VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    char* *         ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    char* *         ppEnabledExtensionNames;
} VkInstanceCreateInfo;

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    char* *                ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    char* *                ppEnabledExtensionNames;
    VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    VkSemaphore*             pWaitSemaphores;
    VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    uint32_t*              pCode;
} VkShaderModuleCreateInfo;

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    void*                   pInitialData;
} VkPipelineCacheCreateInfo;

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    void*                        pData;
} VkSpecializationInfo;

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    char*                         pName;
    VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    VkPipelineShaderStageCreateInfo*           pStages;
    VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    VkPipelineTessellationStateCreateInfo*     pTessellationState;
    VkPipelineViewportStateCreateInfo*         pViewportState;
    VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    VkDescriptorImageInfo*     pImageInfo;
    VkDescriptorBufferInfo*    pBufferInfo;
    VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    VkAttachmentReference*    pColorAttachments;
    VkAttachmentReference*    pResolveAttachments;
    VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;


typedef VkResult (VKAPI_PTR *PFN_vkCreateInstance)(const VkInstanceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
typedef void (VKAPI_PTR *PFN_vkDestroyInstance)(VkInstance instance, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumeratePhysicalDevices)(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFeatures)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceQueueFamilyProperties)(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceMemoryProperties)(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance instance, char* pName);
typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetDeviceProcAddr)(VkDevice device, char* pName);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDevice)(VkPhysicalDevice physicalDevice, VkDeviceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
typedef void (VKAPI_PTR *PFN_vkDestroyDevice)(VkDevice device, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceExtensionProperties)(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceExtensionProperties)(VkPhysicalDevice physicalDevice, char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateInstanceLayerProperties)(uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkEnumerateDeviceLayerProperties)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties);
typedef void (VKAPI_PTR *PFN_vkGetDeviceQueue)(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue);
typedef VkResult (VKAPI_PTR *PFN_vkQueueSubmit)(VkQueue queue, uint32_t submitCount, VkSubmitInfo* pSubmits, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkQueueWaitIdle)(VkQueue queue);
typedef VkResult (VKAPI_PTR *PFN_vkDeviceWaitIdle)(VkDevice device);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateMemory)(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);
typedef void (VKAPI_PTR *PFN_vkFreeMemory)(VkDevice device, VkDeviceMemory memory, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkMapMemory)(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);
typedef void (VKAPI_PTR *PFN_vkUnmapMemory)(VkDevice device, VkDeviceMemory memory);
typedef VkResult (VKAPI_PTR *PFN_vkFlushMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges);
typedef void (VKAPI_PTR *PFN_vkGetDeviceMemoryCommitment)(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes);
typedef VkResult (VKAPI_PTR *PFN_vkBindBufferMemory)(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef VkResult (VKAPI_PTR *PFN_vkBindImageMemory)(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
typedef void (VKAPI_PTR *PFN_vkGetBufferMemoryRequirements)(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetImageSparseMemoryRequirements)(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements);
typedef void (VKAPI_PTR *PFN_vkGetPhysicalDeviceSparseImageFormatProperties)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkQueueBindSparse)(VkQueue queue, uint32_t bindInfoCount, VkBindSparseInfo* pBindInfo, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFence)(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence);
typedef void (VKAPI_PTR *PFN_vkDestroyFence)(VkDevice device, VkFence fence, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences);
typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice device, VkFence fence);
typedef VkResult (VKAPI_PTR *PFN_vkWaitForFences)(VkDevice device, uint32_t fenceCount, VkFence* pFences, VkBool32 waitAll, uint64_t timeout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSemaphore)(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
typedef void (VKAPI_PTR *PFN_vkDestroySemaphore)(VkDevice device, VkSemaphore semaphore, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateEvent)(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkEvent* pEvent);
typedef void (VKAPI_PTR *PFN_vkDestroyEvent)(VkDevice device, VkEvent event, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkSetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkResetEvent)(VkDevice device, VkEvent event);
typedef VkResult (VKAPI_PTR *PFN_vkCreateQueryPool)(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool);
typedef void (VKAPI_PTR *PFN_vkDestroyQueryPool)(VkDevice device, VkQueryPool queryPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetQueryPoolResults)(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBuffer)(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyBuffer)(VkDevice device, VkBuffer buffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateBufferView)(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyBufferView)(VkDevice device, VkBufferView bufferView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImage)(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImage* pImage);
typedef void (VKAPI_PTR *PFN_vkDestroyImage)(VkDevice device, VkImage image, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetImageSubresourceLayout)(VkDevice device, VkImage image, VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout);
typedef VkResult (VKAPI_PTR *PFN_vkCreateImageView)(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImageView* pView);
typedef void (VKAPI_PTR *PFN_vkDestroyImageView)(VkDevice device, VkImageView imageView, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateShaderModule)(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule);
typedef void (VKAPI_PTR *PFN_vkDestroyShaderModule)(VkDevice device, VkShaderModule shaderModule, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineCache)(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineCache)(VkDevice device, VkPipelineCache pipelineCache, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPipelineCacheData)(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData);
typedef VkResult (VKAPI_PTR *PFN_vkMergePipelineCaches)(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, VkPipelineCache* pSrcCaches);
typedef VkResult (VKAPI_PTR *PFN_vkCreateGraphicsPipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef VkResult (VKAPI_PTR *PFN_vkCreateComputePipelines)(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines);
typedef void (VKAPI_PTR *PFN_vkDestroyPipeline)(VkDevice device, VkPipeline pipeline, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreatePipelineLayout)(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyPipelineLayout)(VkDevice device, VkPipelineLayout pipelineLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateSampler)(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSampler* pSampler);
typedef void (VKAPI_PTR *PFN_vkDestroySampler)(VkDevice device, VkSampler sampler, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorSetLayout)(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDescriptorPool)(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool);
typedef void (VKAPI_PTR *PFN_vkDestroyDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetDescriptorPool)(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateDescriptorSets)(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets);
typedef VkResult (VKAPI_PTR *PFN_vkFreeDescriptorSets)(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets);
typedef void (VKAPI_PTR *PFN_vkUpdateDescriptorSets)(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet* pDescriptorCopies);
typedef VkResult (VKAPI_PTR *PFN_vkCreateFramebuffer)(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer);
typedef void (VKAPI_PTR *PFN_vkDestroyFramebuffer)(VkDevice device, VkFramebuffer framebuffer, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkCreateRenderPass)(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass);
typedef void (VKAPI_PTR *PFN_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkGetRenderAreaGranularity)(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity);
typedef VkResult (VKAPI_PTR *PFN_vkCreateCommandPool)(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool);
typedef void (VKAPI_PTR *PFN_vkDestroyCommandPool)(VkDevice device, VkCommandPool commandPool, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandPool)(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags);
typedef VkResult (VKAPI_PTR *PFN_vkAllocateCommandBuffers)(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers);
typedef void (VKAPI_PTR *PFN_vkFreeCommandBuffers)(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);
typedef VkResult (VKAPI_PTR *PFN_vkBeginCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo);
typedef VkResult (VKAPI_PTR *PFN_vkEndCommandBuffer)(VkCommandBuffer commandBuffer);
typedef VkResult (VKAPI_PTR *PFN_vkResetCommandBuffer)(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdBindPipeline)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline);
typedef void (VKAPI_PTR *PFN_vkCmdSetViewport)(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport* pViewports);
typedef void (VKAPI_PTR *PFN_vkCmdSetScissor)(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D* pScissors);
typedef void (VKAPI_PTR *PFN_vkCmdSetLineWidth)(VkCommandBuffer commandBuffer, float lineWidth);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBias)(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
typedef void (VKAPI_PTR *PFN_vkCmdSetBlendConstants)(VkCommandBuffer commandBuffer, float blendConstants[4]);
typedef void (VKAPI_PTR *PFN_vkCmdSetDepthBounds)(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilCompareMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilWriteMask)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask);
typedef void (VKAPI_PTR *PFN_vkCmdSetStencilReference)(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference);
typedef void (VKAPI_PTR *PFN_vkCmdBindDescriptorSets)(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t* pDynamicOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdBindIndexBuffer)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType);
typedef void (VKAPI_PTR *PFN_vkCmdBindVertexBuffers)(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets);
typedef void (VKAPI_PTR *PFN_vkCmdDraw)(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexed)(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDispatch)(VkCommandBuffer commandBuffer, uint32_t x, uint32_t y, uint32_t z);
typedef void (VKAPI_PTR *PFN_vkCmdDispatchIndirect)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBuffer)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdBlitImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit* pRegions, VkFilter filter);
typedef void (VKAPI_PTR *PFN_vkCmdCopyBufferToImage)(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdCopyImageToBuffer)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdUpdateBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData);
typedef void (VKAPI_PTR *PFN_vkCmdFillBuffer)(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data);
typedef void (VKAPI_PTR *PFN_vkCmdClearColorImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearDepthStencilImage)(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange* pRanges);
typedef void (VKAPI_PTR *PFN_vkCmdClearAttachments)(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment* pAttachments, uint32_t rectCount, VkClearRect* pRects);
typedef void (VKAPI_PTR *PFN_vkCmdResolveImage)(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve* pRegions);
typedef void (VKAPI_PTR *PFN_vkCmdSetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdResetEvent)(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);
typedef void (VKAPI_PTR *PFN_vkCmdWaitEvents)(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdPipelineBarrier)(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers);
typedef void (VKAPI_PTR *PFN_vkCmdBeginQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdEndQuery)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdResetQueryPool)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
typedef void (VKAPI_PTR *PFN_vkCmdWriteTimestamp)(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query);
typedef void (VKAPI_PTR *PFN_vkCmdCopyQueryPoolResults)(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags);
typedef void (VKAPI_PTR *PFN_vkCmdPushConstants)(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void* pValues);
typedef void (VKAPI_PTR *PFN_vkCmdBeginRenderPass)(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdNextSubpass)(VkCommandBuffer commandBuffer, VkSubpassContents contents);
typedef void (VKAPI_PTR *PFN_vkCmdEndRenderPass)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdExecuteCommands)(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(
    VkInstanceCreateInfo*                 pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);

VKAPI_ATTR void VKAPI_CALL vkDestroyInstance(
    VkInstance                                  instance,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(
    VkInstance                                  instance,
    char*                                 pName);

VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL vkGetDeviceProcAddr(
    VkDevice                                    device,
    char*                                 pName);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);

VKAPI_ATTR void VKAPI_CALL vkDestroyDevice(
    VkDevice                                    device,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceExtensionProperties(
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueWaitIdle(
    VkQueue                                     queue);

VKAPI_ATTR VkResult VKAPI_CALL vkDeviceWaitIdle(
    VkDevice                                    device);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(
    VkDevice                                    device,
    VkMemoryAllocateInfo*                 pAllocateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);

VKAPI_ATTR void VKAPI_CALL vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);

VKAPI_ATTR void VKAPI_CALL vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);

VKAPI_ATTR VkResult VKAPI_CALL vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    VkMappedMemoryRange*                  pMemoryRanges);

VKAPI_ATTR void VKAPI_CALL vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);

VKAPI_ATTR VkResult VKAPI_CALL vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR VkResult VKAPI_CALL vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);

VKAPI_ATTR void VKAPI_CALL vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);

VKAPI_ATTR void VKAPI_CALL vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFence(
    VkDevice                                    device,
    VkFenceCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);

VKAPI_ATTR void VKAPI_CALL vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences);

VKAPI_ATTR VkResult VKAPI_CALL vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);

VKAPI_ATTR VkResult VKAPI_CALL vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSemaphore(
    VkDevice                                    device,
    VkSemaphoreCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);

VKAPI_ATTR void VKAPI_CALL vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateEvent(
    VkDevice                                    device,
    VkEventCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);

VKAPI_ATTR void VKAPI_CALL vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateQueryPool(
    VkDevice                                    device,
    VkQueryPoolCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBuffer(
    VkDevice                                    device,
    VkBufferCreateInfo*                   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateBufferView(
    VkDevice                                    device,
    VkBufferViewCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImage(
    VkDevice                                    device,
    VkImageCreateInfo*                    pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);

VKAPI_ATTR void VKAPI_CALL vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateImageView(
    VkDevice                                    device,
    VkImageViewCreateInfo*                pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);

VKAPI_ATTR void VKAPI_CALL vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateShaderModule(
    VkDevice                                    device,
    VkShaderModuleCreateInfo*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);

VKAPI_ATTR void VKAPI_CALL vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineCache(
    VkDevice                                    device,
    VkPipelineCacheCreateInfo*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);

VKAPI_ATTR VkResult VKAPI_CALL vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    VkPipelineCache*                      pSrcCaches);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkGraphicsPipelineCreateInfo*         pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    VkComputePipelineCreateInfo*          pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreatePipelineLayout(
    VkDevice                                    device,
    VkPipelineLayoutCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateSampler(
    VkDevice                                    device,
    VkSamplerCreateInfo*                  pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);

VKAPI_ATTR void VKAPI_CALL vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPoolCreateInfo*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateDescriptorSets(
    VkDevice                                    device,
    VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);

VKAPI_ATTR VkResult VKAPI_CALL vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets);

VKAPI_ATTR void VKAPI_CALL vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    VkCopyDescriptorSet*                  pDescriptorCopies);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateFramebuffer(
    VkDevice                                    device,
    VkFramebufferCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);

VKAPI_ATTR void VKAPI_CALL vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateRenderPass(
    VkDevice                                    device,
    VkRenderPassCreateInfo*               pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);

VKAPI_ATTR void VKAPI_CALL vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateCommandPool(
    VkDevice                                    device,
    VkCommandPoolCreateInfo*              pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);

VKAPI_ATTR void VKAPI_CALL vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);

VKAPI_ATTR VkResult VKAPI_CALL vkAllocateCommandBuffers(
    VkDevice                                    device,
    VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);

VKAPI_ATTR void VKAPI_CALL vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);

VKAPI_ATTR VkResult VKAPI_CALL vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferBeginInfo*             pBeginInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR VkResult VKAPI_CALL vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);

VKAPI_ATTR void VKAPI_CALL vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);

VKAPI_ATTR void VKAPI_CALL vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    VkViewport*                           pViewports);

VKAPI_ATTR void VKAPI_CALL vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    VkRect2D*                             pScissors);

VKAPI_ATTR void VKAPI_CALL vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);

VKAPI_ATTR void VKAPI_CALL vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    float                                 blendConstants[4]);

VKAPI_ATTR void VKAPI_CALL vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);

VKAPI_ATTR void VKAPI_CALL vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);

VKAPI_ATTR void VKAPI_CALL vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    uint32_t*                             pDynamicOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);

VKAPI_ATTR void VKAPI_CALL vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    VkBuffer*                             pBuffers,
    VkDeviceSize*                         pOffsets);

VKAPI_ATTR void VKAPI_CALL vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    x,
    uint32_t                                    y,
    uint32_t                                    z);

VKAPI_ATTR void VKAPI_CALL vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferCopy*                         pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageCopy*                          pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageBlit*                          pRegions,
    VkFilter                                    filter);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    VkBufferImageCopy*                    pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    void*                                 pData);

VKAPI_ATTR void VKAPI_CALL vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);

VKAPI_ATTR void VKAPI_CALL vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    VkImageSubresourceRange*              pRanges);

VKAPI_ATTR void VKAPI_CALL vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    VkClearRect*                          pRects);

VKAPI_ATTR void VKAPI_CALL vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    VkImageResolve*                       pRegions);

VKAPI_ATTR void VKAPI_CALL vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);

VKAPI_ATTR void VKAPI_CALL vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    VkImageMemoryBarrier*                 pImageMemoryBarriers);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);

VKAPI_ATTR void VKAPI_CALL vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);

VKAPI_ATTR void VKAPI_CALL vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);

VKAPI_ATTR void VKAPI_CALL vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);

VKAPI_ATTR void VKAPI_CALL vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    void*                                 pValues);

VKAPI_ATTR void VKAPI_CALL vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);

VKAPI_ATTR void VKAPI_CALL vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    VkCommandBuffer*                      pCommandBuffers);
#endif

#define VK_KHR_surface 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)

#define VK_KHR_SURFACE_SPEC_VERSION       25
#define VK_KHR_SURFACE_EXTENSION_NAME     "VK_KHR_surface"
#define VK_COLORSPACE_SRGB_NONLINEAR_KHR  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR


typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_BEGIN_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_END_RANGE_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = (VK_COLOR_SPACE_SRGB_NONLINEAR_KHR - VK_COLOR_SPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_BEGIN_RANGE_KHR = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE_KHR = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;


typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
typedef VkFlags VkSurfaceTransformFlagsKHR;

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
typedef VkFlags VkCompositeAlphaFlagsKHR;

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;


typedef void (VKAPI_PTR *PFN_vkDestroySurfaceKHR)(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
#endif

#define VK_KHR_swapchain 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)

#define VK_KHR_SWAPCHAIN_SPEC_VERSION     68
#define VK_KHR_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_swapchain"

typedef VkFlags VkSwapchainCreateFlagsKHR;

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 waitSemaphoreCount;
    VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    VkSwapchainKHR*    pSwapchains;
    uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSwapchainKHR)(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain);
typedef void (VKAPI_PTR *PFN_vkDestroySwapchainKHR)(VkDevice device, VkSwapchainKHR swapchain, VkAllocationCallbacks* pAllocator);
typedef VkResult (VKAPI_PTR *PFN_vkGetSwapchainImagesKHR)(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages);
typedef VkResult (VKAPI_PTR *PFN_vkAcquireNextImageKHR)(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex);
typedef VkResult (VKAPI_PTR *PFN_vkQueuePresentKHR)(VkQueue queue, VkPresentInfoKHR* pPresentInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSwapchainKHR(
    VkDevice                                    device,
    VkSwapchainCreateInfoKHR*             pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);

VKAPI_ATTR void VKAPI_CALL vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR VkResult VKAPI_CALL vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);

VKAPI_ATTR VkResult VKAPI_CALL vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);

VKAPI_ATTR VkResult VKAPI_CALL vkQueuePresentKHR(
    VkQueue                                     queue,
    VkPresentInfoKHR*                     pPresentInfo);
#endif

#define VK_KHR_display 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)

#define VK_KHR_DISPLAY_SPEC_VERSION       21
#define VK_KHR_DISPLAY_EXTENSION_NAME     "VK_KHR_display"


typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
typedef VkFlags VkDisplayModeCreateFlagsKHR;
typedef VkFlags VkDisplaySurfaceCreateFlagsKHR;

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneSupportedDisplaysKHR)(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayModePropertiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayModeKHR)(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode);
typedef VkResult (VKAPI_PTR *PFN_vkGetDisplayPlaneCapabilitiesKHR)(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities);
typedef VkResult (VKAPI_PTR *PFN_vkCreateDisplayPlaneSurfaceKHR)(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    VkDisplayModeCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);

VKAPI_ATTR VkResult VKAPI_CALL vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);

VKAPI_ATTR VkResult VKAPI_CALL vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif

#define VK_KHR_display_swapchain 1
#define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION 9
#define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateSharedSwapchainsKHR)(VkDevice device, uint32_t swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    VkSwapchainCreateInfoKHR*             pCreateInfos,
    VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
#define VK_KHR_xlib_surface 1
#include <X11/Xlib.h>

#define VK_KHR_XLIB_SURFACE_SPEC_VERSION  6
#define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

typedef VkFlags VkXlibSurfaceCreateFlagsKHR;

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXlibSurfaceKHR)(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);
#endif
#endif /* VK_USE_PLATFORM_XLIB_KHR */

#ifdef VK_USE_PLATFORM_XCB_KHR
#define VK_KHR_xcb_surface 1
#include <xcb/xcb.h>

#define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
#define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

typedef VkFlags VkXcbSurfaceCreateFlagsKHR;

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateXcbSurfaceKHR)(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);
#endif
#endif /* VK_USE_PLATFORM_XCB_KHR */

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
#define VK_KHR_wayland_surface 1
#include <wayland-client.h>

#define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 5
#define VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME "VK_KHR_wayland_surface"

typedef VkFlags VkWaylandSurfaceCreateFlagsKHR;

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWaylandSurfaceKHR)(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display);
#endif
#endif /* VK_USE_PLATFORM_WAYLAND_KHR */

#ifdef VK_USE_PLATFORM_MIR_KHR
#define VK_KHR_mir_surface 1
#include <mir_toolkit/client_types.h>

#define VK_KHR_MIR_SURFACE_SPEC_VERSION   4
#define VK_KHR_MIR_SURFACE_EXTENSION_NAME "VK_KHR_mir_surface"

typedef VkFlags VkMirSurfaceCreateFlagsKHR;

typedef struct VkMirSurfaceCreateInfoKHR {
    VkStructureType               sType;
    void*                   pNext;
    VkMirSurfaceCreateFlagsKHR    flags;
    MirConnection*                connection;
    MirSurface*                   mirSurface;
} VkMirSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateMirSurfaceKHR)(VkInstance instance, VkMirSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceMirPresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, MirConnection* connection);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateMirSurfaceKHR(
    VkInstance                                  instance,
    VkMirSurfaceCreateInfoKHR*            pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceMirPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    MirConnection*                              connection);
#endif
#endif /* VK_USE_PLATFORM_MIR_KHR */

#ifdef VK_USE_PLATFORM_ANDROID_KHR
#define VK_KHR_android_surface 1
#include <android/native_window.h>

#define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
#define VK_KHR_ANDROID_SURFACE_EXTENSION_NAME "VK_KHR_android_surface"

typedef VkFlags VkAndroidSurfaceCreateFlagsKHR;

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    ANativeWindow*                    window;
} VkAndroidSurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateAndroidSurfaceKHR)(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
#endif
#endif /* VK_USE_PLATFORM_ANDROID_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_KHR_win32_surface 1
#include <windows.h>

#define VK_KHR_WIN32_SURFACE_SPEC_VERSION 5
#define VK_KHR_WIN32_SURFACE_EXTENSION_NAME "VK_KHR_win32_surface"

typedef VkFlags VkWin32SurfaceCreateFlagsKHR;

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;


typedef VkResult (VKAPI_PTR *PFN_vkCreateWin32SurfaceKHR)(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface);
typedef VkBool32 (VKAPI_PTR *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);

VKAPI_ATTR VkBool32 VKAPI_CALL vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#define VK_KHR_sampler_mirror_clamp_to_edge 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION 1
#define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"


#define VK_EXT_debug_report 1
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)

#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  4
#define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
#define VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT


typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT - VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT + 1),
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;

typedef enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = VK_DEBUG_REPORT_ERROR_NONE_EXT,
    VK_DEBUG_REPORT_ERROR_END_RANGE_EXT = VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = (VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT - VK_DEBUG_REPORT_ERROR_NONE_EXT + 1),
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportErrorEXT;


typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
typedef VkFlags VkDebugReportFlagsEXT;

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage,
    void*                                       pUserData);


typedef struct VkDebugReportLayerFlagsEXT {
    VkStructureType    sType;
    void*        pNext;
    uint64_t           enabledValidationFlags;
} VkDebugReportLayerFlagsEXT;

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkCreateDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback);
typedef void (VKAPI_PTR *PFN_vkDestroyDebugReportCallbackEXT)(VkInstance instance, VkDebugReportCallbackEXT callback, VkAllocationCallbacks* pAllocator);
typedef void (VKAPI_PTR *PFN_vkDebugReportMessageEXT)(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, char* pLayerPrefix, char* pMessage);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);

VKAPI_ATTR void VKAPI_CALL vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    VkAllocationCallbacks*                pAllocator);

VKAPI_ATTR void VKAPI_CALL vkDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    char*                                 pLayerPrefix,
    char*                                 pMessage);
#endif

#define VK_NV_glsl_shader 1
#define VK_NV_GLSL_SHADER_SPEC_VERSION    1
#define VK_NV_GLSL_SHADER_EXTENSION_NAME  "VK_NV_glsl_shader"


#define VK_IMG_filter_cubic 1
#define VK_IMG_FILTER_CUBIC_SPEC_VERSION  1
#define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"


#define VK_AMD_rasterization_order 1
#define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION 1
#define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"


typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = VK_RASTERIZATION_ORDER_STRICT_AMD,
    VK_RASTERIZATION_ORDER_END_RANGE_AMD = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (VK_RASTERIZATION_ORDER_RELAXED_AMD - VK_RASTERIZATION_ORDER_STRICT_AMD + 1),
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;



#define VK_AMD_shader_trinary_minmax 1
#define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
#define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"


#define VK_AMD_shader_explicit_vertex_parameter 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
#define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"


#define VK_EXT_debug_marker 1
#define VK_EXT_DEBUG_MARKER_SPEC_VERSION  3
#define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    void*        pNext;
    char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;


typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectTagEXT)(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo);
typedef VkResult (VKAPI_PTR *PFN_vkDebugMarkerSetObjectNameEXT)(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerBeginEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerEndEXT)(VkCommandBuffer commandBuffer);
typedef void (VKAPI_PTR *PFN_vkCmdDebugMarkerInsertEXT)(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectTagInfoEXT*              pTagInfo);

VKAPI_ATTR VkResult VKAPI_CALL vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectNameInfoEXT*             pNameInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer);

VKAPI_ATTR void VKAPI_CALL vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo);
#endif

#define VK_AMD_gcn_shader 1
#define VK_AMD_GCN_SHADER_SPEC_VERSION    1
#define VK_AMD_GCN_SHADER_EXTENSION_NAME  "VK_AMD_gcn_shader"


#define VK_NV_dedicated_allocation 1
#define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
#define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;



#define VK_AMD_draw_indirect_count 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
#define VK_AMD_EXTENSION_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

typedef void (VKAPI_PTR *PFN_vkCmdDrawIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
typedef void (VKAPI_PTR *PFN_vkCmdDrawIndexedIndirectCountAMD)(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);

VKAPI_ATTR void VKAPI_CALL vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
#endif

#define VK_IMG_format_pvrtc 1
#define VK_IMG_FORMAT_PVRTC_SPEC_VERSION  1
#define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"


#define VK_NV_external_memory_capabilities 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"


typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;

typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;
typedef VkFlags VkExternalMemoryFeatureFlagsNV;

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
#endif

#define VK_NV_external_memory 1
#define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;



#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_external_memory_win32 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
#define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    void*                   pNext;
    SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;


typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleNV)(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle);

#ifndef VK_NO_PROTOTYPES
VKAPI_ATTR VkResult VKAPI_CALL vkGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle);
#endif
#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef VK_USE_PLATFORM_WIN32_KHR
#define VK_NV_win32_keyed_mutex 1
#define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
#define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    void*              pNext;
    uint32_t                 acquireCount;
    VkDeviceMemory*    pAcquireSyncs;
    uint64_t*          pAcquireKeys;
    uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    VkDeviceMemory*    pReleaseSyncs;
    uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;


#endif /* VK_USE_PLATFORM_WIN32_KHR */

#ifdef __cplusplus
}
#endif

#endif
// END VULKAN H

static PFN_vkCreateInstance vkCreateInstance;
static PFN_vkDestroyInstance vkDestroyInstance;
static PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices;
static PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr;
static PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr;
static PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties;
static PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties;
static PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties;
static PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures;
static PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties;
static PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties;
static PFN_vkCreateDevice vkCreateDevice;
static PFN_vkDestroyDevice vkDestroyDevice;
static PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties;
static PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties;
static PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties;
static PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties;
static PFN_vkGetDeviceQueue vkGetDeviceQueue;
static PFN_vkQueueSubmit vkQueueSubmit;
static PFN_vkQueueWaitIdle vkQueueWaitIdle;
static PFN_vkDeviceWaitIdle vkDeviceWaitIdle;
static PFN_vkAllocateMemory vkAllocateMemory;
static PFN_vkFreeMemory vkFreeMemory;
static PFN_vkMapMemory vkMapMemory;
static PFN_vkUnmapMemory vkUnmapMemory;
static PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges;
static PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges;
static PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment;
static PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements;
static PFN_vkBindBufferMemory vkBindBufferMemory;
static PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements;
static PFN_vkBindImageMemory vkBindImageMemory;
static PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements;
static PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties;
static PFN_vkQueueBindSparse vkQueueBindSparse;
static PFN_vkCreateFence vkCreateFence;
static PFN_vkDestroyFence vkDestroyFence;
static PFN_vkResetFences vkResetFences;
static PFN_vkGetFenceStatus vkGetFenceStatus;
static PFN_vkWaitForFences vkWaitForFences;
static PFN_vkCreateSemaphore vkCreateSemaphore;
static PFN_vkDestroySemaphore vkDestroySemaphore;
static PFN_vkCreateEvent vkCreateEvent;
static PFN_vkDestroyEvent vkDestroyEvent;
static PFN_vkGetEventStatus vkGetEventStatus;
static PFN_vkSetEvent vkSetEvent;
static PFN_vkResetEvent vkResetEvent;
static PFN_vkCreateQueryPool vkCreateQueryPool;
static PFN_vkDestroyQueryPool vkDestroyQueryPool;
static PFN_vkGetQueryPoolResults vkGetQueryPoolResults;
static PFN_vkCreateBuffer vkCreateBuffer;
static PFN_vkDestroyBuffer vkDestroyBuffer;
static PFN_vkCreateBufferView vkCreateBufferView;
static PFN_vkDestroyBufferView vkDestroyBufferView;
static PFN_vkCreateImage vkCreateImage;
static PFN_vkDestroyImage vkDestroyImage;
static PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout;
static PFN_vkCreateImageView vkCreateImageView;
static PFN_vkDestroyImageView vkDestroyImageView;
static PFN_vkCreateShaderModule vkCreateShaderModule;
static PFN_vkDestroyShaderModule vkDestroyShaderModule;
static PFN_vkCreatePipelineCache vkCreatePipelineCache;
static PFN_vkDestroyPipelineCache vkDestroyPipelineCache;
static PFN_vkGetPipelineCacheData vkGetPipelineCacheData;
static PFN_vkMergePipelineCaches vkMergePipelineCaches;
static PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines;
static PFN_vkCreateComputePipelines vkCreateComputePipelines;
static PFN_vkDestroyPipeline vkDestroyPipeline;
static PFN_vkCreatePipelineLayout vkCreatePipelineLayout;
static PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout;
static PFN_vkCreateSampler vkCreateSampler;
static PFN_vkDestroySampler vkDestroySampler;
static PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout;
static PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout;
static PFN_vkCreateDescriptorPool vkCreateDescriptorPool;
static PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool;
static PFN_vkResetDescriptorPool vkResetDescriptorPool;
static PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets;
static PFN_vkFreeDescriptorSets vkFreeDescriptorSets;
static PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets;
static PFN_vkCreateFramebuffer vkCreateFramebuffer;
static PFN_vkDestroyFramebuffer vkDestroyFramebuffer;
static PFN_vkCreateRenderPass vkCreateRenderPass;
static PFN_vkDestroyRenderPass vkDestroyRenderPass;
static PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity;
static PFN_vkCreateCommandPool vkCreateCommandPool;
static PFN_vkDestroyCommandPool vkDestroyCommandPool;
static PFN_vkResetCommandPool vkResetCommandPool;
static PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers;
static PFN_vkFreeCommandBuffers vkFreeCommandBuffers;
static PFN_vkBeginCommandBuffer vkBeginCommandBuffer;
static PFN_vkEndCommandBuffer vkEndCommandBuffer;
static PFN_vkResetCommandBuffer vkResetCommandBuffer;
static PFN_vkCmdBindPipeline vkCmdBindPipeline;
static PFN_vkCmdSetViewport vkCmdSetViewport;
static PFN_vkCmdSetScissor vkCmdSetScissor;
static PFN_vkCmdSetLineWidth vkCmdSetLineWidth;
static PFN_vkCmdSetDepthBias vkCmdSetDepthBias;
static PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants;
static PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds;
static PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask;
static PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask;
static PFN_vkCmdSetStencilReference vkCmdSetStencilReference;
static PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets;
static PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer;
static PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers;
static PFN_vkCmdDraw vkCmdDraw;
static PFN_vkCmdDrawIndexed vkCmdDrawIndexed;
static PFN_vkCmdDrawIndirect vkCmdDrawIndirect;
static PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect;
static PFN_vkCmdDispatch vkCmdDispatch;
static PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect;
static PFN_vkCmdCopyBuffer vkCmdCopyBuffer;
static PFN_vkCmdCopyImage vkCmdCopyImage;
static PFN_vkCmdBlitImage vkCmdBlitImage;
static PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage;
static PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer;
static PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer;
static PFN_vkCmdFillBuffer vkCmdFillBuffer;
static PFN_vkCmdClearColorImage vkCmdClearColorImage;
static PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage;
static PFN_vkCmdClearAttachments vkCmdClearAttachments;
static PFN_vkCmdResolveImage vkCmdResolveImage;
static PFN_vkCmdSetEvent vkCmdSetEvent;
static PFN_vkCmdResetEvent vkCmdResetEvent;
static PFN_vkCmdWaitEvents vkCmdWaitEvents;
static PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier;
static PFN_vkCmdBeginQuery vkCmdBeginQuery;
static PFN_vkCmdEndQuery vkCmdEndQuery;
static PFN_vkCmdResetQueryPool vkCmdResetQueryPool;
static PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp;
static PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults;
static PFN_vkCmdPushConstants vkCmdPushConstants;
static PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass;
static PFN_vkCmdNextSubpass vkCmdNextSubpass;
static PFN_vkCmdEndRenderPass vkCmdEndRenderPass;
static PFN_vkCmdExecuteCommands vkCmdExecuteCommands;

            static PyObject * load_sdk(PyObject *self, PyObject *args) {
                void* vk_sdk = LOAD_SDK();
                if (vk_sdk == NULL) {
                    PyErr_SetString(PyExc_ImportError,
                                    "Can't find vulkan sdk");
                    return NULL;
                }

                
                             vkCreateInstance = (PFN_vkCreateInstance)dlsym(vk_sdk, "vkCreateInstance");
                             if( vkCreateInstance == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateInstance in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyInstance = (PFN_vkDestroyInstance)dlsym(vk_sdk, "vkDestroyInstance");
                             if( vkDestroyInstance == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyInstance in sdk");
                                 return NULL;
                             }
                             

                             vkEnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)dlsym(vk_sdk, "vkEnumeratePhysicalDevices");
                             if( vkEnumeratePhysicalDevices == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEnumeratePhysicalDevices in sdk");
                                 return NULL;
                             }
                             

                             vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)dlsym(vk_sdk, "vkGetDeviceProcAddr");
                             if( vkGetDeviceProcAddr == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetDeviceProcAddr in sdk");
                                 return NULL;
                             }
                             

                             vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)dlsym(vk_sdk, "vkGetInstanceProcAddr");
                             if( vkGetInstanceProcAddr == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetInstanceProcAddr in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceProperties");
                             if( vkGetPhysicalDeviceProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceProperties in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceQueueFamilyProperties");
                             if( vkGetPhysicalDeviceQueueFamilyProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceQueueFamilyProperties in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceMemoryProperties");
                             if( vkGetPhysicalDeviceMemoryProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceMemoryProperties in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)dlsym(vk_sdk, "vkGetPhysicalDeviceFeatures");
                             if( vkGetPhysicalDeviceFeatures == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceFeatures in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceFormatProperties");
                             if( vkGetPhysicalDeviceFormatProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceFormatProperties in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceImageFormatProperties");
                             if( vkGetPhysicalDeviceImageFormatProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceImageFormatProperties in sdk");
                                 return NULL;
                             }
                             

                             vkCreateDevice = (PFN_vkCreateDevice)dlsym(vk_sdk, "vkCreateDevice");
                             if( vkCreateDevice == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateDevice in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyDevice = (PFN_vkDestroyDevice)dlsym(vk_sdk, "vkDestroyDevice");
                             if( vkDestroyDevice == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyDevice in sdk");
                                 return NULL;
                             }
                             

                             vkEnumerateInstanceLayerProperties = (PFN_vkEnumerateInstanceLayerProperties)dlsym(vk_sdk, "vkEnumerateInstanceLayerProperties");
                             if( vkEnumerateInstanceLayerProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEnumerateInstanceLayerProperties in sdk");
                                 return NULL;
                             }
                             

                             vkEnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)dlsym(vk_sdk, "vkEnumerateInstanceExtensionProperties");
                             if( vkEnumerateInstanceExtensionProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEnumerateInstanceExtensionProperties in sdk");
                                 return NULL;
                             }
                             

                             vkEnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)dlsym(vk_sdk, "vkEnumerateDeviceLayerProperties");
                             if( vkEnumerateDeviceLayerProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEnumerateDeviceLayerProperties in sdk");
                                 return NULL;
                             }
                             

                             vkEnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)dlsym(vk_sdk, "vkEnumerateDeviceExtensionProperties");
                             if( vkEnumerateDeviceExtensionProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEnumerateDeviceExtensionProperties in sdk");
                                 return NULL;
                             }
                             

                             vkGetDeviceQueue = (PFN_vkGetDeviceQueue)dlsym(vk_sdk, "vkGetDeviceQueue");
                             if( vkGetDeviceQueue == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetDeviceQueue in sdk");
                                 return NULL;
                             }
                             

                             vkQueueSubmit = (PFN_vkQueueSubmit)dlsym(vk_sdk, "vkQueueSubmit");
                             if( vkQueueSubmit == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkQueueSubmit in sdk");
                                 return NULL;
                             }
                             

                             vkQueueWaitIdle = (PFN_vkQueueWaitIdle)dlsym(vk_sdk, "vkQueueWaitIdle");
                             if( vkQueueWaitIdle == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkQueueWaitIdle in sdk");
                                 return NULL;
                             }
                             

                             vkDeviceWaitIdle = (PFN_vkDeviceWaitIdle)dlsym(vk_sdk, "vkDeviceWaitIdle");
                             if( vkDeviceWaitIdle == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDeviceWaitIdle in sdk");
                                 return NULL;
                             }
                             

                             vkAllocateMemory = (PFN_vkAllocateMemory)dlsym(vk_sdk, "vkAllocateMemory");
                             if( vkAllocateMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkAllocateMemory in sdk");
                                 return NULL;
                             }
                             

                             vkFreeMemory = (PFN_vkFreeMemory)dlsym(vk_sdk, "vkFreeMemory");
                             if( vkFreeMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkFreeMemory in sdk");
                                 return NULL;
                             }
                             

                             vkMapMemory = (PFN_vkMapMemory)dlsym(vk_sdk, "vkMapMemory");
                             if( vkMapMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkMapMemory in sdk");
                                 return NULL;
                             }
                             

                             vkUnmapMemory = (PFN_vkUnmapMemory)dlsym(vk_sdk, "vkUnmapMemory");
                             if( vkUnmapMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkUnmapMemory in sdk");
                                 return NULL;
                             }
                             

                             vkFlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)dlsym(vk_sdk, "vkFlushMappedMemoryRanges");
                             if( vkFlushMappedMemoryRanges == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkFlushMappedMemoryRanges in sdk");
                                 return NULL;
                             }
                             

                             vkInvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)dlsym(vk_sdk, "vkInvalidateMappedMemoryRanges");
                             if( vkInvalidateMappedMemoryRanges == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkInvalidateMappedMemoryRanges in sdk");
                                 return NULL;
                             }
                             

                             vkGetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)dlsym(vk_sdk, "vkGetDeviceMemoryCommitment");
                             if( vkGetDeviceMemoryCommitment == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetDeviceMemoryCommitment in sdk");
                                 return NULL;
                             }
                             

                             vkGetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)dlsym(vk_sdk, "vkGetBufferMemoryRequirements");
                             if( vkGetBufferMemoryRequirements == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetBufferMemoryRequirements in sdk");
                                 return NULL;
                             }
                             

                             vkBindBufferMemory = (PFN_vkBindBufferMemory)dlsym(vk_sdk, "vkBindBufferMemory");
                             if( vkBindBufferMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkBindBufferMemory in sdk");
                                 return NULL;
                             }
                             

                             vkGetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)dlsym(vk_sdk, "vkGetImageMemoryRequirements");
                             if( vkGetImageMemoryRequirements == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetImageMemoryRequirements in sdk");
                                 return NULL;
                             }
                             

                             vkBindImageMemory = (PFN_vkBindImageMemory)dlsym(vk_sdk, "vkBindImageMemory");
                             if( vkBindImageMemory == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkBindImageMemory in sdk");
                                 return NULL;
                             }
                             

                             vkGetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)dlsym(vk_sdk, "vkGetImageSparseMemoryRequirements");
                             if( vkGetImageSparseMemoryRequirements == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetImageSparseMemoryRequirements in sdk");
                                 return NULL;
                             }
                             

                             vkGetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)dlsym(vk_sdk, "vkGetPhysicalDeviceSparseImageFormatProperties");
                             if( vkGetPhysicalDeviceSparseImageFormatProperties == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPhysicalDeviceSparseImageFormatProperties in sdk");
                                 return NULL;
                             }
                             

                             vkQueueBindSparse = (PFN_vkQueueBindSparse)dlsym(vk_sdk, "vkQueueBindSparse");
                             if( vkQueueBindSparse == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkQueueBindSparse in sdk");
                                 return NULL;
                             }
                             

                             vkCreateFence = (PFN_vkCreateFence)dlsym(vk_sdk, "vkCreateFence");
                             if( vkCreateFence == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateFence in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyFence = (PFN_vkDestroyFence)dlsym(vk_sdk, "vkDestroyFence");
                             if( vkDestroyFence == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyFence in sdk");
                                 return NULL;
                             }
                             

                             vkResetFences = (PFN_vkResetFences)dlsym(vk_sdk, "vkResetFences");
                             if( vkResetFences == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkResetFences in sdk");
                                 return NULL;
                             }
                             

                             vkGetFenceStatus = (PFN_vkGetFenceStatus)dlsym(vk_sdk, "vkGetFenceStatus");
                             if( vkGetFenceStatus == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetFenceStatus in sdk");
                                 return NULL;
                             }
                             

                             vkWaitForFences = (PFN_vkWaitForFences)dlsym(vk_sdk, "vkWaitForFences");
                             if( vkWaitForFences == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkWaitForFences in sdk");
                                 return NULL;
                             }
                             

                             vkCreateSemaphore = (PFN_vkCreateSemaphore)dlsym(vk_sdk, "vkCreateSemaphore");
                             if( vkCreateSemaphore == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateSemaphore in sdk");
                                 return NULL;
                             }
                             

                             vkDestroySemaphore = (PFN_vkDestroySemaphore)dlsym(vk_sdk, "vkDestroySemaphore");
                             if( vkDestroySemaphore == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroySemaphore in sdk");
                                 return NULL;
                             }
                             

                             vkCreateEvent = (PFN_vkCreateEvent)dlsym(vk_sdk, "vkCreateEvent");
                             if( vkCreateEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateEvent in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyEvent = (PFN_vkDestroyEvent)dlsym(vk_sdk, "vkDestroyEvent");
                             if( vkDestroyEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyEvent in sdk");
                                 return NULL;
                             }
                             

                             vkGetEventStatus = (PFN_vkGetEventStatus)dlsym(vk_sdk, "vkGetEventStatus");
                             if( vkGetEventStatus == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetEventStatus in sdk");
                                 return NULL;
                             }
                             

                             vkSetEvent = (PFN_vkSetEvent)dlsym(vk_sdk, "vkSetEvent");
                             if( vkSetEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkSetEvent in sdk");
                                 return NULL;
                             }
                             

                             vkResetEvent = (PFN_vkResetEvent)dlsym(vk_sdk, "vkResetEvent");
                             if( vkResetEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkResetEvent in sdk");
                                 return NULL;
                             }
                             

                             vkCreateQueryPool = (PFN_vkCreateQueryPool)dlsym(vk_sdk, "vkCreateQueryPool");
                             if( vkCreateQueryPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateQueryPool in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyQueryPool = (PFN_vkDestroyQueryPool)dlsym(vk_sdk, "vkDestroyQueryPool");
                             if( vkDestroyQueryPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyQueryPool in sdk");
                                 return NULL;
                             }
                             

                             vkGetQueryPoolResults = (PFN_vkGetQueryPoolResults)dlsym(vk_sdk, "vkGetQueryPoolResults");
                             if( vkGetQueryPoolResults == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetQueryPoolResults in sdk");
                                 return NULL;
                             }
                             

                             vkCreateBuffer = (PFN_vkCreateBuffer)dlsym(vk_sdk, "vkCreateBuffer");
                             if( vkCreateBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyBuffer = (PFN_vkDestroyBuffer)dlsym(vk_sdk, "vkDestroyBuffer");
                             if( vkDestroyBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCreateBufferView = (PFN_vkCreateBufferView)dlsym(vk_sdk, "vkCreateBufferView");
                             if( vkCreateBufferView == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateBufferView in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyBufferView = (PFN_vkDestroyBufferView)dlsym(vk_sdk, "vkDestroyBufferView");
                             if( vkDestroyBufferView == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyBufferView in sdk");
                                 return NULL;
                             }
                             

                             vkCreateImage = (PFN_vkCreateImage)dlsym(vk_sdk, "vkCreateImage");
                             if( vkCreateImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateImage in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyImage = (PFN_vkDestroyImage)dlsym(vk_sdk, "vkDestroyImage");
                             if( vkDestroyImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyImage in sdk");
                                 return NULL;
                             }
                             

                             vkGetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)dlsym(vk_sdk, "vkGetImageSubresourceLayout");
                             if( vkGetImageSubresourceLayout == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetImageSubresourceLayout in sdk");
                                 return NULL;
                             }
                             

                             vkCreateImageView = (PFN_vkCreateImageView)dlsym(vk_sdk, "vkCreateImageView");
                             if( vkCreateImageView == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateImageView in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyImageView = (PFN_vkDestroyImageView)dlsym(vk_sdk, "vkDestroyImageView");
                             if( vkDestroyImageView == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyImageView in sdk");
                                 return NULL;
                             }
                             

                             vkCreateShaderModule = (PFN_vkCreateShaderModule)dlsym(vk_sdk, "vkCreateShaderModule");
                             if( vkCreateShaderModule == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateShaderModule in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyShaderModule = (PFN_vkDestroyShaderModule)dlsym(vk_sdk, "vkDestroyShaderModule");
                             if( vkDestroyShaderModule == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyShaderModule in sdk");
                                 return NULL;
                             }
                             

                             vkCreatePipelineCache = (PFN_vkCreatePipelineCache)dlsym(vk_sdk, "vkCreatePipelineCache");
                             if( vkCreatePipelineCache == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreatePipelineCache in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyPipelineCache = (PFN_vkDestroyPipelineCache)dlsym(vk_sdk, "vkDestroyPipelineCache");
                             if( vkDestroyPipelineCache == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyPipelineCache in sdk");
                                 return NULL;
                             }
                             

                             vkGetPipelineCacheData = (PFN_vkGetPipelineCacheData)dlsym(vk_sdk, "vkGetPipelineCacheData");
                             if( vkGetPipelineCacheData == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetPipelineCacheData in sdk");
                                 return NULL;
                             }
                             

                             vkMergePipelineCaches = (PFN_vkMergePipelineCaches)dlsym(vk_sdk, "vkMergePipelineCaches");
                             if( vkMergePipelineCaches == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkMergePipelineCaches in sdk");
                                 return NULL;
                             }
                             

                             vkCreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)dlsym(vk_sdk, "vkCreateGraphicsPipelines");
                             if( vkCreateGraphicsPipelines == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateGraphicsPipelines in sdk");
                                 return NULL;
                             }
                             

                             vkCreateComputePipelines = (PFN_vkCreateComputePipelines)dlsym(vk_sdk, "vkCreateComputePipelines");
                             if( vkCreateComputePipelines == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateComputePipelines in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyPipeline = (PFN_vkDestroyPipeline)dlsym(vk_sdk, "vkDestroyPipeline");
                             if( vkDestroyPipeline == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyPipeline in sdk");
                                 return NULL;
                             }
                             

                             vkCreatePipelineLayout = (PFN_vkCreatePipelineLayout)dlsym(vk_sdk, "vkCreatePipelineLayout");
                             if( vkCreatePipelineLayout == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreatePipelineLayout in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)dlsym(vk_sdk, "vkDestroyPipelineLayout");
                             if( vkDestroyPipelineLayout == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyPipelineLayout in sdk");
                                 return NULL;
                             }
                             

                             vkCreateSampler = (PFN_vkCreateSampler)dlsym(vk_sdk, "vkCreateSampler");
                             if( vkCreateSampler == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateSampler in sdk");
                                 return NULL;
                             }
                             

                             vkDestroySampler = (PFN_vkDestroySampler)dlsym(vk_sdk, "vkDestroySampler");
                             if( vkDestroySampler == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroySampler in sdk");
                                 return NULL;
                             }
                             

                             vkCreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)dlsym(vk_sdk, "vkCreateDescriptorSetLayout");
                             if( vkCreateDescriptorSetLayout == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateDescriptorSetLayout in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)dlsym(vk_sdk, "vkDestroyDescriptorSetLayout");
                             if( vkDestroyDescriptorSetLayout == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyDescriptorSetLayout in sdk");
                                 return NULL;
                             }
                             

                             vkCreateDescriptorPool = (PFN_vkCreateDescriptorPool)dlsym(vk_sdk, "vkCreateDescriptorPool");
                             if( vkCreateDescriptorPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateDescriptorPool in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)dlsym(vk_sdk, "vkDestroyDescriptorPool");
                             if( vkDestroyDescriptorPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyDescriptorPool in sdk");
                                 return NULL;
                             }
                             

                             vkResetDescriptorPool = (PFN_vkResetDescriptorPool)dlsym(vk_sdk, "vkResetDescriptorPool");
                             if( vkResetDescriptorPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkResetDescriptorPool in sdk");
                                 return NULL;
                             }
                             

                             vkAllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)dlsym(vk_sdk, "vkAllocateDescriptorSets");
                             if( vkAllocateDescriptorSets == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkAllocateDescriptorSets in sdk");
                                 return NULL;
                             }
                             

                             vkFreeDescriptorSets = (PFN_vkFreeDescriptorSets)dlsym(vk_sdk, "vkFreeDescriptorSets");
                             if( vkFreeDescriptorSets == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkFreeDescriptorSets in sdk");
                                 return NULL;
                             }
                             

                             vkUpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)dlsym(vk_sdk, "vkUpdateDescriptorSets");
                             if( vkUpdateDescriptorSets == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkUpdateDescriptorSets in sdk");
                                 return NULL;
                             }
                             

                             vkCreateFramebuffer = (PFN_vkCreateFramebuffer)dlsym(vk_sdk, "vkCreateFramebuffer");
                             if( vkCreateFramebuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateFramebuffer in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyFramebuffer = (PFN_vkDestroyFramebuffer)dlsym(vk_sdk, "vkDestroyFramebuffer");
                             if( vkDestroyFramebuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyFramebuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCreateRenderPass = (PFN_vkCreateRenderPass)dlsym(vk_sdk, "vkCreateRenderPass");
                             if( vkCreateRenderPass == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateRenderPass in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyRenderPass = (PFN_vkDestroyRenderPass)dlsym(vk_sdk, "vkDestroyRenderPass");
                             if( vkDestroyRenderPass == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyRenderPass in sdk");
                                 return NULL;
                             }
                             

                             vkGetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)dlsym(vk_sdk, "vkGetRenderAreaGranularity");
                             if( vkGetRenderAreaGranularity == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkGetRenderAreaGranularity in sdk");
                                 return NULL;
                             }
                             

                             vkCreateCommandPool = (PFN_vkCreateCommandPool)dlsym(vk_sdk, "vkCreateCommandPool");
                             if( vkCreateCommandPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCreateCommandPool in sdk");
                                 return NULL;
                             }
                             

                             vkDestroyCommandPool = (PFN_vkDestroyCommandPool)dlsym(vk_sdk, "vkDestroyCommandPool");
                             if( vkDestroyCommandPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkDestroyCommandPool in sdk");
                                 return NULL;
                             }
                             

                             vkResetCommandPool = (PFN_vkResetCommandPool)dlsym(vk_sdk, "vkResetCommandPool");
                             if( vkResetCommandPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkResetCommandPool in sdk");
                                 return NULL;
                             }
                             

                             vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)dlsym(vk_sdk, "vkAllocateCommandBuffers");
                             if( vkAllocateCommandBuffers == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkAllocateCommandBuffers in sdk");
                                 return NULL;
                             }
                             

                             vkFreeCommandBuffers = (PFN_vkFreeCommandBuffers)dlsym(vk_sdk, "vkFreeCommandBuffers");
                             if( vkFreeCommandBuffers == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkFreeCommandBuffers in sdk");
                                 return NULL;
                             }
                             

                             vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)dlsym(vk_sdk, "vkBeginCommandBuffer");
                             if( vkBeginCommandBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkBeginCommandBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkEndCommandBuffer = (PFN_vkEndCommandBuffer)dlsym(vk_sdk, "vkEndCommandBuffer");
                             if( vkEndCommandBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkEndCommandBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkResetCommandBuffer = (PFN_vkResetCommandBuffer)dlsym(vk_sdk, "vkResetCommandBuffer");
                             if( vkResetCommandBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkResetCommandBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBindPipeline = (PFN_vkCmdBindPipeline)dlsym(vk_sdk, "vkCmdBindPipeline");
                             if( vkCmdBindPipeline == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBindPipeline in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetViewport = (PFN_vkCmdSetViewport)dlsym(vk_sdk, "vkCmdSetViewport");
                             if( vkCmdSetViewport == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetViewport in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetScissor = (PFN_vkCmdSetScissor)dlsym(vk_sdk, "vkCmdSetScissor");
                             if( vkCmdSetScissor == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetScissor in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetLineWidth = (PFN_vkCmdSetLineWidth)dlsym(vk_sdk, "vkCmdSetLineWidth");
                             if( vkCmdSetLineWidth == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetLineWidth in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetDepthBias = (PFN_vkCmdSetDepthBias)dlsym(vk_sdk, "vkCmdSetDepthBias");
                             if( vkCmdSetDepthBias == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetDepthBias in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)dlsym(vk_sdk, "vkCmdSetBlendConstants");
                             if( vkCmdSetBlendConstants == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetBlendConstants in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)dlsym(vk_sdk, "vkCmdSetDepthBounds");
                             if( vkCmdSetDepthBounds == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetDepthBounds in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)dlsym(vk_sdk, "vkCmdSetStencilCompareMask");
                             if( vkCmdSetStencilCompareMask == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetStencilCompareMask in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)dlsym(vk_sdk, "vkCmdSetStencilWriteMask");
                             if( vkCmdSetStencilWriteMask == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetStencilWriteMask in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetStencilReference = (PFN_vkCmdSetStencilReference)dlsym(vk_sdk, "vkCmdSetStencilReference");
                             if( vkCmdSetStencilReference == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetStencilReference in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)dlsym(vk_sdk, "vkCmdBindDescriptorSets");
                             if( vkCmdBindDescriptorSets == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBindDescriptorSets in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)dlsym(vk_sdk, "vkCmdBindIndexBuffer");
                             if( vkCmdBindIndexBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBindIndexBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)dlsym(vk_sdk, "vkCmdBindVertexBuffers");
                             if( vkCmdBindVertexBuffers == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBindVertexBuffers in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDraw = (PFN_vkCmdDraw)dlsym(vk_sdk, "vkCmdDraw");
                             if( vkCmdDraw == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDraw in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDrawIndexed = (PFN_vkCmdDrawIndexed)dlsym(vk_sdk, "vkCmdDrawIndexed");
                             if( vkCmdDrawIndexed == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDrawIndexed in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDrawIndirect = (PFN_vkCmdDrawIndirect)dlsym(vk_sdk, "vkCmdDrawIndirect");
                             if( vkCmdDrawIndirect == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDrawIndirect in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)dlsym(vk_sdk, "vkCmdDrawIndexedIndirect");
                             if( vkCmdDrawIndexedIndirect == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDrawIndexedIndirect in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDispatch = (PFN_vkCmdDispatch)dlsym(vk_sdk, "vkCmdDispatch");
                             if( vkCmdDispatch == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDispatch in sdk");
                                 return NULL;
                             }
                             

                             vkCmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)dlsym(vk_sdk, "vkCmdDispatchIndirect");
                             if( vkCmdDispatchIndirect == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdDispatchIndirect in sdk");
                                 return NULL;
                             }
                             

                             vkCmdCopyBuffer = (PFN_vkCmdCopyBuffer)dlsym(vk_sdk, "vkCmdCopyBuffer");
                             if( vkCmdCopyBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdCopyBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdCopyImage = (PFN_vkCmdCopyImage)dlsym(vk_sdk, "vkCmdCopyImage");
                             if( vkCmdCopyImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdCopyImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBlitImage = (PFN_vkCmdBlitImage)dlsym(vk_sdk, "vkCmdBlitImage");
                             if( vkCmdBlitImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBlitImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)dlsym(vk_sdk, "vkCmdCopyBufferToImage");
                             if( vkCmdCopyBufferToImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdCopyBufferToImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)dlsym(vk_sdk, "vkCmdCopyImageToBuffer");
                             if( vkCmdCopyImageToBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdCopyImageToBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)dlsym(vk_sdk, "vkCmdUpdateBuffer");
                             if( vkCmdUpdateBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdUpdateBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdFillBuffer = (PFN_vkCmdFillBuffer)dlsym(vk_sdk, "vkCmdFillBuffer");
                             if( vkCmdFillBuffer == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdFillBuffer in sdk");
                                 return NULL;
                             }
                             

                             vkCmdClearColorImage = (PFN_vkCmdClearColorImage)dlsym(vk_sdk, "vkCmdClearColorImage");
                             if( vkCmdClearColorImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdClearColorImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)dlsym(vk_sdk, "vkCmdClearDepthStencilImage");
                             if( vkCmdClearDepthStencilImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdClearDepthStencilImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdClearAttachments = (PFN_vkCmdClearAttachments)dlsym(vk_sdk, "vkCmdClearAttachments");
                             if( vkCmdClearAttachments == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdClearAttachments in sdk");
                                 return NULL;
                             }
                             

                             vkCmdResolveImage = (PFN_vkCmdResolveImage)dlsym(vk_sdk, "vkCmdResolveImage");
                             if( vkCmdResolveImage == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdResolveImage in sdk");
                                 return NULL;
                             }
                             

                             vkCmdSetEvent = (PFN_vkCmdSetEvent)dlsym(vk_sdk, "vkCmdSetEvent");
                             if( vkCmdSetEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdSetEvent in sdk");
                                 return NULL;
                             }
                             

                             vkCmdResetEvent = (PFN_vkCmdResetEvent)dlsym(vk_sdk, "vkCmdResetEvent");
                             if( vkCmdResetEvent == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdResetEvent in sdk");
                                 return NULL;
                             }
                             

                             vkCmdWaitEvents = (PFN_vkCmdWaitEvents)dlsym(vk_sdk, "vkCmdWaitEvents");
                             if( vkCmdWaitEvents == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdWaitEvents in sdk");
                                 return NULL;
                             }
                             

                             vkCmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)dlsym(vk_sdk, "vkCmdPipelineBarrier");
                             if( vkCmdPipelineBarrier == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdPipelineBarrier in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBeginQuery = (PFN_vkCmdBeginQuery)dlsym(vk_sdk, "vkCmdBeginQuery");
                             if( vkCmdBeginQuery == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBeginQuery in sdk");
                                 return NULL;
                             }
                             

                             vkCmdEndQuery = (PFN_vkCmdEndQuery)dlsym(vk_sdk, "vkCmdEndQuery");
                             if( vkCmdEndQuery == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdEndQuery in sdk");
                                 return NULL;
                             }
                             

                             vkCmdResetQueryPool = (PFN_vkCmdResetQueryPool)dlsym(vk_sdk, "vkCmdResetQueryPool");
                             if( vkCmdResetQueryPool == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdResetQueryPool in sdk");
                                 return NULL;
                             }
                             

                             vkCmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)dlsym(vk_sdk, "vkCmdWriteTimestamp");
                             if( vkCmdWriteTimestamp == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdWriteTimestamp in sdk");
                                 return NULL;
                             }
                             

                             vkCmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)dlsym(vk_sdk, "vkCmdCopyQueryPoolResults");
                             if( vkCmdCopyQueryPoolResults == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdCopyQueryPoolResults in sdk");
                                 return NULL;
                             }
                             

                             vkCmdPushConstants = (PFN_vkCmdPushConstants)dlsym(vk_sdk, "vkCmdPushConstants");
                             if( vkCmdPushConstants == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdPushConstants in sdk");
                                 return NULL;
                             }
                             

                             vkCmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)dlsym(vk_sdk, "vkCmdBeginRenderPass");
                             if( vkCmdBeginRenderPass == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdBeginRenderPass in sdk");
                                 return NULL;
                             }
                             

                             vkCmdNextSubpass = (PFN_vkCmdNextSubpass)dlsym(vk_sdk, "vkCmdNextSubpass");
                             if( vkCmdNextSubpass == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdNextSubpass in sdk");
                                 return NULL;
                             }
                             

                             vkCmdEndRenderPass = (PFN_vkCmdEndRenderPass)dlsym(vk_sdk, "vkCmdEndRenderPass");
                             if( vkCmdEndRenderPass == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdEndRenderPass in sdk");
                                 return NULL;
                             }
                             

                             vkCmdExecuteCommands = (PFN_vkCmdExecuteCommands)dlsym(vk_sdk, "vkCmdExecuteCommands");
                             if( vkCmdExecuteCommands == NULL ) {
                                 PyErr_SetString(PyExc_ImportError,
                                                 "Can't load vkCmdExecuteCommands in sdk");
                                 return NULL;
                             }
                             

                Py_INCREF(Py_None);
                return Py_None;
            }
        
                typedef struct { PyObject_HEAD VkOffset2D *base; }
                PyVkOffset2D;
                
                static void PyVkOffset2D_del(PyVkOffset2D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkOffset2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkOffset2D *self;
                    self = (PyVkOffset2D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkOffset2D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkOffset2D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkOffset2D_setx(PyVkOffset2D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with x");
                        return -1;
                    }
                (self->base)->x = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkOffset2D_getx(PyVkOffset2D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->x);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkOffset2D_sety(PyVkOffset2D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with y");
                        return -1;
                    }
                (self->base)->y = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkOffset2D_gety(PyVkOffset2D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->y);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkOffset2D_getsetters[] = {
                    
                        { "x", (getter)PyVkOffset2D_getx, (setter)PyVkOffset2D_setx, "", NULL},
                    
                        { "y", (getter)PyVkOffset2D_gety, (setter)PyVkOffset2D_sety, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkOffset2DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkOffset2D", sizeof(PyVkOffset2D), 0,
                    (destructor)PyVkOffset2D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkOffset2D object",0,0,0,0,0,0,0,0,
                    PyVkOffset2D_getsetters,0,0,0,0,0,0,0,PyVkOffset2D_new,};
            
                typedef struct { PyObject_HEAD VkOffset3D *base; }
                PyVkOffset3D;
                
                static void PyVkOffset3D_del(PyVkOffset3D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkOffset3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkOffset3D *self;
                    self = (PyVkOffset3D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkOffset3D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkOffset3D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkOffset3D_setx(PyVkOffset3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with x");
                        return -1;
                    }
                (self->base)->x = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkOffset3D_getx(PyVkOffset3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->x);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkOffset3D_sety(PyVkOffset3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with y");
                        return -1;
                    }
                (self->base)->y = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkOffset3D_gety(PyVkOffset3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->y);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkOffset3D_setz(PyVkOffset3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with z");
                        return -1;
                    }
                (self->base)->z = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkOffset3D_getz(PyVkOffset3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->z);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkOffset3D_getsetters[] = {
                    
                        { "x", (getter)PyVkOffset3D_getx, (setter)PyVkOffset3D_setx, "", NULL},
                    
                        { "y", (getter)PyVkOffset3D_gety, (setter)PyVkOffset3D_sety, "", NULL},
                    
                        { "z", (getter)PyVkOffset3D_getz, (setter)PyVkOffset3D_setz, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkOffset3DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkOffset3D", sizeof(PyVkOffset3D), 0,
                    (destructor)PyVkOffset3D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkOffset3D object",0,0,0,0,0,0,0,0,
                    PyVkOffset3D_getsetters,0,0,0,0,0,0,0,PyVkOffset3D_new,};
            
                typedef struct { PyObject_HEAD VkExtent2D *base; }
                PyVkExtent2D;
                
                static void PyVkExtent2D_del(PyVkExtent2D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExtent2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExtent2D *self;
                    self = (PyVkExtent2D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExtent2D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExtent2D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExtent2D_setwidth(PyVkExtent2D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with width");
                        return -1;
                    }
                (self->base)->width = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtent2D_getwidth(PyVkExtent2D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->width);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkExtent2D_setheight(PyVkExtent2D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with height");
                        return -1;
                    }
                (self->base)->height = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtent2D_getheight(PyVkExtent2D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->height);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExtent2D_getsetters[] = {
                    
                        { "width", (getter)PyVkExtent2D_getwidth, (setter)PyVkExtent2D_setwidth, "", NULL},
                    
                        { "height", (getter)PyVkExtent2D_getheight, (setter)PyVkExtent2D_setheight, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExtent2DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExtent2D", sizeof(PyVkExtent2D), 0,
                    (destructor)PyVkExtent2D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExtent2D object",0,0,0,0,0,0,0,0,
                    PyVkExtent2D_getsetters,0,0,0,0,0,0,0,PyVkExtent2D_new,};
            
                typedef struct { PyObject_HEAD VkExtent3D *base; }
                PyVkExtent3D;
                
                static void PyVkExtent3D_del(PyVkExtent3D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExtent3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExtent3D *self;
                    self = (PyVkExtent3D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExtent3D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExtent3D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExtent3D_setwidth(PyVkExtent3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with width");
                        return -1;
                    }
                (self->base)->width = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtent3D_getwidth(PyVkExtent3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->width);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkExtent3D_setheight(PyVkExtent3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with height");
                        return -1;
                    }
                (self->base)->height = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtent3D_getheight(PyVkExtent3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->height);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkExtent3D_setdepth(PyVkExtent3D *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with depth");
                        return -1;
                    }
                (self->base)->depth = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtent3D_getdepth(PyVkExtent3D *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->depth);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExtent3D_getsetters[] = {
                    
                        { "width", (getter)PyVkExtent3D_getwidth, (setter)PyVkExtent3D_setwidth, "", NULL},
                    
                        { "height", (getter)PyVkExtent3D_getheight, (setter)PyVkExtent3D_setheight, "", NULL},
                    
                        { "depth", (getter)PyVkExtent3D_getdepth, (setter)PyVkExtent3D_setdepth, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExtent3DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExtent3D", sizeof(PyVkExtent3D), 0,
                    (destructor)PyVkExtent3D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExtent3D object",0,0,0,0,0,0,0,0,
                    PyVkExtent3D_getsetters,0,0,0,0,0,0,0,PyVkExtent3D_new,};
            
                typedef struct { PyObject_HEAD VkViewport *base; }
                PyVkViewport;
                
                static void PyVkViewport_del(PyVkViewport* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkViewport_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkViewport *self;
                    self = (PyVkViewport *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkViewport));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkViewport");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkViewport_setx(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with x");
                        return -1;
                    }
                (self->base)->x = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_getx(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->x);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkViewport_sety(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with y");
                        return -1;
                    }
                (self->base)->y = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_gety(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->y);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkViewport_setwidth(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with width");
                        return -1;
                    }
                (self->base)->width = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_getwidth(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->width);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkViewport_setheight(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with height");
                        return -1;
                    }
                (self->base)->height = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_getheight(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->height);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkViewport_setminDepth(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minDepth");
                        return -1;
                    }
                (self->base)->minDepth = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_getminDepth(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepth);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkViewport_setmaxDepth(PyVkViewport *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDepth");
                        return -1;
                    }
                (self->base)->maxDepth = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkViewport_getmaxDepth(PyVkViewport *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepth);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkViewport_getsetters[] = {
                    
                        { "x", (getter)PyVkViewport_getx, (setter)PyVkViewport_setx, "", NULL},
                    
                        { "y", (getter)PyVkViewport_gety, (setter)PyVkViewport_sety, "", NULL},
                    
                        { "width", (getter)PyVkViewport_getwidth, (setter)PyVkViewport_setwidth, "", NULL},
                    
                        { "height", (getter)PyVkViewport_getheight, (setter)PyVkViewport_setheight, "", NULL},
                    
                        { "minDepth", (getter)PyVkViewport_getminDepth, (setter)PyVkViewport_setminDepth, "", NULL},
                    
                        { "maxDepth", (getter)PyVkViewport_getmaxDepth, (setter)PyVkViewport_setmaxDepth, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkViewportType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkViewport", sizeof(PyVkViewport), 0,
                    (destructor)PyVkViewport_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkViewport object",0,0,0,0,0,0,0,0,
                    PyVkViewport_getsetters,0,0,0,0,0,0,0,PyVkViewport_new,};
            
                typedef struct { PyObject_HEAD VkRect2D *base; }
                PyVkRect2D;
                
                static void PyVkRect2D_del(PyVkRect2D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkRect2D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkRect2D *self;
                    self = (PyVkRect2D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkRect2D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkRect2D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkRect2D_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkRect2DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkRect2D", sizeof(PyVkRect2D), 0,
                    (destructor)PyVkRect2D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkRect2D object",0,0,0,0,0,0,0,0,
                    PyVkRect2D_getsetters,0,0,0,0,0,0,0,PyVkRect2D_new,};
            
#ifdef hackdefine

                typedef struct { PyObject_HEAD VkRect3D *base; }
                PyVkRect3D;
                
                static void PyVkRect3D_del(PyVkRect3D* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkRect3D_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkRect3D *self;
                    self = (PyVkRect3D *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkRect3D));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkRect3D");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkRect3D_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkRect3DType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkRect3D", sizeof(PyVkRect3D), 0,
                    (destructor)PyVkRect3D_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkRect3D object",0,0,0,0,0,0,0,0,
                    PyVkRect3D_getsetters,0,0,0,0,0,0,0,PyVkRect3D_new,};
            
#endif

                typedef struct { PyObject_HEAD VkClearRect *base; }
                PyVkClearRect;
                
                static void PyVkClearRect_del(PyVkClearRect* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkClearRect_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkClearRect *self;
                    self = (PyVkClearRect *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkClearRect));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkClearRect");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkClearRect_setbaseArrayLayer(PyVkClearRect *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with baseArrayLayer");
                        return -1;
                    }
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkClearRect_getbaseArrayLayer(PyVkClearRect *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkClearRect_setlayerCount(PyVkClearRect *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with layerCount");
                        return -1;
                    }
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkClearRect_getlayerCount(PyVkClearRect *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkClearRect_getsetters[] = {
                    
                        { "baseArrayLayer", (getter)PyVkClearRect_getbaseArrayLayer, (setter)PyVkClearRect_setbaseArrayLayer, "", NULL},
                    
                        { "layerCount", (getter)PyVkClearRect_getlayerCount, (setter)PyVkClearRect_setlayerCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkClearRectType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkClearRect", sizeof(PyVkClearRect), 0,
                    (destructor)PyVkClearRect_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkClearRect object",0,0,0,0,0,0,0,0,
                    PyVkClearRect_getsetters,0,0,0,0,0,0,0,PyVkClearRect_new,};
            
                typedef struct { PyObject_HEAD VkComponentMapping *base; }
                PyVkComponentMapping;
                
                static void PyVkComponentMapping_del(PyVkComponentMapping* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkComponentMapping_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkComponentMapping *self;
                    self = (PyVkComponentMapping *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkComponentMapping));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkComponentMapping");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkComponentMapping_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkComponentMappingType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkComponentMapping", sizeof(PyVkComponentMapping), 0,
                    (destructor)PyVkComponentMapping_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkComponentMapping object",0,0,0,0,0,0,0,0,
                    PyVkComponentMapping_getsetters,0,0,0,0,0,0,0,PyVkComponentMapping_new,};
            
                typedef struct { PyObject_HEAD VkPhysicalDeviceProperties *base; }
                PyVkPhysicalDeviceProperties;
                
                static void PyVkPhysicalDeviceProperties_del(PyVkPhysicalDeviceProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPhysicalDeviceProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPhysicalDeviceProperties *self;
                    self = (PyVkPhysicalDeviceProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPhysicalDeviceProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPhysicalDeviceProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPhysicalDeviceProperties_setapiVersion(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with apiVersion");
                        return -1;
                    }
                (self->base)->apiVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getapiVersion(PyVkPhysicalDeviceProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceProperties_setdriverVersion(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with driverVersion");
                        return -1;
                    }
                (self->base)->driverVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getdriverVersion(PyVkPhysicalDeviceProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->driverVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceProperties_setvendorID(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with vendorID");
                        return -1;
                    }
                (self->base)->vendorID = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getvendorID(PyVkPhysicalDeviceProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->vendorID);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceProperties_setdeviceID(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with deviceID");
                        return -1;
                    }
                (self->base)->deviceID = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getdeviceID(PyVkPhysicalDeviceProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->deviceID);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceProperties_setdeviceName(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with deviceName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            strcpy((self->base)->deviceName, tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getdeviceName(PyVkPhysicalDeviceProperties *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->deviceName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceProperties_setpipelineCacheUUID(PyVkPhysicalDeviceProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pipelineCacheUUID");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                uint8_t tmp = (uint8_t) PyLong_AsLong(PyList_GetItem(value, i));
                ((self->base)->pipelineCacheUUID)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceProperties_getpipelineCacheUUID(PyVkPhysicalDeviceProperties *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->pipelineCacheUUID) / sizeof((self->base)->pipelineCacheUUID[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyLong_FromLong((long) (self->base)->pipelineCacheUUID[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPhysicalDeviceProperties_getsetters[] = {
                    
                        { "apiVersion", (getter)PyVkPhysicalDeviceProperties_getapiVersion, (setter)PyVkPhysicalDeviceProperties_setapiVersion, "", NULL},
                    
                        { "driverVersion", (getter)PyVkPhysicalDeviceProperties_getdriverVersion, (setter)PyVkPhysicalDeviceProperties_setdriverVersion, "", NULL},
                    
                        { "vendorID", (getter)PyVkPhysicalDeviceProperties_getvendorID, (setter)PyVkPhysicalDeviceProperties_setvendorID, "", NULL},
                    
                        { "deviceID", (getter)PyVkPhysicalDeviceProperties_getdeviceID, (setter)PyVkPhysicalDeviceProperties_setdeviceID, "", NULL},
                    
                        { "deviceName", (getter)PyVkPhysicalDeviceProperties_getdeviceName, (setter)PyVkPhysicalDeviceProperties_setdeviceName, "", NULL},
                    
                        { "pipelineCacheUUID", (getter)PyVkPhysicalDeviceProperties_getpipelineCacheUUID, (setter)PyVkPhysicalDeviceProperties_setpipelineCacheUUID, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPhysicalDevicePropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPhysicalDeviceProperties", sizeof(PyVkPhysicalDeviceProperties), 0,
                    (destructor)PyVkPhysicalDeviceProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPhysicalDeviceProperties object",0,0,0,0,0,0,0,0,
                    PyVkPhysicalDeviceProperties_getsetters,0,0,0,0,0,0,0,PyVkPhysicalDeviceProperties_new,};
            
                typedef struct { PyObject_HEAD VkExtensionProperties *base; }
                PyVkExtensionProperties;
                
                static void PyVkExtensionProperties_del(PyVkExtensionProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExtensionProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExtensionProperties *self;
                    self = (PyVkExtensionProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExtensionProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExtensionProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExtensionProperties_setextensionName(PyVkExtensionProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with extensionName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            strcpy((self->base)->extensionName, tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkExtensionProperties_getextensionName(PyVkExtensionProperties *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->extensionName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkExtensionProperties_setspecVersion(PyVkExtensionProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with specVersion");
                        return -1;
                    }
                (self->base)->specVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkExtensionProperties_getspecVersion(PyVkExtensionProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExtensionProperties_getsetters[] = {
                    
                        { "extensionName", (getter)PyVkExtensionProperties_getextensionName, (setter)PyVkExtensionProperties_setextensionName, "", NULL},
                    
                        { "specVersion", (getter)PyVkExtensionProperties_getspecVersion, (setter)PyVkExtensionProperties_setspecVersion, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExtensionPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExtensionProperties", sizeof(PyVkExtensionProperties), 0,
                    (destructor)PyVkExtensionProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExtensionProperties object",0,0,0,0,0,0,0,0,
                    PyVkExtensionProperties_getsetters,0,0,0,0,0,0,0,PyVkExtensionProperties_new,};
            
                typedef struct { PyObject_HEAD VkLayerProperties *base; }
                PyVkLayerProperties;
                
                static void PyVkLayerProperties_del(PyVkLayerProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkLayerProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkLayerProperties *self;
                    self = (PyVkLayerProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkLayerProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkLayerProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkLayerProperties_setlayerName(PyVkLayerProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with layerName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            strcpy((self->base)->layerName, tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkLayerProperties_getlayerName(PyVkLayerProperties *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->layerName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkLayerProperties_setspecVersion(PyVkLayerProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with specVersion");
                        return -1;
                    }
                (self->base)->specVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkLayerProperties_getspecVersion(PyVkLayerProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->specVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkLayerProperties_setimplementationVersion(PyVkLayerProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with implementationVersion");
                        return -1;
                    }
                (self->base)->implementationVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkLayerProperties_getimplementationVersion(PyVkLayerProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->implementationVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkLayerProperties_setdescription(PyVkLayerProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with description");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            strcpy((self->base)->description, tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkLayerProperties_getdescription(PyVkLayerProperties *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->description);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkLayerProperties_getsetters[] = {
                    
                        { "layerName", (getter)PyVkLayerProperties_getlayerName, (setter)PyVkLayerProperties_setlayerName, "", NULL},
                    
                        { "specVersion", (getter)PyVkLayerProperties_getspecVersion, (setter)PyVkLayerProperties_setspecVersion, "", NULL},
                    
                        { "implementationVersion", (getter)PyVkLayerProperties_getimplementationVersion, (setter)PyVkLayerProperties_setimplementationVersion, "", NULL},
                    
                        { "description", (getter)PyVkLayerProperties_getdescription, (setter)PyVkLayerProperties_setdescription, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkLayerPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkLayerProperties", sizeof(PyVkLayerProperties), 0,
                    (destructor)PyVkLayerProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkLayerProperties object",0,0,0,0,0,0,0,0,
                    PyVkLayerProperties_getsetters,0,0,0,0,0,0,0,PyVkLayerProperties_new,};
            
                typedef struct { PyObject_HEAD VkApplicationInfo *base; }
                PyVkApplicationInfo;
                
                static void PyVkApplicationInfo_del(PyVkApplicationInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkApplicationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkApplicationInfo *self;
                    self = (PyVkApplicationInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkApplicationInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkApplicationInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkApplicationInfo_setpNext(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getpNext(PyVkApplicationInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkApplicationInfo_setpApplicationName(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pApplicationName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->pApplicationName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getpApplicationName(PyVkApplicationInfo *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->pApplicationName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkApplicationInfo_setapplicationVersion(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with applicationVersion");
                        return -1;
                    }
                (self->base)->applicationVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getapplicationVersion(PyVkApplicationInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->applicationVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkApplicationInfo_setpEngineName(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pEngineName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->pEngineName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getpEngineName(PyVkApplicationInfo *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->pEngineName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkApplicationInfo_setengineVersion(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with engineVersion");
                        return -1;
                    }
                (self->base)->engineVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getengineVersion(PyVkApplicationInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->engineVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkApplicationInfo_setapiVersion(PyVkApplicationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with apiVersion");
                        return -1;
                    }
                (self->base)->apiVersion = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkApplicationInfo_getapiVersion(PyVkApplicationInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->apiVersion);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkApplicationInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkApplicationInfo_getpNext, (setter)PyVkApplicationInfo_setpNext, "", NULL},
                    
                        { "pApplicationName", (getter)PyVkApplicationInfo_getpApplicationName, (setter)PyVkApplicationInfo_setpApplicationName, "", NULL},
                    
                        { "applicationVersion", (getter)PyVkApplicationInfo_getapplicationVersion, (setter)PyVkApplicationInfo_setapplicationVersion, "", NULL},
                    
                        { "pEngineName", (getter)PyVkApplicationInfo_getpEngineName, (setter)PyVkApplicationInfo_setpEngineName, "", NULL},
                    
                        { "engineVersion", (getter)PyVkApplicationInfo_getengineVersion, (setter)PyVkApplicationInfo_setengineVersion, "", NULL},
                    
                        { "apiVersion", (getter)PyVkApplicationInfo_getapiVersion, (setter)PyVkApplicationInfo_setapiVersion, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkApplicationInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkApplicationInfo", sizeof(PyVkApplicationInfo), 0,
                    (destructor)PyVkApplicationInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkApplicationInfo object",0,0,0,0,0,0,0,0,
                    PyVkApplicationInfo_getsetters,0,0,0,0,0,0,0,PyVkApplicationInfo_new,};
            
                typedef struct { PyObject_HEAD VkAllocationCallbacks *base; }
                PyVkAllocationCallbacks;
                
                static void PyVkAllocationCallbacks_del(PyVkAllocationCallbacks* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkAllocationCallbacks_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkAllocationCallbacks *self;
                    self = (PyVkAllocationCallbacks *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkAllocationCallbacks));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkAllocationCallbacks");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkAllocationCallbacks_setpUserData(PyVkAllocationCallbacks *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pUserData");
                        return -1;
                    }
                (self->base)->pUserData = NULL;
                    return 0;
                }
                
                static PyObject * PyVkAllocationCallbacks_getpUserData(PyVkAllocationCallbacks *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkAllocationCallbacks_getsetters[] = {
                    
                        { "pUserData", (getter)PyVkAllocationCallbacks_getpUserData, (setter)PyVkAllocationCallbacks_setpUserData, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkAllocationCallbacksType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkAllocationCallbacks", sizeof(PyVkAllocationCallbacks), 0,
                    (destructor)PyVkAllocationCallbacks_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkAllocationCallbacks object",0,0,0,0,0,0,0,0,
                    PyVkAllocationCallbacks_getsetters,0,0,0,0,0,0,0,PyVkAllocationCallbacks_new,};
            
                typedef struct { PyObject_HEAD VkDeviceQueueCreateInfo *base; }
                PyVkDeviceQueueCreateInfo;
                
                static void PyVkDeviceQueueCreateInfo_del(PyVkDeviceQueueCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDeviceQueueCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDeviceQueueCreateInfo *self;
                    self = (PyVkDeviceQueueCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDeviceQueueCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDeviceQueueCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDeviceQueueCreateInfo_setpNext(PyVkDeviceQueueCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDeviceQueueCreateInfo_getpNext(PyVkDeviceQueueCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceQueueCreateInfo_setqueueFamilyIndex(PyVkDeviceQueueCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueFamilyIndex");
                        return -1;
                    }
                (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDeviceQueueCreateInfo_getqueueFamilyIndex(PyVkDeviceQueueCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceQueueCreateInfo_setqueueCount(PyVkDeviceQueueCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueCount");
                        return -1;
                    }
                (self->base)->queueCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDeviceQueueCreateInfo_getqueueCount(PyVkDeviceQueueCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceQueueCreateInfo_setpQueuePriorities(PyVkDeviceQueueCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pQueuePriorities");
                        return -1;
                    }
                
            float tmp = (float) PyFloat_AsDouble(value);
            float *t = malloc(sizeof(float));
            memcpy(t, &tmp, sizeof(float));
            (self->base)->pQueuePriorities = t;
            
                    return 0;
                }
                
                static PyObject * PyVkDeviceQueueCreateInfo_getpQueuePriorities(PyVkDeviceQueueCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (*((self->base)->pQueuePriorities)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDeviceQueueCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDeviceQueueCreateInfo_getpNext, (setter)PyVkDeviceQueueCreateInfo_setpNext, "", NULL},
                    
                        { "queueFamilyIndex", (getter)PyVkDeviceQueueCreateInfo_getqueueFamilyIndex, (setter)PyVkDeviceQueueCreateInfo_setqueueFamilyIndex, "", NULL},
                    
                        { "queueCount", (getter)PyVkDeviceQueueCreateInfo_getqueueCount, (setter)PyVkDeviceQueueCreateInfo_setqueueCount, "", NULL},
                    
                        { "pQueuePriorities", (getter)PyVkDeviceQueueCreateInfo_getpQueuePriorities, (setter)PyVkDeviceQueueCreateInfo_setpQueuePriorities, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDeviceQueueCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDeviceQueueCreateInfo", sizeof(PyVkDeviceQueueCreateInfo), 0,
                    (destructor)PyVkDeviceQueueCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDeviceQueueCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkDeviceQueueCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkDeviceQueueCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkDeviceCreateInfo *base; }
                PyVkDeviceCreateInfo;
                
                static void PyVkDeviceCreateInfo_del(PyVkDeviceCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDeviceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDeviceCreateInfo *self;
                    self = (PyVkDeviceCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDeviceCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDeviceCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDeviceCreateInfo_setpNext(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getpNext(PyVkDeviceCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceCreateInfo_setqueueCreateInfoCount(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueCreateInfoCount");
                        return -1;
                    }
                (self->base)->queueCreateInfoCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getqueueCreateInfoCount(PyVkDeviceCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueCreateInfoCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceCreateInfo_setenabledLayerCount(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with enabledLayerCount");
                        return -1;
                    }
                (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getenabledLayerCount(PyVkDeviceCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceCreateInfo_setppEnabledLayerNames(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with ppEnabledLayerNames");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            char** tmp = malloc(sizeof(char*)*nb + 1);
            int i;
            for (i = 0; i < nb; i++) {
                PyObject* ascii_str = PyUnicode_AsASCIIString(
                PyList_GetItem(value, i));
                char* tmp2 = PyBytes_AsString(ascii_str);
                tmp[i] = strdup(tmp2);
                Py_DECREF(ascii_str);
            }
            tmp[i] = NULL; // sentinel
            (self->base)->ppEnabledLayerNames = tmp;
            
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getppEnabledLayerNames(PyVkDeviceCreateInfo *self, void *closure){
                
            if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
            PyObject* value = PyList_New(0);
            int i = 0;
            while ((self->base)->ppEnabledLayerNames[i] != NULL) {
                PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
                PyList_Append(value, py_tmp);
                i++;
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceCreateInfo_setenabledExtensionCount(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with enabledExtensionCount");
                        return -1;
                    }
                (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getenabledExtensionCount(PyVkDeviceCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDeviceCreateInfo_setppEnabledExtensionNames(PyVkDeviceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with ppEnabledExtensionNames");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            char** tmp = malloc(sizeof(char*)*nb + 1);
            int i;
            for (i = 0; i < nb; i++) {
                PyObject* ascii_str = PyUnicode_AsASCIIString(
                PyList_GetItem(value, i));
                char* tmp2 = PyBytes_AsString(ascii_str);
                tmp[i] = strdup(tmp2);
                Py_DECREF(ascii_str);
            }
            tmp[i] = NULL; // sentinel
            (self->base)->ppEnabledExtensionNames = tmp;
            
                    return 0;
                }
                
                static PyObject * PyVkDeviceCreateInfo_getppEnabledExtensionNames(PyVkDeviceCreateInfo *self, void *closure){
                
            if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
            PyObject* value = PyList_New(0);
            int i = 0;
            while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
                PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
                PyList_Append(value, py_tmp);
                i++;
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDeviceCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDeviceCreateInfo_getpNext, (setter)PyVkDeviceCreateInfo_setpNext, "", NULL},
                    
                        { "queueCreateInfoCount", (getter)PyVkDeviceCreateInfo_getqueueCreateInfoCount, (setter)PyVkDeviceCreateInfo_setqueueCreateInfoCount, "", NULL},
                    
                        { "enabledLayerCount", (getter)PyVkDeviceCreateInfo_getenabledLayerCount, (setter)PyVkDeviceCreateInfo_setenabledLayerCount, "", NULL},
                    
                        { "ppEnabledLayerNames", (getter)PyVkDeviceCreateInfo_getppEnabledLayerNames, (setter)PyVkDeviceCreateInfo_setppEnabledLayerNames, "", NULL},
                    
                        { "enabledExtensionCount", (getter)PyVkDeviceCreateInfo_getenabledExtensionCount, (setter)PyVkDeviceCreateInfo_setenabledExtensionCount, "", NULL},
                    
                        { "ppEnabledExtensionNames", (getter)PyVkDeviceCreateInfo_getppEnabledExtensionNames, (setter)PyVkDeviceCreateInfo_setppEnabledExtensionNames, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDeviceCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDeviceCreateInfo", sizeof(PyVkDeviceCreateInfo), 0,
                    (destructor)PyVkDeviceCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDeviceCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkDeviceCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkDeviceCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkInstanceCreateInfo *base; }
                PyVkInstanceCreateInfo;
                
                static void PyVkInstanceCreateInfo_del(PyVkInstanceCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkInstanceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkInstanceCreateInfo *self;
                    self = (PyVkInstanceCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkInstanceCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkInstanceCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkInstanceCreateInfo_setpNext(PyVkInstanceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkInstanceCreateInfo_getpNext(PyVkInstanceCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkInstanceCreateInfo_setenabledLayerCount(PyVkInstanceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with enabledLayerCount");
                        return -1;
                    }
                (self->base)->enabledLayerCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkInstanceCreateInfo_getenabledLayerCount(PyVkInstanceCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->enabledLayerCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkInstanceCreateInfo_setppEnabledLayerNames(PyVkInstanceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with ppEnabledLayerNames");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            char** tmp = malloc(sizeof(char*)*nb + 1);
            int i;
            for (i = 0; i < nb; i++) {
                PyObject* ascii_str = PyUnicode_AsASCIIString(
                PyList_GetItem(value, i));
                char* tmp2 = PyBytes_AsString(ascii_str);
                tmp[i] = strdup(tmp2);
                Py_DECREF(ascii_str);
            }
            tmp[i] = NULL; // sentinel
            (self->base)->ppEnabledLayerNames = tmp;
            
                    return 0;
                }
                
                static PyObject * PyVkInstanceCreateInfo_getppEnabledLayerNames(PyVkInstanceCreateInfo *self, void *closure){
                
            if ((self->base)->ppEnabledLayerNames[0] == NULL) return PyList_New(0);;
            PyObject* value = PyList_New(0);
            int i = 0;
            while ((self->base)->ppEnabledLayerNames[i] != NULL) {
                PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledLayerNames[i]);
                PyList_Append(value, py_tmp);
                i++;
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkInstanceCreateInfo_setenabledExtensionCount(PyVkInstanceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with enabledExtensionCount");
                        return -1;
                    }
                (self->base)->enabledExtensionCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkInstanceCreateInfo_getenabledExtensionCount(PyVkInstanceCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->enabledExtensionCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkInstanceCreateInfo_setppEnabledExtensionNames(PyVkInstanceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with ppEnabledExtensionNames");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            char** tmp = malloc(sizeof(char*)*nb + 1);
            int i;
            for (i = 0; i < nb; i++) {
                PyObject* ascii_str = PyUnicode_AsASCIIString(
                PyList_GetItem(value, i));
                char* tmp2 = PyBytes_AsString(ascii_str);
                tmp[i] = strdup(tmp2);
                Py_DECREF(ascii_str);
            }
            tmp[i] = NULL; // sentinel
            (self->base)->ppEnabledExtensionNames = tmp;
            
                    return 0;
                }
                
                static PyObject * PyVkInstanceCreateInfo_getppEnabledExtensionNames(PyVkInstanceCreateInfo *self, void *closure){
                
            if ((self->base)->ppEnabledExtensionNames[0] == NULL) return PyList_New(0);;
            PyObject* value = PyList_New(0);
            int i = 0;
            while ((self->base)->ppEnabledExtensionNames[i] != NULL) {
                PyObject* py_tmp = PyUnicode_FromString((const char *) (self->base)->ppEnabledExtensionNames[i]);
                PyList_Append(value, py_tmp);
                i++;
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkInstanceCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkInstanceCreateInfo_getpNext, (setter)PyVkInstanceCreateInfo_setpNext, "", NULL},
                    
                        { "enabledLayerCount", (getter)PyVkInstanceCreateInfo_getenabledLayerCount, (setter)PyVkInstanceCreateInfo_setenabledLayerCount, "", NULL},
                    
                        { "ppEnabledLayerNames", (getter)PyVkInstanceCreateInfo_getppEnabledLayerNames, (setter)PyVkInstanceCreateInfo_setppEnabledLayerNames, "", NULL},
                    
                        { "enabledExtensionCount", (getter)PyVkInstanceCreateInfo_getenabledExtensionCount, (setter)PyVkInstanceCreateInfo_setenabledExtensionCount, "", NULL},
                    
                        { "ppEnabledExtensionNames", (getter)PyVkInstanceCreateInfo_getppEnabledExtensionNames, (setter)PyVkInstanceCreateInfo_setppEnabledExtensionNames, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkInstanceCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkInstanceCreateInfo", sizeof(PyVkInstanceCreateInfo), 0,
                    (destructor)PyVkInstanceCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkInstanceCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkInstanceCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkInstanceCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkQueueFamilyProperties *base; }
                PyVkQueueFamilyProperties;
                
                static void PyVkQueueFamilyProperties_del(PyVkQueueFamilyProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkQueueFamilyProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkQueueFamilyProperties *self;
                    self = (PyVkQueueFamilyProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkQueueFamilyProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkQueueFamilyProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkQueueFamilyProperties_setqueueCount(PyVkQueueFamilyProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueCount");
                        return -1;
                    }
                (self->base)->queueCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkQueueFamilyProperties_getqueueCount(PyVkQueueFamilyProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkQueueFamilyProperties_settimestampValidBits(PyVkQueueFamilyProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with timestampValidBits");
                        return -1;
                    }
                (self->base)->timestampValidBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkQueueFamilyProperties_gettimestampValidBits(PyVkQueueFamilyProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->timestampValidBits);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkQueueFamilyProperties_getsetters[] = {
                    
                        { "queueCount", (getter)PyVkQueueFamilyProperties_getqueueCount, (setter)PyVkQueueFamilyProperties_setqueueCount, "", NULL},
                    
                        { "timestampValidBits", (getter)PyVkQueueFamilyProperties_gettimestampValidBits, (setter)PyVkQueueFamilyProperties_settimestampValidBits, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkQueueFamilyPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkQueueFamilyProperties", sizeof(PyVkQueueFamilyProperties), 0,
                    (destructor)PyVkQueueFamilyProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkQueueFamilyProperties object",0,0,0,0,0,0,0,0,
                    PyVkQueueFamilyProperties_getsetters,0,0,0,0,0,0,0,PyVkQueueFamilyProperties_new,};
            
                typedef struct { PyObject_HEAD VkPhysicalDeviceMemoryProperties *base; }
                PyVkPhysicalDeviceMemoryProperties;
                
                static void PyVkPhysicalDeviceMemoryProperties_del(PyVkPhysicalDeviceMemoryProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPhysicalDeviceMemoryProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPhysicalDeviceMemoryProperties *self;
                    self = (PyVkPhysicalDeviceMemoryProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPhysicalDeviceMemoryProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPhysicalDeviceMemoryProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPhysicalDeviceMemoryProperties_setmemoryTypeCount(PyVkPhysicalDeviceMemoryProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with memoryTypeCount");
                        return -1;
                    }
                (self->base)->memoryTypeCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceMemoryProperties_setmemoryHeapCount(PyVkPhysicalDeviceMemoryProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with memoryHeapCount");
                        return -1;
                    }
                (self->base)->memoryHeapCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount(PyVkPhysicalDeviceMemoryProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->memoryHeapCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPhysicalDeviceMemoryProperties_getsetters[] = {
                    
                        { "memoryTypeCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryTypeCount, (setter)PyVkPhysicalDeviceMemoryProperties_setmemoryTypeCount, "", NULL},
                    
                        { "memoryHeapCount", (getter)PyVkPhysicalDeviceMemoryProperties_getmemoryHeapCount, (setter)PyVkPhysicalDeviceMemoryProperties_setmemoryHeapCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPhysicalDeviceMemoryPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPhysicalDeviceMemoryProperties", sizeof(PyVkPhysicalDeviceMemoryProperties), 0,
                    (destructor)PyVkPhysicalDeviceMemoryProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPhysicalDeviceMemoryProperties object",0,0,0,0,0,0,0,0,
                    PyVkPhysicalDeviceMemoryProperties_getsetters,0,0,0,0,0,0,0,PyVkPhysicalDeviceMemoryProperties_new,};
            
                typedef struct { PyObject_HEAD VkMemoryAllocateInfo *base; }
                PyVkMemoryAllocateInfo;
                
                static void PyVkMemoryAllocateInfo_del(PyVkMemoryAllocateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMemoryAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMemoryAllocateInfo *self;
                    self = (PyVkMemoryAllocateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMemoryAllocateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMemoryAllocateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMemoryAllocateInfo_setpNext(PyVkMemoryAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkMemoryAllocateInfo_getpNext(PyVkMemoryAllocateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkMemoryAllocateInfo_setmemoryTypeIndex(PyVkMemoryAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with memoryTypeIndex");
                        return -1;
                    }
                (self->base)->memoryTypeIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkMemoryAllocateInfo_getmemoryTypeIndex(PyVkMemoryAllocateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMemoryAllocateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkMemoryAllocateInfo_getpNext, (setter)PyVkMemoryAllocateInfo_setpNext, "", NULL},
                    
                        { "memoryTypeIndex", (getter)PyVkMemoryAllocateInfo_getmemoryTypeIndex, (setter)PyVkMemoryAllocateInfo_setmemoryTypeIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMemoryAllocateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMemoryAllocateInfo", sizeof(PyVkMemoryAllocateInfo), 0,
                    (destructor)PyVkMemoryAllocateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMemoryAllocateInfo object",0,0,0,0,0,0,0,0,
                    PyVkMemoryAllocateInfo_getsetters,0,0,0,0,0,0,0,PyVkMemoryAllocateInfo_new,};
            
                typedef struct { PyObject_HEAD VkMemoryRequirements *base; }
                PyVkMemoryRequirements;
                
                static void PyVkMemoryRequirements_del(PyVkMemoryRequirements* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMemoryRequirements *self;
                    self = (PyVkMemoryRequirements *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMemoryRequirements));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMemoryRequirements");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMemoryRequirements_setmemoryTypeBits(PyVkMemoryRequirements *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with memoryTypeBits");
                        return -1;
                    }
                (self->base)->memoryTypeBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkMemoryRequirements_getmemoryTypeBits(PyVkMemoryRequirements *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->memoryTypeBits);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMemoryRequirements_getsetters[] = {
                    
                        { "memoryTypeBits", (getter)PyVkMemoryRequirements_getmemoryTypeBits, (setter)PyVkMemoryRequirements_setmemoryTypeBits, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMemoryRequirementsType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMemoryRequirements", sizeof(PyVkMemoryRequirements), 0,
                    (destructor)PyVkMemoryRequirements_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMemoryRequirements object",0,0,0,0,0,0,0,0,
                    PyVkMemoryRequirements_getsetters,0,0,0,0,0,0,0,PyVkMemoryRequirements_new,};
            
                typedef struct { PyObject_HEAD VkSparseImageFormatProperties *base; }
                PyVkSparseImageFormatProperties;
                
                static void PyVkSparseImageFormatProperties_del(PyVkSparseImageFormatProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseImageFormatProperties *self;
                    self = (PyVkSparseImageFormatProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseImageFormatProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseImageFormatProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkSparseImageFormatProperties_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkSparseImageFormatPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseImageFormatProperties", sizeof(PyVkSparseImageFormatProperties), 0,
                    (destructor)PyVkSparseImageFormatProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseImageFormatProperties object",0,0,0,0,0,0,0,0,
                    PyVkSparseImageFormatProperties_getsetters,0,0,0,0,0,0,0,PyVkSparseImageFormatProperties_new,};
            
                typedef struct { PyObject_HEAD VkSparseImageMemoryRequirements *base; }
                PyVkSparseImageMemoryRequirements;
                
                static void PyVkSparseImageMemoryRequirements_del(PyVkSparseImageMemoryRequirements* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseImageMemoryRequirements_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseImageMemoryRequirements *self;
                    self = (PyVkSparseImageMemoryRequirements *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseImageMemoryRequirements));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseImageMemoryRequirements");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSparseImageMemoryRequirements_setimageMipTailFirstLod(PyVkSparseImageMemoryRequirements *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with imageMipTailFirstLod");
                        return -1;
                    }
                (self->base)->imageMipTailFirstLod = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod(PyVkSparseImageMemoryRequirements *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->imageMipTailFirstLod);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSparseImageMemoryRequirements_getsetters[] = {
                    
                        { "imageMipTailFirstLod", (getter)PyVkSparseImageMemoryRequirements_getimageMipTailFirstLod, (setter)PyVkSparseImageMemoryRequirements_setimageMipTailFirstLod, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSparseImageMemoryRequirementsType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseImageMemoryRequirements", sizeof(PyVkSparseImageMemoryRequirements), 0,
                    (destructor)PyVkSparseImageMemoryRequirements_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseImageMemoryRequirements object",0,0,0,0,0,0,0,0,
                    PyVkSparseImageMemoryRequirements_getsetters,0,0,0,0,0,0,0,PyVkSparseImageMemoryRequirements_new,};
            
                typedef struct { PyObject_HEAD VkMemoryType *base; }
                PyVkMemoryType;
                
                static void PyVkMemoryType_del(PyVkMemoryType* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMemoryType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMemoryType *self;
                    self = (PyVkMemoryType *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMemoryType));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMemoryType");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMemoryType_setheapIndex(PyVkMemoryType *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with heapIndex");
                        return -1;
                    }
                (self->base)->heapIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkMemoryType_getheapIndex(PyVkMemoryType *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->heapIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMemoryType_getsetters[] = {
                    
                        { "heapIndex", (getter)PyVkMemoryType_getheapIndex, (setter)PyVkMemoryType_setheapIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMemoryTypeType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMemoryType", sizeof(PyVkMemoryType), 0,
                    (destructor)PyVkMemoryType_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMemoryType object",0,0,0,0,0,0,0,0,
                    PyVkMemoryType_getsetters,0,0,0,0,0,0,0,PyVkMemoryType_new,};
            
                typedef struct { PyObject_HEAD VkMemoryHeap *base; }
                PyVkMemoryHeap;
                
                static void PyVkMemoryHeap_del(PyVkMemoryHeap* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMemoryHeap_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMemoryHeap *self;
                    self = (PyVkMemoryHeap *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMemoryHeap));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMemoryHeap");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkMemoryHeap_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkMemoryHeapType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMemoryHeap", sizeof(PyVkMemoryHeap), 0,
                    (destructor)PyVkMemoryHeap_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMemoryHeap object",0,0,0,0,0,0,0,0,
                    PyVkMemoryHeap_getsetters,0,0,0,0,0,0,0,PyVkMemoryHeap_new,};
            
                typedef struct { PyObject_HEAD VkMappedMemoryRange *base; }
                PyVkMappedMemoryRange;
                
                static void PyVkMappedMemoryRange_del(PyVkMappedMemoryRange* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMappedMemoryRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMappedMemoryRange *self;
                    self = (PyVkMappedMemoryRange *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMappedMemoryRange));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMappedMemoryRange");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMappedMemoryRange_setpNext(PyVkMappedMemoryRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkMappedMemoryRange_getpNext(PyVkMappedMemoryRange *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMappedMemoryRange_getsetters[] = {
                    
                        { "pNext", (getter)PyVkMappedMemoryRange_getpNext, (setter)PyVkMappedMemoryRange_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMappedMemoryRangeType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMappedMemoryRange", sizeof(PyVkMappedMemoryRange), 0,
                    (destructor)PyVkMappedMemoryRange_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMappedMemoryRange object",0,0,0,0,0,0,0,0,
                    PyVkMappedMemoryRange_getsetters,0,0,0,0,0,0,0,PyVkMappedMemoryRange_new,};
            
                typedef struct { PyObject_HEAD VkFormatProperties *base; }
                PyVkFormatProperties;
                
                static void PyVkFormatProperties_del(PyVkFormatProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkFormatProperties *self;
                    self = (PyVkFormatProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkFormatProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkFormatProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkFormatProperties_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkFormatPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkFormatProperties", sizeof(PyVkFormatProperties), 0,
                    (destructor)PyVkFormatProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkFormatProperties object",0,0,0,0,0,0,0,0,
                    PyVkFormatProperties_getsetters,0,0,0,0,0,0,0,PyVkFormatProperties_new,};
            
                typedef struct { PyObject_HEAD VkImageFormatProperties *base; }
                PyVkImageFormatProperties;
                
                static void PyVkImageFormatProperties_del(PyVkImageFormatProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageFormatProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageFormatProperties *self;
                    self = (PyVkImageFormatProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageFormatProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageFormatProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageFormatProperties_setmaxMipLevels(PyVkImageFormatProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxMipLevels");
                        return -1;
                    }
                (self->base)->maxMipLevels = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageFormatProperties_getmaxMipLevels(PyVkImageFormatProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxMipLevels);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageFormatProperties_setmaxArrayLayers(PyVkImageFormatProperties *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxArrayLayers");
                        return -1;
                    }
                (self->base)->maxArrayLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageFormatProperties_getmaxArrayLayers(PyVkImageFormatProperties *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxArrayLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageFormatProperties_getsetters[] = {
                    
                        { "maxMipLevels", (getter)PyVkImageFormatProperties_getmaxMipLevels, (setter)PyVkImageFormatProperties_setmaxMipLevels, "", NULL},
                    
                        { "maxArrayLayers", (getter)PyVkImageFormatProperties_getmaxArrayLayers, (setter)PyVkImageFormatProperties_setmaxArrayLayers, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageFormatPropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageFormatProperties", sizeof(PyVkImageFormatProperties), 0,
                    (destructor)PyVkImageFormatProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageFormatProperties object",0,0,0,0,0,0,0,0,
                    PyVkImageFormatProperties_getsetters,0,0,0,0,0,0,0,PyVkImageFormatProperties_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorBufferInfo *base; }
                PyVkDescriptorBufferInfo;
                
                static void PyVkDescriptorBufferInfo_del(PyVkDescriptorBufferInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorBufferInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorBufferInfo *self;
                    self = (PyVkDescriptorBufferInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorBufferInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorBufferInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkDescriptorBufferInfo_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkDescriptorBufferInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorBufferInfo", sizeof(PyVkDescriptorBufferInfo), 0,
                    (destructor)PyVkDescriptorBufferInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorBufferInfo object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorBufferInfo_getsetters,0,0,0,0,0,0,0,PyVkDescriptorBufferInfo_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorImageInfo *base; }
                PyVkDescriptorImageInfo;
                
                static void PyVkDescriptorImageInfo_del(PyVkDescriptorImageInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorImageInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorImageInfo *self;
                    self = (PyVkDescriptorImageInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorImageInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorImageInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkDescriptorImageInfo_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkDescriptorImageInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorImageInfo", sizeof(PyVkDescriptorImageInfo), 0,
                    (destructor)PyVkDescriptorImageInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorImageInfo object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorImageInfo_getsetters,0,0,0,0,0,0,0,PyVkDescriptorImageInfo_new,};
            
                typedef struct { PyObject_HEAD VkWriteDescriptorSet *base; }
                PyVkWriteDescriptorSet;
                
                static void PyVkWriteDescriptorSet_del(PyVkWriteDescriptorSet* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkWriteDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkWriteDescriptorSet *self;
                    self = (PyVkWriteDescriptorSet *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkWriteDescriptorSet));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkWriteDescriptorSet");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkWriteDescriptorSet_setpNext(PyVkWriteDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkWriteDescriptorSet_getpNext(PyVkWriteDescriptorSet *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWriteDescriptorSet_setdstBinding(PyVkWriteDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstBinding");
                        return -1;
                    }
                (self->base)->dstBinding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkWriteDescriptorSet_getdstBinding(PyVkWriteDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWriteDescriptorSet_setdstArrayElement(PyVkWriteDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstArrayElement");
                        return -1;
                    }
                (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkWriteDescriptorSet_getdstArrayElement(PyVkWriteDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWriteDescriptorSet_setdescriptorCount(PyVkWriteDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with descriptorCount");
                        return -1;
                    }
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkWriteDescriptorSet_getdescriptorCount(PyVkWriteDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkWriteDescriptorSet_getsetters[] = {
                    
                        { "pNext", (getter)PyVkWriteDescriptorSet_getpNext, (setter)PyVkWriteDescriptorSet_setpNext, "", NULL},
                    
                        { "dstBinding", (getter)PyVkWriteDescriptorSet_getdstBinding, (setter)PyVkWriteDescriptorSet_setdstBinding, "", NULL},
                    
                        { "dstArrayElement", (getter)PyVkWriteDescriptorSet_getdstArrayElement, (setter)PyVkWriteDescriptorSet_setdstArrayElement, "", NULL},
                    
                        { "descriptorCount", (getter)PyVkWriteDescriptorSet_getdescriptorCount, (setter)PyVkWriteDescriptorSet_setdescriptorCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkWriteDescriptorSetType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkWriteDescriptorSet", sizeof(PyVkWriteDescriptorSet), 0,
                    (destructor)PyVkWriteDescriptorSet_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkWriteDescriptorSet object",0,0,0,0,0,0,0,0,
                    PyVkWriteDescriptorSet_getsetters,0,0,0,0,0,0,0,PyVkWriteDescriptorSet_new,};
            
                typedef struct { PyObject_HEAD VkCopyDescriptorSet *base; }
                PyVkCopyDescriptorSet;
                
                static void PyVkCopyDescriptorSet_del(PyVkCopyDescriptorSet* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkCopyDescriptorSet_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkCopyDescriptorSet *self;
                    self = (PyVkCopyDescriptorSet *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkCopyDescriptorSet));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkCopyDescriptorSet");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkCopyDescriptorSet_setpNext(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getpNext(PyVkCopyDescriptorSet *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCopyDescriptorSet_setsrcBinding(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with srcBinding");
                        return -1;
                    }
                (self->base)->srcBinding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getsrcBinding(PyVkCopyDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->srcBinding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCopyDescriptorSet_setsrcArrayElement(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with srcArrayElement");
                        return -1;
                    }
                (self->base)->srcArrayElement = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getsrcArrayElement(PyVkCopyDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->srcArrayElement);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCopyDescriptorSet_setdstBinding(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstBinding");
                        return -1;
                    }
                (self->base)->dstBinding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getdstBinding(PyVkCopyDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstBinding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCopyDescriptorSet_setdstArrayElement(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstArrayElement");
                        return -1;
                    }
                (self->base)->dstArrayElement = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getdstArrayElement(PyVkCopyDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstArrayElement);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCopyDescriptorSet_setdescriptorCount(PyVkCopyDescriptorSet *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with descriptorCount");
                        return -1;
                    }
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCopyDescriptorSet_getdescriptorCount(PyVkCopyDescriptorSet *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkCopyDescriptorSet_getsetters[] = {
                    
                        { "pNext", (getter)PyVkCopyDescriptorSet_getpNext, (setter)PyVkCopyDescriptorSet_setpNext, "", NULL},
                    
                        { "srcBinding", (getter)PyVkCopyDescriptorSet_getsrcBinding, (setter)PyVkCopyDescriptorSet_setsrcBinding, "", NULL},
                    
                        { "srcArrayElement", (getter)PyVkCopyDescriptorSet_getsrcArrayElement, (setter)PyVkCopyDescriptorSet_setsrcArrayElement, "", NULL},
                    
                        { "dstBinding", (getter)PyVkCopyDescriptorSet_getdstBinding, (setter)PyVkCopyDescriptorSet_setdstBinding, "", NULL},
                    
                        { "dstArrayElement", (getter)PyVkCopyDescriptorSet_getdstArrayElement, (setter)PyVkCopyDescriptorSet_setdstArrayElement, "", NULL},
                    
                        { "descriptorCount", (getter)PyVkCopyDescriptorSet_getdescriptorCount, (setter)PyVkCopyDescriptorSet_setdescriptorCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkCopyDescriptorSetType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkCopyDescriptorSet", sizeof(PyVkCopyDescriptorSet), 0,
                    (destructor)PyVkCopyDescriptorSet_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkCopyDescriptorSet object",0,0,0,0,0,0,0,0,
                    PyVkCopyDescriptorSet_getsetters,0,0,0,0,0,0,0,PyVkCopyDescriptorSet_new,};
            
                typedef struct { PyObject_HEAD VkBufferCreateInfo *base; }
                PyVkBufferCreateInfo;
                
                static void PyVkBufferCreateInfo_del(PyVkBufferCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBufferCreateInfo *self;
                    self = (PyVkBufferCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBufferCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBufferCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkBufferCreateInfo_setpNext(PyVkBufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkBufferCreateInfo_getpNext(PyVkBufferCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBufferCreateInfo_setqueueFamilyIndexCount(PyVkBufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueFamilyIndexCount");
                        return -1;
                    }
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBufferCreateInfo_getqueueFamilyIndexCount(PyVkBufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBufferCreateInfo_setpQueueFamilyIndices(PyVkBufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pQueueFamilyIndices");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pQueueFamilyIndices = t;
            
                    return 0;
                }
                
                static PyObject * PyVkBufferCreateInfo_getpQueueFamilyIndices(PyVkBufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkBufferCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkBufferCreateInfo_getpNext, (setter)PyVkBufferCreateInfo_setpNext, "", NULL},
                    
                        { "queueFamilyIndexCount", (getter)PyVkBufferCreateInfo_getqueueFamilyIndexCount, (setter)PyVkBufferCreateInfo_setqueueFamilyIndexCount, "", NULL},
                    
                        { "pQueueFamilyIndices", (getter)PyVkBufferCreateInfo_getpQueueFamilyIndices, (setter)PyVkBufferCreateInfo_setpQueueFamilyIndices, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkBufferCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBufferCreateInfo", sizeof(PyVkBufferCreateInfo), 0,
                    (destructor)PyVkBufferCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBufferCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkBufferCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkBufferCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkBufferViewCreateInfo *base; }
                PyVkBufferViewCreateInfo;
                
                static void PyVkBufferViewCreateInfo_del(PyVkBufferViewCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBufferViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBufferViewCreateInfo *self;
                    self = (PyVkBufferViewCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBufferViewCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBufferViewCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkBufferViewCreateInfo_setpNext(PyVkBufferViewCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkBufferViewCreateInfo_getpNext(PyVkBufferViewCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkBufferViewCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkBufferViewCreateInfo_getpNext, (setter)PyVkBufferViewCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkBufferViewCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBufferViewCreateInfo", sizeof(PyVkBufferViewCreateInfo), 0,
                    (destructor)PyVkBufferViewCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBufferViewCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkBufferViewCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkBufferViewCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkImageSubresource *base; }
                PyVkImageSubresource;
                
                static void PyVkImageSubresource_del(PyVkImageSubresource* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageSubresource_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageSubresource *self;
                    self = (PyVkImageSubresource *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageSubresource));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageSubresource");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageSubresource_setmipLevel(PyVkImageSubresource *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mipLevel");
                        return -1;
                    }
                (self->base)->mipLevel = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresource_getmipLevel(PyVkImageSubresource *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresource_setarrayLayer(PyVkImageSubresource *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with arrayLayer");
                        return -1;
                    }
                (self->base)->arrayLayer = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresource_getarrayLayer(PyVkImageSubresource *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayer);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageSubresource_getsetters[] = {
                    
                        { "mipLevel", (getter)PyVkImageSubresource_getmipLevel, (setter)PyVkImageSubresource_setmipLevel, "", NULL},
                    
                        { "arrayLayer", (getter)PyVkImageSubresource_getarrayLayer, (setter)PyVkImageSubresource_setarrayLayer, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageSubresourceType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageSubresource", sizeof(PyVkImageSubresource), 0,
                    (destructor)PyVkImageSubresource_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageSubresource object",0,0,0,0,0,0,0,0,
                    PyVkImageSubresource_getsetters,0,0,0,0,0,0,0,PyVkImageSubresource_new,};
            
                typedef struct { PyObject_HEAD VkImageSubresourceLayers *base; }
                PyVkImageSubresourceLayers;
                
                static void PyVkImageSubresourceLayers_del(PyVkImageSubresourceLayers* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageSubresourceLayers_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageSubresourceLayers *self;
                    self = (PyVkImageSubresourceLayers *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageSubresourceLayers));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageSubresourceLayers");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageSubresourceLayers_setmipLevel(PyVkImageSubresourceLayers *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mipLevel");
                        return -1;
                    }
                (self->base)->mipLevel = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceLayers_getmipLevel(PyVkImageSubresourceLayers *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->mipLevel);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresourceLayers_setbaseArrayLayer(PyVkImageSubresourceLayers *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with baseArrayLayer");
                        return -1;
                    }
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceLayers_getbaseArrayLayer(PyVkImageSubresourceLayers *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresourceLayers_setlayerCount(PyVkImageSubresourceLayers *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with layerCount");
                        return -1;
                    }
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceLayers_getlayerCount(PyVkImageSubresourceLayers *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageSubresourceLayers_getsetters[] = {
                    
                        { "mipLevel", (getter)PyVkImageSubresourceLayers_getmipLevel, (setter)PyVkImageSubresourceLayers_setmipLevel, "", NULL},
                    
                        { "baseArrayLayer", (getter)PyVkImageSubresourceLayers_getbaseArrayLayer, (setter)PyVkImageSubresourceLayers_setbaseArrayLayer, "", NULL},
                    
                        { "layerCount", (getter)PyVkImageSubresourceLayers_getlayerCount, (setter)PyVkImageSubresourceLayers_setlayerCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageSubresourceLayersType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageSubresourceLayers", sizeof(PyVkImageSubresourceLayers), 0,
                    (destructor)PyVkImageSubresourceLayers_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageSubresourceLayers object",0,0,0,0,0,0,0,0,
                    PyVkImageSubresourceLayers_getsetters,0,0,0,0,0,0,0,PyVkImageSubresourceLayers_new,};
            
                typedef struct { PyObject_HEAD VkImageSubresourceRange *base; }
                PyVkImageSubresourceRange;
                
                static void PyVkImageSubresourceRange_del(PyVkImageSubresourceRange* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageSubresourceRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageSubresourceRange *self;
                    self = (PyVkImageSubresourceRange *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageSubresourceRange));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageSubresourceRange");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageSubresourceRange_setbaseMipLevel(PyVkImageSubresourceRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with baseMipLevel");
                        return -1;
                    }
                (self->base)->baseMipLevel = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceRange_getbaseMipLevel(PyVkImageSubresourceRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->baseMipLevel);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresourceRange_setlevelCount(PyVkImageSubresourceRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with levelCount");
                        return -1;
                    }
                (self->base)->levelCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceRange_getlevelCount(PyVkImageSubresourceRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->levelCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresourceRange_setbaseArrayLayer(PyVkImageSubresourceRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with baseArrayLayer");
                        return -1;
                    }
                (self->base)->baseArrayLayer = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceRange_getbaseArrayLayer(PyVkImageSubresourceRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->baseArrayLayer);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageSubresourceRange_setlayerCount(PyVkImageSubresourceRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with layerCount");
                        return -1;
                    }
                (self->base)->layerCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageSubresourceRange_getlayerCount(PyVkImageSubresourceRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->layerCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageSubresourceRange_getsetters[] = {
                    
                        { "baseMipLevel", (getter)PyVkImageSubresourceRange_getbaseMipLevel, (setter)PyVkImageSubresourceRange_setbaseMipLevel, "", NULL},
                    
                        { "levelCount", (getter)PyVkImageSubresourceRange_getlevelCount, (setter)PyVkImageSubresourceRange_setlevelCount, "", NULL},
                    
                        { "baseArrayLayer", (getter)PyVkImageSubresourceRange_getbaseArrayLayer, (setter)PyVkImageSubresourceRange_setbaseArrayLayer, "", NULL},
                    
                        { "layerCount", (getter)PyVkImageSubresourceRange_getlayerCount, (setter)PyVkImageSubresourceRange_setlayerCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageSubresourceRangeType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageSubresourceRange", sizeof(PyVkImageSubresourceRange), 0,
                    (destructor)PyVkImageSubresourceRange_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageSubresourceRange object",0,0,0,0,0,0,0,0,
                    PyVkImageSubresourceRange_getsetters,0,0,0,0,0,0,0,PyVkImageSubresourceRange_new,};
            
                typedef struct { PyObject_HEAD VkMemoryBarrier *base; }
                PyVkMemoryBarrier;
                
                static void PyVkMemoryBarrier_del(PyVkMemoryBarrier* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMemoryBarrier *self;
                    self = (PyVkMemoryBarrier *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMemoryBarrier));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMemoryBarrier");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMemoryBarrier_setpNext(PyVkMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkMemoryBarrier_getpNext(PyVkMemoryBarrier *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMemoryBarrier_getsetters[] = {
                    
                        { "pNext", (getter)PyVkMemoryBarrier_getpNext, (setter)PyVkMemoryBarrier_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMemoryBarrierType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMemoryBarrier", sizeof(PyVkMemoryBarrier), 0,
                    (destructor)PyVkMemoryBarrier_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMemoryBarrier object",0,0,0,0,0,0,0,0,
                    PyVkMemoryBarrier_getsetters,0,0,0,0,0,0,0,PyVkMemoryBarrier_new,};
            
                typedef struct { PyObject_HEAD VkBufferMemoryBarrier *base; }
                PyVkBufferMemoryBarrier;
                
                static void PyVkBufferMemoryBarrier_del(PyVkBufferMemoryBarrier* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBufferMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBufferMemoryBarrier *self;
                    self = (PyVkBufferMemoryBarrier *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBufferMemoryBarrier));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBufferMemoryBarrier");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkBufferMemoryBarrier_setpNext(PyVkBufferMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkBufferMemoryBarrier_getpNext(PyVkBufferMemoryBarrier *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBufferMemoryBarrier_setsrcQueueFamilyIndex(PyVkBufferMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with srcQueueFamilyIndex");
                        return -1;
                    }
                (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBufferMemoryBarrier_setdstQueueFamilyIndex(PyVkBufferMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstQueueFamilyIndex");
                        return -1;
                    }
                (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBufferMemoryBarrier_getdstQueueFamilyIndex(PyVkBufferMemoryBarrier *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkBufferMemoryBarrier_getsetters[] = {
                    
                        { "pNext", (getter)PyVkBufferMemoryBarrier_getpNext, (setter)PyVkBufferMemoryBarrier_setpNext, "", NULL},
                    
                        { "srcQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getsrcQueueFamilyIndex, (setter)PyVkBufferMemoryBarrier_setsrcQueueFamilyIndex, "", NULL},
                    
                        { "dstQueueFamilyIndex", (getter)PyVkBufferMemoryBarrier_getdstQueueFamilyIndex, (setter)PyVkBufferMemoryBarrier_setdstQueueFamilyIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkBufferMemoryBarrierType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBufferMemoryBarrier", sizeof(PyVkBufferMemoryBarrier), 0,
                    (destructor)PyVkBufferMemoryBarrier_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBufferMemoryBarrier object",0,0,0,0,0,0,0,0,
                    PyVkBufferMemoryBarrier_getsetters,0,0,0,0,0,0,0,PyVkBufferMemoryBarrier_new,};
            
                typedef struct { PyObject_HEAD VkImageMemoryBarrier *base; }
                PyVkImageMemoryBarrier;
                
                static void PyVkImageMemoryBarrier_del(PyVkImageMemoryBarrier* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageMemoryBarrier_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageMemoryBarrier *self;
                    self = (PyVkImageMemoryBarrier *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageMemoryBarrier));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageMemoryBarrier");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageMemoryBarrier_setpNext(PyVkImageMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkImageMemoryBarrier_getpNext(PyVkImageMemoryBarrier *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageMemoryBarrier_setsrcQueueFamilyIndex(PyVkImageMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with srcQueueFamilyIndex");
                        return -1;
                    }
                (self->base)->srcQueueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageMemoryBarrier_getsrcQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->srcQueueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageMemoryBarrier_setdstQueueFamilyIndex(PyVkImageMemoryBarrier *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstQueueFamilyIndex");
                        return -1;
                    }
                (self->base)->dstQueueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageMemoryBarrier_getdstQueueFamilyIndex(PyVkImageMemoryBarrier *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstQueueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageMemoryBarrier_getsetters[] = {
                    
                        { "pNext", (getter)PyVkImageMemoryBarrier_getpNext, (setter)PyVkImageMemoryBarrier_setpNext, "", NULL},
                    
                        { "srcQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getsrcQueueFamilyIndex, (setter)PyVkImageMemoryBarrier_setsrcQueueFamilyIndex, "", NULL},
                    
                        { "dstQueueFamilyIndex", (getter)PyVkImageMemoryBarrier_getdstQueueFamilyIndex, (setter)PyVkImageMemoryBarrier_setdstQueueFamilyIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageMemoryBarrierType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageMemoryBarrier", sizeof(PyVkImageMemoryBarrier), 0,
                    (destructor)PyVkImageMemoryBarrier_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageMemoryBarrier object",0,0,0,0,0,0,0,0,
                    PyVkImageMemoryBarrier_getsetters,0,0,0,0,0,0,0,PyVkImageMemoryBarrier_new,};
            
                typedef struct { PyObject_HEAD VkImageCreateInfo *base; }
                PyVkImageCreateInfo;
                
                static void PyVkImageCreateInfo_del(PyVkImageCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageCreateInfo *self;
                    self = (PyVkImageCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageCreateInfo_setpNext(PyVkImageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkImageCreateInfo_getpNext(PyVkImageCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageCreateInfo_setmipLevels(PyVkImageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mipLevels");
                        return -1;
                    }
                (self->base)->mipLevels = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageCreateInfo_getmipLevels(PyVkImageCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->mipLevels);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageCreateInfo_setarrayLayers(PyVkImageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with arrayLayers");
                        return -1;
                    }
                (self->base)->arrayLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageCreateInfo_getarrayLayers(PyVkImageCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->arrayLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageCreateInfo_setqueueFamilyIndexCount(PyVkImageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueFamilyIndexCount");
                        return -1;
                    }
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkImageCreateInfo_getqueueFamilyIndexCount(PyVkImageCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkImageCreateInfo_setpQueueFamilyIndices(PyVkImageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pQueueFamilyIndices");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pQueueFamilyIndices = t;
            
                    return 0;
                }
                
                static PyObject * PyVkImageCreateInfo_getpQueueFamilyIndices(PyVkImageCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkImageCreateInfo_getpNext, (setter)PyVkImageCreateInfo_setpNext, "", NULL},
                    
                        { "mipLevels", (getter)PyVkImageCreateInfo_getmipLevels, (setter)PyVkImageCreateInfo_setmipLevels, "", NULL},
                    
                        { "arrayLayers", (getter)PyVkImageCreateInfo_getarrayLayers, (setter)PyVkImageCreateInfo_setarrayLayers, "", NULL},
                    
                        { "queueFamilyIndexCount", (getter)PyVkImageCreateInfo_getqueueFamilyIndexCount, (setter)PyVkImageCreateInfo_setqueueFamilyIndexCount, "", NULL},
                    
                        { "pQueueFamilyIndices", (getter)PyVkImageCreateInfo_getpQueueFamilyIndices, (setter)PyVkImageCreateInfo_setpQueueFamilyIndices, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageCreateInfo", sizeof(PyVkImageCreateInfo), 0,
                    (destructor)PyVkImageCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkImageCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkImageCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkSubresourceLayout *base; }
                PyVkSubresourceLayout;
                
                static void PyVkSubresourceLayout_del(PyVkSubresourceLayout* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSubresourceLayout_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSubresourceLayout *self;
                    self = (PyVkSubresourceLayout *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSubresourceLayout));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSubresourceLayout");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkSubresourceLayout_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkSubresourceLayoutType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSubresourceLayout", sizeof(PyVkSubresourceLayout), 0,
                    (destructor)PyVkSubresourceLayout_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSubresourceLayout object",0,0,0,0,0,0,0,0,
                    PyVkSubresourceLayout_getsetters,0,0,0,0,0,0,0,PyVkSubresourceLayout_new,};
            
                typedef struct { PyObject_HEAD VkImageViewCreateInfo *base; }
                PyVkImageViewCreateInfo;
                
                static void PyVkImageViewCreateInfo_del(PyVkImageViewCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageViewCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageViewCreateInfo *self;
                    self = (PyVkImageViewCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageViewCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageViewCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImageViewCreateInfo_setpNext(PyVkImageViewCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkImageViewCreateInfo_getpNext(PyVkImageViewCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImageViewCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkImageViewCreateInfo_getpNext, (setter)PyVkImageViewCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImageViewCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageViewCreateInfo", sizeof(PyVkImageViewCreateInfo), 0,
                    (destructor)PyVkImageViewCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageViewCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkImageViewCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkImageViewCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkBufferCopy *base; }
                PyVkBufferCopy;
                
                static void PyVkBufferCopy_del(PyVkBufferCopy* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBufferCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBufferCopy *self;
                    self = (PyVkBufferCopy *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBufferCopy));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBufferCopy");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkBufferCopy_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkBufferCopyType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBufferCopy", sizeof(PyVkBufferCopy), 0,
                    (destructor)PyVkBufferCopy_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBufferCopy object",0,0,0,0,0,0,0,0,
                    PyVkBufferCopy_getsetters,0,0,0,0,0,0,0,PyVkBufferCopy_new,};
            
                typedef struct { PyObject_HEAD VkSparseMemoryBind *base; }
                PyVkSparseMemoryBind;
                
                static void PyVkSparseMemoryBind_del(PyVkSparseMemoryBind* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseMemoryBind *self;
                    self = (PyVkSparseMemoryBind *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseMemoryBind));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseMemoryBind");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkSparseMemoryBind_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkSparseMemoryBindType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseMemoryBind", sizeof(PyVkSparseMemoryBind), 0,
                    (destructor)PyVkSparseMemoryBind_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseMemoryBind object",0,0,0,0,0,0,0,0,
                    PyVkSparseMemoryBind_getsetters,0,0,0,0,0,0,0,PyVkSparseMemoryBind_new,};
            
                typedef struct { PyObject_HEAD VkSparseImageMemoryBind *base; }
                PyVkSparseImageMemoryBind;
                
                static void PyVkSparseImageMemoryBind_del(PyVkSparseImageMemoryBind* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseImageMemoryBind_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseImageMemoryBind *self;
                    self = (PyVkSparseImageMemoryBind *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseImageMemoryBind));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseImageMemoryBind");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkSparseImageMemoryBind_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkSparseImageMemoryBindType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseImageMemoryBind", sizeof(PyVkSparseImageMemoryBind), 0,
                    (destructor)PyVkSparseImageMemoryBind_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseImageMemoryBind object",0,0,0,0,0,0,0,0,
                    PyVkSparseImageMemoryBind_getsetters,0,0,0,0,0,0,0,PyVkSparseImageMemoryBind_new,};
            
                typedef struct { PyObject_HEAD VkSparseBufferMemoryBindInfo *base; }
                PyVkSparseBufferMemoryBindInfo;
                
                static void PyVkSparseBufferMemoryBindInfo_del(PyVkSparseBufferMemoryBindInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseBufferMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseBufferMemoryBindInfo *self;
                    self = (PyVkSparseBufferMemoryBindInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseBufferMemoryBindInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseBufferMemoryBindInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSparseBufferMemoryBindInfo_setbindCount(PyVkSparseBufferMemoryBindInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bindCount");
                        return -1;
                    }
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSparseBufferMemoryBindInfo_getbindCount(PyVkSparseBufferMemoryBindInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSparseBufferMemoryBindInfo_getsetters[] = {
                    
                        { "bindCount", (getter)PyVkSparseBufferMemoryBindInfo_getbindCount, (setter)PyVkSparseBufferMemoryBindInfo_setbindCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSparseBufferMemoryBindInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseBufferMemoryBindInfo", sizeof(PyVkSparseBufferMemoryBindInfo), 0,
                    (destructor)PyVkSparseBufferMemoryBindInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseBufferMemoryBindInfo object",0,0,0,0,0,0,0,0,
                    PyVkSparseBufferMemoryBindInfo_getsetters,0,0,0,0,0,0,0,PyVkSparseBufferMemoryBindInfo_new,};
            
                typedef struct { PyObject_HEAD VkSparseImageOpaqueMemoryBindInfo *base; }
                PyVkSparseImageOpaqueMemoryBindInfo;
                
                static void PyVkSparseImageOpaqueMemoryBindInfo_del(PyVkSparseImageOpaqueMemoryBindInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseImageOpaqueMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseImageOpaqueMemoryBindInfo *self;
                    self = (PyVkSparseImageOpaqueMemoryBindInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseImageOpaqueMemoryBindInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseImageOpaqueMemoryBindInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSparseImageOpaqueMemoryBindInfo_setbindCount(PyVkSparseImageOpaqueMemoryBindInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bindCount");
                        return -1;
                    }
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSparseImageOpaqueMemoryBindInfo_getbindCount(PyVkSparseImageOpaqueMemoryBindInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSparseImageOpaqueMemoryBindInfo_getsetters[] = {
                    
                        { "bindCount", (getter)PyVkSparseImageOpaqueMemoryBindInfo_getbindCount, (setter)PyVkSparseImageOpaqueMemoryBindInfo_setbindCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSparseImageOpaqueMemoryBindInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseImageOpaqueMemoryBindInfo", sizeof(PyVkSparseImageOpaqueMemoryBindInfo), 0,
                    (destructor)PyVkSparseImageOpaqueMemoryBindInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseImageOpaqueMemoryBindInfo object",0,0,0,0,0,0,0,0,
                    PyVkSparseImageOpaqueMemoryBindInfo_getsetters,0,0,0,0,0,0,0,PyVkSparseImageOpaqueMemoryBindInfo_new,};
            
                typedef struct { PyObject_HEAD VkSparseImageMemoryBindInfo *base; }
                PyVkSparseImageMemoryBindInfo;
                
                static void PyVkSparseImageMemoryBindInfo_del(PyVkSparseImageMemoryBindInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSparseImageMemoryBindInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSparseImageMemoryBindInfo *self;
                    self = (PyVkSparseImageMemoryBindInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSparseImageMemoryBindInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSparseImageMemoryBindInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSparseImageMemoryBindInfo_setbindCount(PyVkSparseImageMemoryBindInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bindCount");
                        return -1;
                    }
                (self->base)->bindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSparseImageMemoryBindInfo_getbindCount(PyVkSparseImageMemoryBindInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSparseImageMemoryBindInfo_getsetters[] = {
                    
                        { "bindCount", (getter)PyVkSparseImageMemoryBindInfo_getbindCount, (setter)PyVkSparseImageMemoryBindInfo_setbindCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSparseImageMemoryBindInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSparseImageMemoryBindInfo", sizeof(PyVkSparseImageMemoryBindInfo), 0,
                    (destructor)PyVkSparseImageMemoryBindInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSparseImageMemoryBindInfo object",0,0,0,0,0,0,0,0,
                    PyVkSparseImageMemoryBindInfo_getsetters,0,0,0,0,0,0,0,PyVkSparseImageMemoryBindInfo_new,};
            
                typedef struct { PyObject_HEAD VkBindSparseInfo *base; }
                PyVkBindSparseInfo;
                
                static void PyVkBindSparseInfo_del(PyVkBindSparseInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBindSparseInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBindSparseInfo *self;
                    self = (PyVkBindSparseInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBindSparseInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBindSparseInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkBindSparseInfo_setpNext(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getpNext(PyVkBindSparseInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBindSparseInfo_setwaitSemaphoreCount(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with waitSemaphoreCount");
                        return -1;
                    }
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getwaitSemaphoreCount(PyVkBindSparseInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBindSparseInfo_setbufferBindCount(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bufferBindCount");
                        return -1;
                    }
                (self->base)->bufferBindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getbufferBindCount(PyVkBindSparseInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bufferBindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBindSparseInfo_setimageOpaqueBindCount(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with imageOpaqueBindCount");
                        return -1;
                    }
                (self->base)->imageOpaqueBindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getimageOpaqueBindCount(PyVkBindSparseInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->imageOpaqueBindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBindSparseInfo_setimageBindCount(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with imageBindCount");
                        return -1;
                    }
                (self->base)->imageBindCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getimageBindCount(PyVkBindSparseInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->imageBindCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBindSparseInfo_setsignalSemaphoreCount(PyVkBindSparseInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with signalSemaphoreCount");
                        return -1;
                    }
                (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBindSparseInfo_getsignalSemaphoreCount(PyVkBindSparseInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkBindSparseInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkBindSparseInfo_getpNext, (setter)PyVkBindSparseInfo_setpNext, "", NULL},
                    
                        { "waitSemaphoreCount", (getter)PyVkBindSparseInfo_getwaitSemaphoreCount, (setter)PyVkBindSparseInfo_setwaitSemaphoreCount, "", NULL},
                    
                        { "bufferBindCount", (getter)PyVkBindSparseInfo_getbufferBindCount, (setter)PyVkBindSparseInfo_setbufferBindCount, "", NULL},
                    
                        { "imageOpaqueBindCount", (getter)PyVkBindSparseInfo_getimageOpaqueBindCount, (setter)PyVkBindSparseInfo_setimageOpaqueBindCount, "", NULL},
                    
                        { "imageBindCount", (getter)PyVkBindSparseInfo_getimageBindCount, (setter)PyVkBindSparseInfo_setimageBindCount, "", NULL},
                    
                        { "signalSemaphoreCount", (getter)PyVkBindSparseInfo_getsignalSemaphoreCount, (setter)PyVkBindSparseInfo_setsignalSemaphoreCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkBindSparseInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBindSparseInfo", sizeof(PyVkBindSparseInfo), 0,
                    (destructor)PyVkBindSparseInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBindSparseInfo object",0,0,0,0,0,0,0,0,
                    PyVkBindSparseInfo_getsetters,0,0,0,0,0,0,0,PyVkBindSparseInfo_new,};
            
                typedef struct { PyObject_HEAD VkImageCopy *base; }
                PyVkImageCopy;
                
                static void PyVkImageCopy_del(PyVkImageCopy* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageCopy *self;
                    self = (PyVkImageCopy *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageCopy));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageCopy");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkImageCopy_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkImageCopyType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageCopy", sizeof(PyVkImageCopy), 0,
                    (destructor)PyVkImageCopy_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageCopy object",0,0,0,0,0,0,0,0,
                    PyVkImageCopy_getsetters,0,0,0,0,0,0,0,PyVkImageCopy_new,};
            
                typedef struct { PyObject_HEAD VkImageBlit *base; }
                PyVkImageBlit;
                
                static void PyVkImageBlit_del(PyVkImageBlit* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageBlit_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageBlit *self;
                    self = (PyVkImageBlit *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageBlit));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageBlit");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkImageBlit_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkImageBlitType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageBlit", sizeof(PyVkImageBlit), 0,
                    (destructor)PyVkImageBlit_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageBlit object",0,0,0,0,0,0,0,0,
                    PyVkImageBlit_getsetters,0,0,0,0,0,0,0,PyVkImageBlit_new,};
            
                typedef struct { PyObject_HEAD VkBufferImageCopy *base; }
                PyVkBufferImageCopy;
                
                static void PyVkBufferImageCopy_del(PyVkBufferImageCopy* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkBufferImageCopy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkBufferImageCopy *self;
                    self = (PyVkBufferImageCopy *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkBufferImageCopy));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkBufferImageCopy");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkBufferImageCopy_setbufferRowLength(PyVkBufferImageCopy *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bufferRowLength");
                        return -1;
                    }
                (self->base)->bufferRowLength = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBufferImageCopy_getbufferRowLength(PyVkBufferImageCopy *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bufferRowLength);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkBufferImageCopy_setbufferImageHeight(PyVkBufferImageCopy *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bufferImageHeight");
                        return -1;
                    }
                (self->base)->bufferImageHeight = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkBufferImageCopy_getbufferImageHeight(PyVkBufferImageCopy *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bufferImageHeight);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkBufferImageCopy_getsetters[] = {
                    
                        { "bufferRowLength", (getter)PyVkBufferImageCopy_getbufferRowLength, (setter)PyVkBufferImageCopy_setbufferRowLength, "", NULL},
                    
                        { "bufferImageHeight", (getter)PyVkBufferImageCopy_getbufferImageHeight, (setter)PyVkBufferImageCopy_setbufferImageHeight, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkBufferImageCopyType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkBufferImageCopy", sizeof(PyVkBufferImageCopy), 0,
                    (destructor)PyVkBufferImageCopy_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkBufferImageCopy object",0,0,0,0,0,0,0,0,
                    PyVkBufferImageCopy_getsetters,0,0,0,0,0,0,0,PyVkBufferImageCopy_new,};
            
                typedef struct { PyObject_HEAD VkImageResolve *base; }
                PyVkImageResolve;
                
                static void PyVkImageResolve_del(PyVkImageResolve* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImageResolve_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImageResolve *self;
                    self = (PyVkImageResolve *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImageResolve));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImageResolve");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkImageResolve_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkImageResolveType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImageResolve", sizeof(PyVkImageResolve), 0,
                    (destructor)PyVkImageResolve_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImageResolve object",0,0,0,0,0,0,0,0,
                    PyVkImageResolve_getsetters,0,0,0,0,0,0,0,PyVkImageResolve_new,};
            
                typedef struct { PyObject_HEAD VkShaderModuleCreateInfo *base; }
                PyVkShaderModuleCreateInfo;
                
                static void PyVkShaderModuleCreateInfo_del(PyVkShaderModuleCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkShaderModuleCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkShaderModuleCreateInfo *self;
                    self = (PyVkShaderModuleCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkShaderModuleCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkShaderModuleCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkShaderModuleCreateInfo_setpNext(PyVkShaderModuleCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkShaderModuleCreateInfo_getpNext(PyVkShaderModuleCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkShaderModuleCreateInfo_setcodeSize(PyVkShaderModuleCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with codeSize");
                        return -1;
                    }
                (self->base)->codeSize = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkShaderModuleCreateInfo_getcodeSize(PyVkShaderModuleCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->codeSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkShaderModuleCreateInfo_setpCode(PyVkShaderModuleCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pCode");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pCode = t;
            
                    return 0;
                }
                
                static PyObject * PyVkShaderModuleCreateInfo_getpCode(PyVkShaderModuleCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pCode)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkShaderModuleCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkShaderModuleCreateInfo_getpNext, (setter)PyVkShaderModuleCreateInfo_setpNext, "", NULL},
                    
                        { "codeSize", (getter)PyVkShaderModuleCreateInfo_getcodeSize, (setter)PyVkShaderModuleCreateInfo_setcodeSize, "", NULL},
                    
                        { "pCode", (getter)PyVkShaderModuleCreateInfo_getpCode, (setter)PyVkShaderModuleCreateInfo_setpCode, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkShaderModuleCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkShaderModuleCreateInfo", sizeof(PyVkShaderModuleCreateInfo), 0,
                    (destructor)PyVkShaderModuleCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkShaderModuleCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkShaderModuleCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkShaderModuleCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorSetLayoutBinding *base; }
                PyVkDescriptorSetLayoutBinding;
                
                static void PyVkDescriptorSetLayoutBinding_del(PyVkDescriptorSetLayoutBinding* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorSetLayoutBinding_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorSetLayoutBinding *self;
                    self = (PyVkDescriptorSetLayoutBinding *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorSetLayoutBinding));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorSetLayoutBinding");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDescriptorSetLayoutBinding_setbinding(PyVkDescriptorSetLayoutBinding *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with binding");
                        return -1;
                    }
                (self->base)->binding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetLayoutBinding_getbinding(PyVkDescriptorSetLayoutBinding *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDescriptorSetLayoutBinding_setdescriptorCount(PyVkDescriptorSetLayoutBinding *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with descriptorCount");
                        return -1;
                    }
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetLayoutBinding_getdescriptorCount(PyVkDescriptorSetLayoutBinding *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDescriptorSetLayoutBinding_getsetters[] = {
                    
                        { "binding", (getter)PyVkDescriptorSetLayoutBinding_getbinding, (setter)PyVkDescriptorSetLayoutBinding_setbinding, "", NULL},
                    
                        { "descriptorCount", (getter)PyVkDescriptorSetLayoutBinding_getdescriptorCount, (setter)PyVkDescriptorSetLayoutBinding_setdescriptorCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDescriptorSetLayoutBindingType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorSetLayoutBinding", sizeof(PyVkDescriptorSetLayoutBinding), 0,
                    (destructor)PyVkDescriptorSetLayoutBinding_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorSetLayoutBinding object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorSetLayoutBinding_getsetters,0,0,0,0,0,0,0,PyVkDescriptorSetLayoutBinding_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorSetLayoutCreateInfo *base; }
                PyVkDescriptorSetLayoutCreateInfo;
                
                static void PyVkDescriptorSetLayoutCreateInfo_del(PyVkDescriptorSetLayoutCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorSetLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorSetLayoutCreateInfo *self;
                    self = (PyVkDescriptorSetLayoutCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorSetLayoutCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorSetLayoutCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDescriptorSetLayoutCreateInfo_setpNext(PyVkDescriptorSetLayoutCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetLayoutCreateInfo_getpNext(PyVkDescriptorSetLayoutCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDescriptorSetLayoutCreateInfo_setbindingCount(PyVkDescriptorSetLayoutCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with bindingCount");
                        return -1;
                    }
                (self->base)->bindingCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetLayoutCreateInfo_getbindingCount(PyVkDescriptorSetLayoutCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->bindingCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDescriptorSetLayoutCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDescriptorSetLayoutCreateInfo_getpNext, (setter)PyVkDescriptorSetLayoutCreateInfo_setpNext, "", NULL},
                    
                        { "bindingCount", (getter)PyVkDescriptorSetLayoutCreateInfo_getbindingCount, (setter)PyVkDescriptorSetLayoutCreateInfo_setbindingCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDescriptorSetLayoutCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorSetLayoutCreateInfo", sizeof(PyVkDescriptorSetLayoutCreateInfo), 0,
                    (destructor)PyVkDescriptorSetLayoutCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorSetLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorSetLayoutCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkDescriptorSetLayoutCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorPoolSize *base; }
                PyVkDescriptorPoolSize;
                
                static void PyVkDescriptorPoolSize_del(PyVkDescriptorPoolSize* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorPoolSize_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorPoolSize *self;
                    self = (PyVkDescriptorPoolSize *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorPoolSize));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorPoolSize");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDescriptorPoolSize_setdescriptorCount(PyVkDescriptorPoolSize *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with descriptorCount");
                        return -1;
                    }
                (self->base)->descriptorCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorPoolSize_getdescriptorCount(PyVkDescriptorPoolSize *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->descriptorCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDescriptorPoolSize_getsetters[] = {
                    
                        { "descriptorCount", (getter)PyVkDescriptorPoolSize_getdescriptorCount, (setter)PyVkDescriptorPoolSize_setdescriptorCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDescriptorPoolSizeType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorPoolSize", sizeof(PyVkDescriptorPoolSize), 0,
                    (destructor)PyVkDescriptorPoolSize_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorPoolSize object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorPoolSize_getsetters,0,0,0,0,0,0,0,PyVkDescriptorPoolSize_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorPoolCreateInfo *base; }
                PyVkDescriptorPoolCreateInfo;
                
                static void PyVkDescriptorPoolCreateInfo_del(PyVkDescriptorPoolCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorPoolCreateInfo *self;
                    self = (PyVkDescriptorPoolCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorPoolCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorPoolCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDescriptorPoolCreateInfo_setpNext(PyVkDescriptorPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDescriptorPoolCreateInfo_getpNext(PyVkDescriptorPoolCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDescriptorPoolCreateInfo_setmaxSets(PyVkDescriptorPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxSets");
                        return -1;
                    }
                (self->base)->maxSets = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorPoolCreateInfo_getmaxSets(PyVkDescriptorPoolCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxSets);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDescriptorPoolCreateInfo_setpoolSizeCount(PyVkDescriptorPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with poolSizeCount");
                        return -1;
                    }
                (self->base)->poolSizeCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorPoolCreateInfo_getpoolSizeCount(PyVkDescriptorPoolCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->poolSizeCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDescriptorPoolCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDescriptorPoolCreateInfo_getpNext, (setter)PyVkDescriptorPoolCreateInfo_setpNext, "", NULL},
                    
                        { "maxSets", (getter)PyVkDescriptorPoolCreateInfo_getmaxSets, (setter)PyVkDescriptorPoolCreateInfo_setmaxSets, "", NULL},
                    
                        { "poolSizeCount", (getter)PyVkDescriptorPoolCreateInfo_getpoolSizeCount, (setter)PyVkDescriptorPoolCreateInfo_setpoolSizeCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDescriptorPoolCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorPoolCreateInfo", sizeof(PyVkDescriptorPoolCreateInfo), 0,
                    (destructor)PyVkDescriptorPoolCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorPoolCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorPoolCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkDescriptorPoolCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkDescriptorSetAllocateInfo *base; }
                PyVkDescriptorSetAllocateInfo;
                
                static void PyVkDescriptorSetAllocateInfo_del(PyVkDescriptorSetAllocateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDescriptorSetAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDescriptorSetAllocateInfo *self;
                    self = (PyVkDescriptorSetAllocateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDescriptorSetAllocateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDescriptorSetAllocateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDescriptorSetAllocateInfo_setpNext(PyVkDescriptorSetAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetAllocateInfo_getpNext(PyVkDescriptorSetAllocateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDescriptorSetAllocateInfo_setdescriptorSetCount(PyVkDescriptorSetAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with descriptorSetCount");
                        return -1;
                    }
                (self->base)->descriptorSetCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDescriptorSetAllocateInfo_getdescriptorSetCount(PyVkDescriptorSetAllocateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->descriptorSetCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDescriptorSetAllocateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDescriptorSetAllocateInfo_getpNext, (setter)PyVkDescriptorSetAllocateInfo_setpNext, "", NULL},
                    
                        { "descriptorSetCount", (getter)PyVkDescriptorSetAllocateInfo_getdescriptorSetCount, (setter)PyVkDescriptorSetAllocateInfo_setdescriptorSetCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDescriptorSetAllocateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDescriptorSetAllocateInfo", sizeof(PyVkDescriptorSetAllocateInfo), 0,
                    (destructor)PyVkDescriptorSetAllocateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDescriptorSetAllocateInfo object",0,0,0,0,0,0,0,0,
                    PyVkDescriptorSetAllocateInfo_getsetters,0,0,0,0,0,0,0,PyVkDescriptorSetAllocateInfo_new,};
            
                typedef struct { PyObject_HEAD VkSpecializationMapEntry *base; }
                PyVkSpecializationMapEntry;
                
                static void PyVkSpecializationMapEntry_del(PyVkSpecializationMapEntry* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSpecializationMapEntry_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSpecializationMapEntry *self;
                    self = (PyVkSpecializationMapEntry *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSpecializationMapEntry));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSpecializationMapEntry");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSpecializationMapEntry_setconstantID(PyVkSpecializationMapEntry *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with constantID");
                        return -1;
                    }
                (self->base)->constantID = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSpecializationMapEntry_getconstantID(PyVkSpecializationMapEntry *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->constantID);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSpecializationMapEntry_setoffset(PyVkSpecializationMapEntry *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with offset");
                        return -1;
                    }
                (self->base)->offset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSpecializationMapEntry_getoffset(PyVkSpecializationMapEntry *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSpecializationMapEntry_setsize(PyVkSpecializationMapEntry *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with size");
                        return -1;
                    }
                (self->base)->size = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSpecializationMapEntry_getsize(PyVkSpecializationMapEntry *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->size);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSpecializationMapEntry_getsetters[] = {
                    
                        { "constantID", (getter)PyVkSpecializationMapEntry_getconstantID, (setter)PyVkSpecializationMapEntry_setconstantID, "", NULL},
                    
                        { "offset", (getter)PyVkSpecializationMapEntry_getoffset, (setter)PyVkSpecializationMapEntry_setoffset, "", NULL},
                    
                        { "size", (getter)PyVkSpecializationMapEntry_getsize, (setter)PyVkSpecializationMapEntry_setsize, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSpecializationMapEntryType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSpecializationMapEntry", sizeof(PyVkSpecializationMapEntry), 0,
                    (destructor)PyVkSpecializationMapEntry_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSpecializationMapEntry object",0,0,0,0,0,0,0,0,
                    PyVkSpecializationMapEntry_getsetters,0,0,0,0,0,0,0,PyVkSpecializationMapEntry_new,};
            
                typedef struct { PyObject_HEAD VkSpecializationInfo *base; }
                PyVkSpecializationInfo;
                
                static void PyVkSpecializationInfo_del(PyVkSpecializationInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSpecializationInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSpecializationInfo *self;
                    self = (PyVkSpecializationInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSpecializationInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSpecializationInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSpecializationInfo_setmapEntryCount(PyVkSpecializationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mapEntryCount");
                        return -1;
                    }
                (self->base)->mapEntryCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSpecializationInfo_getmapEntryCount(PyVkSpecializationInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->mapEntryCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSpecializationInfo_setdataSize(PyVkSpecializationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dataSize");
                        return -1;
                    }
                (self->base)->dataSize = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSpecializationInfo_getdataSize(PyVkSpecializationInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dataSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSpecializationInfo_setpData(PyVkSpecializationInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pData");
                        return -1;
                    }
                (self->base)->pData = NULL;
                    return 0;
                }
                
                static PyObject * PyVkSpecializationInfo_getpData(PyVkSpecializationInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSpecializationInfo_getsetters[] = {
                    
                        { "mapEntryCount", (getter)PyVkSpecializationInfo_getmapEntryCount, (setter)PyVkSpecializationInfo_setmapEntryCount, "", NULL},
                    
                        { "dataSize", (getter)PyVkSpecializationInfo_getdataSize, (setter)PyVkSpecializationInfo_setdataSize, "", NULL},
                    
                        { "pData", (getter)PyVkSpecializationInfo_getpData, (setter)PyVkSpecializationInfo_setpData, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSpecializationInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSpecializationInfo", sizeof(PyVkSpecializationInfo), 0,
                    (destructor)PyVkSpecializationInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSpecializationInfo object",0,0,0,0,0,0,0,0,
                    PyVkSpecializationInfo_getsetters,0,0,0,0,0,0,0,PyVkSpecializationInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineShaderStageCreateInfo *base; }
                PyVkPipelineShaderStageCreateInfo;
                
                static void PyVkPipelineShaderStageCreateInfo_del(PyVkPipelineShaderStageCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineShaderStageCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineShaderStageCreateInfo *self;
                    self = (PyVkPipelineShaderStageCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineShaderStageCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineShaderStageCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineShaderStageCreateInfo_setpNext(PyVkPipelineShaderStageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineShaderStageCreateInfo_getpNext(PyVkPipelineShaderStageCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineShaderStageCreateInfo_setpName(PyVkPipelineShaderStageCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->pName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkPipelineShaderStageCreateInfo_getpName(PyVkPipelineShaderStageCreateInfo *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->pName);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineShaderStageCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineShaderStageCreateInfo_getpNext, (setter)PyVkPipelineShaderStageCreateInfo_setpNext, "", NULL},
                    
                        { "pName", (getter)PyVkPipelineShaderStageCreateInfo_getpName, (setter)PyVkPipelineShaderStageCreateInfo_setpName, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineShaderStageCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineShaderStageCreateInfo", sizeof(PyVkPipelineShaderStageCreateInfo), 0,
                    (destructor)PyVkPipelineShaderStageCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineShaderStageCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineShaderStageCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineShaderStageCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkComputePipelineCreateInfo *base; }
                PyVkComputePipelineCreateInfo;
                
                static void PyVkComputePipelineCreateInfo_del(PyVkComputePipelineCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkComputePipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkComputePipelineCreateInfo *self;
                    self = (PyVkComputePipelineCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkComputePipelineCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkComputePipelineCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkComputePipelineCreateInfo_setpNext(PyVkComputePipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkComputePipelineCreateInfo_getpNext(PyVkComputePipelineCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkComputePipelineCreateInfo_setbasePipelineIndex(PyVkComputePipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with basePipelineIndex");
                        return -1;
                    }
                (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkComputePipelineCreateInfo_getbasePipelineIndex(PyVkComputePipelineCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkComputePipelineCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkComputePipelineCreateInfo_getpNext, (setter)PyVkComputePipelineCreateInfo_setpNext, "", NULL},
                    
                        { "basePipelineIndex", (getter)PyVkComputePipelineCreateInfo_getbasePipelineIndex, (setter)PyVkComputePipelineCreateInfo_setbasePipelineIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkComputePipelineCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkComputePipelineCreateInfo", sizeof(PyVkComputePipelineCreateInfo), 0,
                    (destructor)PyVkComputePipelineCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkComputePipelineCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkComputePipelineCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkComputePipelineCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkVertexInputBindingDescription *base; }
                PyVkVertexInputBindingDescription;
                
                static void PyVkVertexInputBindingDescription_del(PyVkVertexInputBindingDescription* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkVertexInputBindingDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkVertexInputBindingDescription *self;
                    self = (PyVkVertexInputBindingDescription *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkVertexInputBindingDescription));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkVertexInputBindingDescription");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkVertexInputBindingDescription_setbinding(PyVkVertexInputBindingDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with binding");
                        return -1;
                    }
                (self->base)->binding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkVertexInputBindingDescription_getbinding(PyVkVertexInputBindingDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkVertexInputBindingDescription_setstride(PyVkVertexInputBindingDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with stride");
                        return -1;
                    }
                (self->base)->stride = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkVertexInputBindingDescription_getstride(PyVkVertexInputBindingDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->stride);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkVertexInputBindingDescription_getsetters[] = {
                    
                        { "binding", (getter)PyVkVertexInputBindingDescription_getbinding, (setter)PyVkVertexInputBindingDescription_setbinding, "", NULL},
                    
                        { "stride", (getter)PyVkVertexInputBindingDescription_getstride, (setter)PyVkVertexInputBindingDescription_setstride, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkVertexInputBindingDescriptionType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkVertexInputBindingDescription", sizeof(PyVkVertexInputBindingDescription), 0,
                    (destructor)PyVkVertexInputBindingDescription_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkVertexInputBindingDescription object",0,0,0,0,0,0,0,0,
                    PyVkVertexInputBindingDescription_getsetters,0,0,0,0,0,0,0,PyVkVertexInputBindingDescription_new,};
            
                typedef struct { PyObject_HEAD VkVertexInputAttributeDescription *base; }
                PyVkVertexInputAttributeDescription;
                
                static void PyVkVertexInputAttributeDescription_del(PyVkVertexInputAttributeDescription* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkVertexInputAttributeDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkVertexInputAttributeDescription *self;
                    self = (PyVkVertexInputAttributeDescription *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkVertexInputAttributeDescription));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkVertexInputAttributeDescription");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkVertexInputAttributeDescription_setlocation(PyVkVertexInputAttributeDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with location");
                        return -1;
                    }
                (self->base)->location = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkVertexInputAttributeDescription_getlocation(PyVkVertexInputAttributeDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->location);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkVertexInputAttributeDescription_setbinding(PyVkVertexInputAttributeDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with binding");
                        return -1;
                    }
                (self->base)->binding = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkVertexInputAttributeDescription_getbinding(PyVkVertexInputAttributeDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->binding);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkVertexInputAttributeDescription_setoffset(PyVkVertexInputAttributeDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with offset");
                        return -1;
                    }
                (self->base)->offset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkVertexInputAttributeDescription_getoffset(PyVkVertexInputAttributeDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkVertexInputAttributeDescription_getsetters[] = {
                    
                        { "location", (getter)PyVkVertexInputAttributeDescription_getlocation, (setter)PyVkVertexInputAttributeDescription_setlocation, "", NULL},
                    
                        { "binding", (getter)PyVkVertexInputAttributeDescription_getbinding, (setter)PyVkVertexInputAttributeDescription_setbinding, "", NULL},
                    
                        { "offset", (getter)PyVkVertexInputAttributeDescription_getoffset, (setter)PyVkVertexInputAttributeDescription_setoffset, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkVertexInputAttributeDescriptionType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkVertexInputAttributeDescription", sizeof(PyVkVertexInputAttributeDescription), 0,
                    (destructor)PyVkVertexInputAttributeDescription_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkVertexInputAttributeDescription object",0,0,0,0,0,0,0,0,
                    PyVkVertexInputAttributeDescription_getsetters,0,0,0,0,0,0,0,PyVkVertexInputAttributeDescription_new,};
            
                typedef struct { PyObject_HEAD VkPipelineVertexInputStateCreateInfo *base; }
                PyVkPipelineVertexInputStateCreateInfo;
                
                static void PyVkPipelineVertexInputStateCreateInfo_del(PyVkPipelineVertexInputStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineVertexInputStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineVertexInputStateCreateInfo *self;
                    self = (PyVkPipelineVertexInputStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineVertexInputStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineVertexInputStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineVertexInputStateCreateInfo_setpNext(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineVertexInputStateCreateInfo_getpNext(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineVertexInputStateCreateInfo_setvertexBindingDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with vertexBindingDescriptionCount");
                        return -1;
                    }
                (self->base)->vertexBindingDescriptionCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->vertexBindingDescriptionCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineVertexInputStateCreateInfo_setvertexAttributeDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with vertexAttributeDescriptionCount");
                        return -1;
                    }
                (self->base)->vertexAttributeDescriptionCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount(PyVkPipelineVertexInputStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->vertexAttributeDescriptionCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineVertexInputStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineVertexInputStateCreateInfo_getpNext, (setter)PyVkPipelineVertexInputStateCreateInfo_setpNext, "", NULL},
                    
                        { "vertexBindingDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexBindingDescriptionCount, (setter)PyVkPipelineVertexInputStateCreateInfo_setvertexBindingDescriptionCount, "", NULL},
                    
                        { "vertexAttributeDescriptionCount", (getter)PyVkPipelineVertexInputStateCreateInfo_getvertexAttributeDescriptionCount, (setter)PyVkPipelineVertexInputStateCreateInfo_setvertexAttributeDescriptionCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineVertexInputStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineVertexInputStateCreateInfo", sizeof(PyVkPipelineVertexInputStateCreateInfo), 0,
                    (destructor)PyVkPipelineVertexInputStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineVertexInputStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineVertexInputStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineVertexInputStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineInputAssemblyStateCreateInfo *base; }
                PyVkPipelineInputAssemblyStateCreateInfo;
                
                static void PyVkPipelineInputAssemblyStateCreateInfo_del(PyVkPipelineInputAssemblyStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineInputAssemblyStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineInputAssemblyStateCreateInfo *self;
                    self = (PyVkPipelineInputAssemblyStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineInputAssemblyStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineInputAssemblyStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineInputAssemblyStateCreateInfo_setpNext(PyVkPipelineInputAssemblyStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineInputAssemblyStateCreateInfo_getpNext(PyVkPipelineInputAssemblyStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineInputAssemblyStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineInputAssemblyStateCreateInfo_getpNext, (setter)PyVkPipelineInputAssemblyStateCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineInputAssemblyStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineInputAssemblyStateCreateInfo", sizeof(PyVkPipelineInputAssemblyStateCreateInfo), 0,
                    (destructor)PyVkPipelineInputAssemblyStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineInputAssemblyStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineInputAssemblyStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineInputAssemblyStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineTessellationStateCreateInfo *base; }
                PyVkPipelineTessellationStateCreateInfo;
                
                static void PyVkPipelineTessellationStateCreateInfo_del(PyVkPipelineTessellationStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineTessellationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineTessellationStateCreateInfo *self;
                    self = (PyVkPipelineTessellationStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineTessellationStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineTessellationStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineTessellationStateCreateInfo_setpNext(PyVkPipelineTessellationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineTessellationStateCreateInfo_getpNext(PyVkPipelineTessellationStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineTessellationStateCreateInfo_setpatchControlPoints(PyVkPipelineTessellationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with patchControlPoints");
                        return -1;
                    }
                (self->base)->patchControlPoints = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints(PyVkPipelineTessellationStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->patchControlPoints);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineTessellationStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineTessellationStateCreateInfo_getpNext, (setter)PyVkPipelineTessellationStateCreateInfo_setpNext, "", NULL},
                    
                        { "patchControlPoints", (getter)PyVkPipelineTessellationStateCreateInfo_getpatchControlPoints, (setter)PyVkPipelineTessellationStateCreateInfo_setpatchControlPoints, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineTessellationStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineTessellationStateCreateInfo", sizeof(PyVkPipelineTessellationStateCreateInfo), 0,
                    (destructor)PyVkPipelineTessellationStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineTessellationStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineTessellationStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineTessellationStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineViewportStateCreateInfo *base; }
                PyVkPipelineViewportStateCreateInfo;
                
                static void PyVkPipelineViewportStateCreateInfo_del(PyVkPipelineViewportStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineViewportStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineViewportStateCreateInfo *self;
                    self = (PyVkPipelineViewportStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineViewportStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineViewportStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineViewportStateCreateInfo_setpNext(PyVkPipelineViewportStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineViewportStateCreateInfo_getpNext(PyVkPipelineViewportStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineViewportStateCreateInfo_setviewportCount(PyVkPipelineViewportStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with viewportCount");
                        return -1;
                    }
                (self->base)->viewportCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineViewportStateCreateInfo_getviewportCount(PyVkPipelineViewportStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->viewportCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineViewportStateCreateInfo_setscissorCount(PyVkPipelineViewportStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with scissorCount");
                        return -1;
                    }
                (self->base)->scissorCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineViewportStateCreateInfo_getscissorCount(PyVkPipelineViewportStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->scissorCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineViewportStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineViewportStateCreateInfo_getpNext, (setter)PyVkPipelineViewportStateCreateInfo_setpNext, "", NULL},
                    
                        { "viewportCount", (getter)PyVkPipelineViewportStateCreateInfo_getviewportCount, (setter)PyVkPipelineViewportStateCreateInfo_setviewportCount, "", NULL},
                    
                        { "scissorCount", (getter)PyVkPipelineViewportStateCreateInfo_getscissorCount, (setter)PyVkPipelineViewportStateCreateInfo_setscissorCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineViewportStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineViewportStateCreateInfo", sizeof(PyVkPipelineViewportStateCreateInfo), 0,
                    (destructor)PyVkPipelineViewportStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineViewportStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineViewportStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineViewportStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineRasterizationStateCreateInfo *base; }
                PyVkPipelineRasterizationStateCreateInfo;
                
                static void PyVkPipelineRasterizationStateCreateInfo_del(PyVkPipelineRasterizationStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineRasterizationStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineRasterizationStateCreateInfo *self;
                    self = (PyVkPipelineRasterizationStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineRasterizationStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineRasterizationStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineRasterizationStateCreateInfo_setpNext(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateCreateInfo_getpNext(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineRasterizationStateCreateInfo_setdepthBiasConstantFactor(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with depthBiasConstantFactor");
                        return -1;
                    }
                (self->base)->depthBiasConstantFactor = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasConstantFactor);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineRasterizationStateCreateInfo_setdepthBiasClamp(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with depthBiasClamp");
                        return -1;
                    }
                (self->base)->depthBiasClamp = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasClamp);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineRasterizationStateCreateInfo_setdepthBiasSlopeFactor(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with depthBiasSlopeFactor");
                        return -1;
                    }
                (self->base)->depthBiasSlopeFactor = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->depthBiasSlopeFactor);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineRasterizationStateCreateInfo_setlineWidth(PyVkPipelineRasterizationStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with lineWidth");
                        return -1;
                    }
                (self->base)->lineWidth = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateCreateInfo_getlineWidth(PyVkPipelineRasterizationStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidth);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineRasterizationStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineRasterizationStateCreateInfo_getpNext, (setter)PyVkPipelineRasterizationStateCreateInfo_setpNext, "", NULL},
                    
                        { "depthBiasConstantFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasConstantFactor, (setter)PyVkPipelineRasterizationStateCreateInfo_setdepthBiasConstantFactor, "", NULL},
                    
                        { "depthBiasClamp", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasClamp, (setter)PyVkPipelineRasterizationStateCreateInfo_setdepthBiasClamp, "", NULL},
                    
                        { "depthBiasSlopeFactor", (getter)PyVkPipelineRasterizationStateCreateInfo_getdepthBiasSlopeFactor, (setter)PyVkPipelineRasterizationStateCreateInfo_setdepthBiasSlopeFactor, "", NULL},
                    
                        { "lineWidth", (getter)PyVkPipelineRasterizationStateCreateInfo_getlineWidth, (setter)PyVkPipelineRasterizationStateCreateInfo_setlineWidth, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineRasterizationStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineRasterizationStateCreateInfo", sizeof(PyVkPipelineRasterizationStateCreateInfo), 0,
                    (destructor)PyVkPipelineRasterizationStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineRasterizationStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineRasterizationStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineRasterizationStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineMultisampleStateCreateInfo *base; }
                PyVkPipelineMultisampleStateCreateInfo;
                
                static void PyVkPipelineMultisampleStateCreateInfo_del(PyVkPipelineMultisampleStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineMultisampleStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineMultisampleStateCreateInfo *self;
                    self = (PyVkPipelineMultisampleStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineMultisampleStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineMultisampleStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineMultisampleStateCreateInfo_setpNext(PyVkPipelineMultisampleStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineMultisampleStateCreateInfo_getpNext(PyVkPipelineMultisampleStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineMultisampleStateCreateInfo_setminSampleShading(PyVkPipelineMultisampleStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minSampleShading");
                        return -1;
                    }
                (self->base)->minSampleShading = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineMultisampleStateCreateInfo_getminSampleShading(PyVkPipelineMultisampleStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->minSampleShading);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineMultisampleStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineMultisampleStateCreateInfo_getpNext, (setter)PyVkPipelineMultisampleStateCreateInfo_setpNext, "", NULL},
                    
                        { "minSampleShading", (getter)PyVkPipelineMultisampleStateCreateInfo_getminSampleShading, (setter)PyVkPipelineMultisampleStateCreateInfo_setminSampleShading, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineMultisampleStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineMultisampleStateCreateInfo", sizeof(PyVkPipelineMultisampleStateCreateInfo), 0,
                    (destructor)PyVkPipelineMultisampleStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineMultisampleStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineMultisampleStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineMultisampleStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineColorBlendAttachmentState *base; }
                PyVkPipelineColorBlendAttachmentState;
                
                static void PyVkPipelineColorBlendAttachmentState_del(PyVkPipelineColorBlendAttachmentState* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineColorBlendAttachmentState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineColorBlendAttachmentState *self;
                    self = (PyVkPipelineColorBlendAttachmentState *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineColorBlendAttachmentState));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineColorBlendAttachmentState");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkPipelineColorBlendAttachmentState_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkPipelineColorBlendAttachmentStateType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineColorBlendAttachmentState", sizeof(PyVkPipelineColorBlendAttachmentState), 0,
                    (destructor)PyVkPipelineColorBlendAttachmentState_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineColorBlendAttachmentState object",0,0,0,0,0,0,0,0,
                    PyVkPipelineColorBlendAttachmentState_getsetters,0,0,0,0,0,0,0,PyVkPipelineColorBlendAttachmentState_new,};
            
                typedef struct { PyObject_HEAD VkPipelineColorBlendStateCreateInfo *base; }
                PyVkPipelineColorBlendStateCreateInfo;
                
                static void PyVkPipelineColorBlendStateCreateInfo_del(PyVkPipelineColorBlendStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineColorBlendStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineColorBlendStateCreateInfo *self;
                    self = (PyVkPipelineColorBlendStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineColorBlendStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineColorBlendStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineColorBlendStateCreateInfo_setpNext(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineColorBlendStateCreateInfo_getpNext(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineColorBlendStateCreateInfo_setattachmentCount(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with attachmentCount");
                        return -1;
                    }
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineColorBlendStateCreateInfo_getattachmentCount(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineColorBlendStateCreateInfo_setblendConstants(PyVkPipelineColorBlendStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with blendConstants");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                float tmp = (float) PyFloat_AsDouble(PyList_GetItem(value, i));
                ((self->base)->blendConstants)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPipelineColorBlendStateCreateInfo_getblendConstants(PyVkPipelineColorBlendStateCreateInfo *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->blendConstants) / sizeof((self->base)->blendConstants[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->blendConstants[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineColorBlendStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineColorBlendStateCreateInfo_getpNext, (setter)PyVkPipelineColorBlendStateCreateInfo_setpNext, "", NULL},
                    
                        { "attachmentCount", (getter)PyVkPipelineColorBlendStateCreateInfo_getattachmentCount, (setter)PyVkPipelineColorBlendStateCreateInfo_setattachmentCount, "", NULL},
                    
                        { "blendConstants", (getter)PyVkPipelineColorBlendStateCreateInfo_getblendConstants, (setter)PyVkPipelineColorBlendStateCreateInfo_setblendConstants, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineColorBlendStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineColorBlendStateCreateInfo", sizeof(PyVkPipelineColorBlendStateCreateInfo), 0,
                    (destructor)PyVkPipelineColorBlendStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineColorBlendStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineColorBlendStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineColorBlendStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineDynamicStateCreateInfo *base; }
                PyVkPipelineDynamicStateCreateInfo;
                
                static void PyVkPipelineDynamicStateCreateInfo_del(PyVkPipelineDynamicStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineDynamicStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineDynamicStateCreateInfo *self;
                    self = (PyVkPipelineDynamicStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineDynamicStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineDynamicStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineDynamicStateCreateInfo_setpNext(PyVkPipelineDynamicStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineDynamicStateCreateInfo_getpNext(PyVkPipelineDynamicStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineDynamicStateCreateInfo_setdynamicStateCount(PyVkPipelineDynamicStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dynamicStateCount");
                        return -1;
                    }
                (self->base)->dynamicStateCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount(PyVkPipelineDynamicStateCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dynamicStateCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineDynamicStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineDynamicStateCreateInfo_getpNext, (setter)PyVkPipelineDynamicStateCreateInfo_setpNext, "", NULL},
                    
                        { "dynamicStateCount", (getter)PyVkPipelineDynamicStateCreateInfo_getdynamicStateCount, (setter)PyVkPipelineDynamicStateCreateInfo_setdynamicStateCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineDynamicStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineDynamicStateCreateInfo", sizeof(PyVkPipelineDynamicStateCreateInfo), 0,
                    (destructor)PyVkPipelineDynamicStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineDynamicStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineDynamicStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineDynamicStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkStencilOpState *base; }
                PyVkStencilOpState;
                
                static void PyVkStencilOpState_del(PyVkStencilOpState* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkStencilOpState_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkStencilOpState *self;
                    self = (PyVkStencilOpState *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkStencilOpState));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkStencilOpState");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkStencilOpState_setcompareMask(PyVkStencilOpState *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with compareMask");
                        return -1;
                    }
                (self->base)->compareMask = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkStencilOpState_getcompareMask(PyVkStencilOpState *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->compareMask);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkStencilOpState_setwriteMask(PyVkStencilOpState *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with writeMask");
                        return -1;
                    }
                (self->base)->writeMask = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkStencilOpState_getwriteMask(PyVkStencilOpState *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->writeMask);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkStencilOpState_setreference(PyVkStencilOpState *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with reference");
                        return -1;
                    }
                (self->base)->reference = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkStencilOpState_getreference(PyVkStencilOpState *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->reference);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkStencilOpState_getsetters[] = {
                    
                        { "compareMask", (getter)PyVkStencilOpState_getcompareMask, (setter)PyVkStencilOpState_setcompareMask, "", NULL},
                    
                        { "writeMask", (getter)PyVkStencilOpState_getwriteMask, (setter)PyVkStencilOpState_setwriteMask, "", NULL},
                    
                        { "reference", (getter)PyVkStencilOpState_getreference, (setter)PyVkStencilOpState_setreference, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkStencilOpStateType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkStencilOpState", sizeof(PyVkStencilOpState), 0,
                    (destructor)PyVkStencilOpState_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkStencilOpState object",0,0,0,0,0,0,0,0,
                    PyVkStencilOpState_getsetters,0,0,0,0,0,0,0,PyVkStencilOpState_new,};
            
                typedef struct { PyObject_HEAD VkPipelineDepthStencilStateCreateInfo *base; }
                PyVkPipelineDepthStencilStateCreateInfo;
                
                static void PyVkPipelineDepthStencilStateCreateInfo_del(PyVkPipelineDepthStencilStateCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineDepthStencilStateCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineDepthStencilStateCreateInfo *self;
                    self = (PyVkPipelineDepthStencilStateCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineDepthStencilStateCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineDepthStencilStateCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineDepthStencilStateCreateInfo_setpNext(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getpNext(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineDepthStencilStateCreateInfo_setminDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minDepthBounds");
                        return -1;
                    }
                (self->base)->minDepthBounds = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->minDepthBounds);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineDepthStencilStateCreateInfo_setmaxDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDepthBounds");
                        return -1;
                    }
                (self->base)->maxDepthBounds = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds(PyVkPipelineDepthStencilStateCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxDepthBounds);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineDepthStencilStateCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineDepthStencilStateCreateInfo_getpNext, (setter)PyVkPipelineDepthStencilStateCreateInfo_setpNext, "", NULL},
                    
                        { "minDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getminDepthBounds, (setter)PyVkPipelineDepthStencilStateCreateInfo_setminDepthBounds, "", NULL},
                    
                        { "maxDepthBounds", (getter)PyVkPipelineDepthStencilStateCreateInfo_getmaxDepthBounds, (setter)PyVkPipelineDepthStencilStateCreateInfo_setmaxDepthBounds, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineDepthStencilStateCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineDepthStencilStateCreateInfo", sizeof(PyVkPipelineDepthStencilStateCreateInfo), 0,
                    (destructor)PyVkPipelineDepthStencilStateCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineDepthStencilStateCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineDepthStencilStateCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineDepthStencilStateCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkGraphicsPipelineCreateInfo *base; }
                PyVkGraphicsPipelineCreateInfo;
                
                static void PyVkGraphicsPipelineCreateInfo_del(PyVkGraphicsPipelineCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkGraphicsPipelineCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkGraphicsPipelineCreateInfo *self;
                    self = (PyVkGraphicsPipelineCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkGraphicsPipelineCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkGraphicsPipelineCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkGraphicsPipelineCreateInfo_setpNext(PyVkGraphicsPipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkGraphicsPipelineCreateInfo_getpNext(PyVkGraphicsPipelineCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkGraphicsPipelineCreateInfo_setstageCount(PyVkGraphicsPipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with stageCount");
                        return -1;
                    }
                (self->base)->stageCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkGraphicsPipelineCreateInfo_getstageCount(PyVkGraphicsPipelineCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->stageCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkGraphicsPipelineCreateInfo_setsubpass(PyVkGraphicsPipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subpass");
                        return -1;
                    }
                (self->base)->subpass = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkGraphicsPipelineCreateInfo_getsubpass(PyVkGraphicsPipelineCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkGraphicsPipelineCreateInfo_setbasePipelineIndex(PyVkGraphicsPipelineCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with basePipelineIndex");
                        return -1;
                    }
                (self->base)->basePipelineIndex = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex(PyVkGraphicsPipelineCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->basePipelineIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkGraphicsPipelineCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkGraphicsPipelineCreateInfo_getpNext, (setter)PyVkGraphicsPipelineCreateInfo_setpNext, "", NULL},
                    
                        { "stageCount", (getter)PyVkGraphicsPipelineCreateInfo_getstageCount, (setter)PyVkGraphicsPipelineCreateInfo_setstageCount, "", NULL},
                    
                        { "subpass", (getter)PyVkGraphicsPipelineCreateInfo_getsubpass, (setter)PyVkGraphicsPipelineCreateInfo_setsubpass, "", NULL},
                    
                        { "basePipelineIndex", (getter)PyVkGraphicsPipelineCreateInfo_getbasePipelineIndex, (setter)PyVkGraphicsPipelineCreateInfo_setbasePipelineIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkGraphicsPipelineCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkGraphicsPipelineCreateInfo", sizeof(PyVkGraphicsPipelineCreateInfo), 0,
                    (destructor)PyVkGraphicsPipelineCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkGraphicsPipelineCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkGraphicsPipelineCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkGraphicsPipelineCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPipelineCacheCreateInfo *base; }
                PyVkPipelineCacheCreateInfo;
                
                static void PyVkPipelineCacheCreateInfo_del(PyVkPipelineCacheCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineCacheCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineCacheCreateInfo *self;
                    self = (PyVkPipelineCacheCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineCacheCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineCacheCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineCacheCreateInfo_setpNext(PyVkPipelineCacheCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineCacheCreateInfo_getpNext(PyVkPipelineCacheCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineCacheCreateInfo_setinitialDataSize(PyVkPipelineCacheCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with initialDataSize");
                        return -1;
                    }
                (self->base)->initialDataSize = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineCacheCreateInfo_getinitialDataSize(PyVkPipelineCacheCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->initialDataSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineCacheCreateInfo_setpInitialData(PyVkPipelineCacheCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pInitialData");
                        return -1;
                    }
                (self->base)->pInitialData = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineCacheCreateInfo_getpInitialData(PyVkPipelineCacheCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineCacheCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineCacheCreateInfo_getpNext, (setter)PyVkPipelineCacheCreateInfo_setpNext, "", NULL},
                    
                        { "initialDataSize", (getter)PyVkPipelineCacheCreateInfo_getinitialDataSize, (setter)PyVkPipelineCacheCreateInfo_setinitialDataSize, "", NULL},
                    
                        { "pInitialData", (getter)PyVkPipelineCacheCreateInfo_getpInitialData, (setter)PyVkPipelineCacheCreateInfo_setpInitialData, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineCacheCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineCacheCreateInfo", sizeof(PyVkPipelineCacheCreateInfo), 0,
                    (destructor)PyVkPipelineCacheCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineCacheCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineCacheCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineCacheCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPushConstantRange *base; }
                PyVkPushConstantRange;
                
                static void PyVkPushConstantRange_del(PyVkPushConstantRange* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPushConstantRange_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPushConstantRange *self;
                    self = (PyVkPushConstantRange *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPushConstantRange));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPushConstantRange");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPushConstantRange_setoffset(PyVkPushConstantRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with offset");
                        return -1;
                    }
                (self->base)->offset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPushConstantRange_getoffset(PyVkPushConstantRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->offset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPushConstantRange_setsize(PyVkPushConstantRange *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with size");
                        return -1;
                    }
                (self->base)->size = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPushConstantRange_getsize(PyVkPushConstantRange *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->size);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPushConstantRange_getsetters[] = {
                    
                        { "offset", (getter)PyVkPushConstantRange_getoffset, (setter)PyVkPushConstantRange_setoffset, "", NULL},
                    
                        { "size", (getter)PyVkPushConstantRange_getsize, (setter)PyVkPushConstantRange_setsize, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPushConstantRangeType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPushConstantRange", sizeof(PyVkPushConstantRange), 0,
                    (destructor)PyVkPushConstantRange_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPushConstantRange object",0,0,0,0,0,0,0,0,
                    PyVkPushConstantRange_getsetters,0,0,0,0,0,0,0,PyVkPushConstantRange_new,};
            
                typedef struct { PyObject_HEAD VkPipelineLayoutCreateInfo *base; }
                PyVkPipelineLayoutCreateInfo;
                
                static void PyVkPipelineLayoutCreateInfo_del(PyVkPipelineLayoutCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineLayoutCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineLayoutCreateInfo *self;
                    self = (PyVkPipelineLayoutCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineLayoutCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineLayoutCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineLayoutCreateInfo_setpNext(PyVkPipelineLayoutCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineLayoutCreateInfo_getpNext(PyVkPipelineLayoutCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineLayoutCreateInfo_setsetLayoutCount(PyVkPipelineLayoutCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with setLayoutCount");
                        return -1;
                    }
                (self->base)->setLayoutCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineLayoutCreateInfo_getsetLayoutCount(PyVkPipelineLayoutCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->setLayoutCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPipelineLayoutCreateInfo_setpushConstantRangeCount(PyVkPipelineLayoutCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pushConstantRangeCount");
                        return -1;
                    }
                (self->base)->pushConstantRangeCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount(PyVkPipelineLayoutCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->pushConstantRangeCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineLayoutCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineLayoutCreateInfo_getpNext, (setter)PyVkPipelineLayoutCreateInfo_setpNext, "", NULL},
                    
                        { "setLayoutCount", (getter)PyVkPipelineLayoutCreateInfo_getsetLayoutCount, (setter)PyVkPipelineLayoutCreateInfo_setsetLayoutCount, "", NULL},
                    
                        { "pushConstantRangeCount", (getter)PyVkPipelineLayoutCreateInfo_getpushConstantRangeCount, (setter)PyVkPipelineLayoutCreateInfo_setpushConstantRangeCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineLayoutCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineLayoutCreateInfo", sizeof(PyVkPipelineLayoutCreateInfo), 0,
                    (destructor)PyVkPipelineLayoutCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineLayoutCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkPipelineLayoutCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkPipelineLayoutCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkSamplerCreateInfo *base; }
                PyVkSamplerCreateInfo;
                
                static void PyVkSamplerCreateInfo_del(PyVkSamplerCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSamplerCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSamplerCreateInfo *self;
                    self = (PyVkSamplerCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSamplerCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSamplerCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSamplerCreateInfo_setpNext(PyVkSamplerCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkSamplerCreateInfo_getpNext(PyVkSamplerCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSamplerCreateInfo_setmipLodBias(PyVkSamplerCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mipLodBias");
                        return -1;
                    }
                (self->base)->mipLodBias = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkSamplerCreateInfo_getmipLodBias(PyVkSamplerCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->mipLodBias);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSamplerCreateInfo_setmaxAnisotropy(PyVkSamplerCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxAnisotropy");
                        return -1;
                    }
                (self->base)->maxAnisotropy = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkSamplerCreateInfo_getmaxAnisotropy(PyVkSamplerCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxAnisotropy);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSamplerCreateInfo_setminLod(PyVkSamplerCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minLod");
                        return -1;
                    }
                (self->base)->minLod = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkSamplerCreateInfo_getminLod(PyVkSamplerCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->minLod);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSamplerCreateInfo_setmaxLod(PyVkSamplerCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxLod");
                        return -1;
                    }
                (self->base)->maxLod = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkSamplerCreateInfo_getmaxLod(PyVkSamplerCreateInfo *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxLod);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSamplerCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkSamplerCreateInfo_getpNext, (setter)PyVkSamplerCreateInfo_setpNext, "", NULL},
                    
                        { "mipLodBias", (getter)PyVkSamplerCreateInfo_getmipLodBias, (setter)PyVkSamplerCreateInfo_setmipLodBias, "", NULL},
                    
                        { "maxAnisotropy", (getter)PyVkSamplerCreateInfo_getmaxAnisotropy, (setter)PyVkSamplerCreateInfo_setmaxAnisotropy, "", NULL},
                    
                        { "minLod", (getter)PyVkSamplerCreateInfo_getminLod, (setter)PyVkSamplerCreateInfo_setminLod, "", NULL},
                    
                        { "maxLod", (getter)PyVkSamplerCreateInfo_getmaxLod, (setter)PyVkSamplerCreateInfo_setmaxLod, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSamplerCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSamplerCreateInfo", sizeof(PyVkSamplerCreateInfo), 0,
                    (destructor)PyVkSamplerCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSamplerCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkSamplerCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkSamplerCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkCommandPoolCreateInfo *base; }
                PyVkCommandPoolCreateInfo;
                
                static void PyVkCommandPoolCreateInfo_del(PyVkCommandPoolCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkCommandPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkCommandPoolCreateInfo *self;
                    self = (PyVkCommandPoolCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkCommandPoolCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkCommandPoolCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkCommandPoolCreateInfo_setpNext(PyVkCommandPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkCommandPoolCreateInfo_getpNext(PyVkCommandPoolCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCommandPoolCreateInfo_setqueueFamilyIndex(PyVkCommandPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueFamilyIndex");
                        return -1;
                    }
                (self->base)->queueFamilyIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCommandPoolCreateInfo_getqueueFamilyIndex(PyVkCommandPoolCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkCommandPoolCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkCommandPoolCreateInfo_getpNext, (setter)PyVkCommandPoolCreateInfo_setpNext, "", NULL},
                    
                        { "queueFamilyIndex", (getter)PyVkCommandPoolCreateInfo_getqueueFamilyIndex, (setter)PyVkCommandPoolCreateInfo_setqueueFamilyIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkCommandPoolCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkCommandPoolCreateInfo", sizeof(PyVkCommandPoolCreateInfo), 0,
                    (destructor)PyVkCommandPoolCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkCommandPoolCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkCommandPoolCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkCommandPoolCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkCommandBufferAllocateInfo *base; }
                PyVkCommandBufferAllocateInfo;
                
                static void PyVkCommandBufferAllocateInfo_del(PyVkCommandBufferAllocateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkCommandBufferAllocateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkCommandBufferAllocateInfo *self;
                    self = (PyVkCommandBufferAllocateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkCommandBufferAllocateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkCommandBufferAllocateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkCommandBufferAllocateInfo_setpNext(PyVkCommandBufferAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkCommandBufferAllocateInfo_getpNext(PyVkCommandBufferAllocateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCommandBufferAllocateInfo_setcommandBufferCount(PyVkCommandBufferAllocateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with commandBufferCount");
                        return -1;
                    }
                (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCommandBufferAllocateInfo_getcommandBufferCount(PyVkCommandBufferAllocateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkCommandBufferAllocateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkCommandBufferAllocateInfo_getpNext, (setter)PyVkCommandBufferAllocateInfo_setpNext, "", NULL},
                    
                        { "commandBufferCount", (getter)PyVkCommandBufferAllocateInfo_getcommandBufferCount, (setter)PyVkCommandBufferAllocateInfo_setcommandBufferCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkCommandBufferAllocateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkCommandBufferAllocateInfo", sizeof(PyVkCommandBufferAllocateInfo), 0,
                    (destructor)PyVkCommandBufferAllocateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkCommandBufferAllocateInfo object",0,0,0,0,0,0,0,0,
                    PyVkCommandBufferAllocateInfo_getsetters,0,0,0,0,0,0,0,PyVkCommandBufferAllocateInfo_new,};
            
                typedef struct { PyObject_HEAD VkCommandBufferInheritanceInfo *base; }
                PyVkCommandBufferInheritanceInfo;
                
                static void PyVkCommandBufferInheritanceInfo_del(PyVkCommandBufferInheritanceInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkCommandBufferInheritanceInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkCommandBufferInheritanceInfo *self;
                    self = (PyVkCommandBufferInheritanceInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkCommandBufferInheritanceInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkCommandBufferInheritanceInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkCommandBufferInheritanceInfo_setpNext(PyVkCommandBufferInheritanceInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkCommandBufferInheritanceInfo_getpNext(PyVkCommandBufferInheritanceInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkCommandBufferInheritanceInfo_setsubpass(PyVkCommandBufferInheritanceInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subpass");
                        return -1;
                    }
                (self->base)->subpass = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkCommandBufferInheritanceInfo_getsubpass(PyVkCommandBufferInheritanceInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subpass);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkCommandBufferInheritanceInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkCommandBufferInheritanceInfo_getpNext, (setter)PyVkCommandBufferInheritanceInfo_setpNext, "", NULL},
                    
                        { "subpass", (getter)PyVkCommandBufferInheritanceInfo_getsubpass, (setter)PyVkCommandBufferInheritanceInfo_setsubpass, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkCommandBufferInheritanceInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkCommandBufferInheritanceInfo", sizeof(PyVkCommandBufferInheritanceInfo), 0,
                    (destructor)PyVkCommandBufferInheritanceInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkCommandBufferInheritanceInfo object",0,0,0,0,0,0,0,0,
                    PyVkCommandBufferInheritanceInfo_getsetters,0,0,0,0,0,0,0,PyVkCommandBufferInheritanceInfo_new,};
            
                typedef struct { PyObject_HEAD VkCommandBufferBeginInfo *base; }
                PyVkCommandBufferBeginInfo;
                
                static void PyVkCommandBufferBeginInfo_del(PyVkCommandBufferBeginInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkCommandBufferBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkCommandBufferBeginInfo *self;
                    self = (PyVkCommandBufferBeginInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkCommandBufferBeginInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkCommandBufferBeginInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkCommandBufferBeginInfo_setpNext(PyVkCommandBufferBeginInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkCommandBufferBeginInfo_getpNext(PyVkCommandBufferBeginInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkCommandBufferBeginInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkCommandBufferBeginInfo_getpNext, (setter)PyVkCommandBufferBeginInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkCommandBufferBeginInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkCommandBufferBeginInfo", sizeof(PyVkCommandBufferBeginInfo), 0,
                    (destructor)PyVkCommandBufferBeginInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkCommandBufferBeginInfo object",0,0,0,0,0,0,0,0,
                    PyVkCommandBufferBeginInfo_getsetters,0,0,0,0,0,0,0,PyVkCommandBufferBeginInfo_new,};
            
                typedef struct { PyObject_HEAD VkRenderPassBeginInfo *base; }
                PyVkRenderPassBeginInfo;
                
                static void PyVkRenderPassBeginInfo_del(PyVkRenderPassBeginInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkRenderPassBeginInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkRenderPassBeginInfo *self;
                    self = (PyVkRenderPassBeginInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkRenderPassBeginInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkRenderPassBeginInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkRenderPassBeginInfo_setpNext(PyVkRenderPassBeginInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkRenderPassBeginInfo_getpNext(PyVkRenderPassBeginInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkRenderPassBeginInfo_setclearValueCount(PyVkRenderPassBeginInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with clearValueCount");
                        return -1;
                    }
                (self->base)->clearValueCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkRenderPassBeginInfo_getclearValueCount(PyVkRenderPassBeginInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->clearValueCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkRenderPassBeginInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkRenderPassBeginInfo_getpNext, (setter)PyVkRenderPassBeginInfo_setpNext, "", NULL},
                    
                        { "clearValueCount", (getter)PyVkRenderPassBeginInfo_getclearValueCount, (setter)PyVkRenderPassBeginInfo_setclearValueCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkRenderPassBeginInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkRenderPassBeginInfo", sizeof(PyVkRenderPassBeginInfo), 0,
                    (destructor)PyVkRenderPassBeginInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkRenderPassBeginInfo object",0,0,0,0,0,0,0,0,
                    PyVkRenderPassBeginInfo_getsetters,0,0,0,0,0,0,0,PyVkRenderPassBeginInfo_new,};
            
                typedef struct { PyObject_HEAD VkClearDepthStencilValue *base; }
                PyVkClearDepthStencilValue;
                
                static void PyVkClearDepthStencilValue_del(PyVkClearDepthStencilValue* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkClearDepthStencilValue_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkClearDepthStencilValue *self;
                    self = (PyVkClearDepthStencilValue *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkClearDepthStencilValue));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkClearDepthStencilValue");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkClearDepthStencilValue_setdepth(PyVkClearDepthStencilValue *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with depth");
                        return -1;
                    }
                (self->base)->depth = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkClearDepthStencilValue_getdepth(PyVkClearDepthStencilValue *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->depth);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkClearDepthStencilValue_setstencil(PyVkClearDepthStencilValue *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with stencil");
                        return -1;
                    }
                (self->base)->stencil = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkClearDepthStencilValue_getstencil(PyVkClearDepthStencilValue *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->stencil);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkClearDepthStencilValue_getsetters[] = {
                    
                        { "depth", (getter)PyVkClearDepthStencilValue_getdepth, (setter)PyVkClearDepthStencilValue_setdepth, "", NULL},
                    
                        { "stencil", (getter)PyVkClearDepthStencilValue_getstencil, (setter)PyVkClearDepthStencilValue_setstencil, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkClearDepthStencilValueType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkClearDepthStencilValue", sizeof(PyVkClearDepthStencilValue), 0,
                    (destructor)PyVkClearDepthStencilValue_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkClearDepthStencilValue object",0,0,0,0,0,0,0,0,
                    PyVkClearDepthStencilValue_getsetters,0,0,0,0,0,0,0,PyVkClearDepthStencilValue_new,};
            
                typedef struct { PyObject_HEAD VkClearAttachment *base; }
                PyVkClearAttachment;
                
                static void PyVkClearAttachment_del(PyVkClearAttachment* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkClearAttachment_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkClearAttachment *self;
                    self = (PyVkClearAttachment *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkClearAttachment));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkClearAttachment");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkClearAttachment_setcolorAttachment(PyVkClearAttachment *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with colorAttachment");
                        return -1;
                    }
                (self->base)->colorAttachment = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkClearAttachment_getcolorAttachment(PyVkClearAttachment *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachment);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkClearAttachment_getsetters[] = {
                    
                        { "colorAttachment", (getter)PyVkClearAttachment_getcolorAttachment, (setter)PyVkClearAttachment_setcolorAttachment, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkClearAttachmentType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkClearAttachment", sizeof(PyVkClearAttachment), 0,
                    (destructor)PyVkClearAttachment_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkClearAttachment object",0,0,0,0,0,0,0,0,
                    PyVkClearAttachment_getsetters,0,0,0,0,0,0,0,PyVkClearAttachment_new,};
            
                typedef struct { PyObject_HEAD VkAttachmentDescription *base; }
                PyVkAttachmentDescription;
                
                static void PyVkAttachmentDescription_del(PyVkAttachmentDescription* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkAttachmentDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkAttachmentDescription *self;
                    self = (PyVkAttachmentDescription *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkAttachmentDescription));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkAttachmentDescription");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkAttachmentDescription_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkAttachmentDescriptionType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkAttachmentDescription", sizeof(PyVkAttachmentDescription), 0,
                    (destructor)PyVkAttachmentDescription_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkAttachmentDescription object",0,0,0,0,0,0,0,0,
                    PyVkAttachmentDescription_getsetters,0,0,0,0,0,0,0,PyVkAttachmentDescription_new,};
            
                typedef struct { PyObject_HEAD VkAttachmentReference *base; }
                PyVkAttachmentReference;
                
                static void PyVkAttachmentReference_del(PyVkAttachmentReference* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkAttachmentReference_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkAttachmentReference *self;
                    self = (PyVkAttachmentReference *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkAttachmentReference));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkAttachmentReference");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkAttachmentReference_setattachment(PyVkAttachmentReference *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with attachment");
                        return -1;
                    }
                (self->base)->attachment = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkAttachmentReference_getattachment(PyVkAttachmentReference *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->attachment);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkAttachmentReference_getsetters[] = {
                    
                        { "attachment", (getter)PyVkAttachmentReference_getattachment, (setter)PyVkAttachmentReference_setattachment, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkAttachmentReferenceType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkAttachmentReference", sizeof(PyVkAttachmentReference), 0,
                    (destructor)PyVkAttachmentReference_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkAttachmentReference object",0,0,0,0,0,0,0,0,
                    PyVkAttachmentReference_getsetters,0,0,0,0,0,0,0,PyVkAttachmentReference_new,};
            
                typedef struct { PyObject_HEAD VkSubpassDescription *base; }
                PyVkSubpassDescription;
                
                static void PyVkSubpassDescription_del(PyVkSubpassDescription* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSubpassDescription_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSubpassDescription *self;
                    self = (PyVkSubpassDescription *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSubpassDescription));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSubpassDescription");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSubpassDescription_setinputAttachmentCount(PyVkSubpassDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with inputAttachmentCount");
                        return -1;
                    }
                (self->base)->inputAttachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubpassDescription_getinputAttachmentCount(PyVkSubpassDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->inputAttachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubpassDescription_setcolorAttachmentCount(PyVkSubpassDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with colorAttachmentCount");
                        return -1;
                    }
                (self->base)->colorAttachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubpassDescription_getcolorAttachmentCount(PyVkSubpassDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->colorAttachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubpassDescription_setpreserveAttachmentCount(PyVkSubpassDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with preserveAttachmentCount");
                        return -1;
                    }
                (self->base)->preserveAttachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubpassDescription_getpreserveAttachmentCount(PyVkSubpassDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->preserveAttachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubpassDescription_setpPreserveAttachments(PyVkSubpassDescription *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pPreserveAttachments");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pPreserveAttachments = t;
            
                    return 0;
                }
                
                static PyObject * PyVkSubpassDescription_getpPreserveAttachments(PyVkSubpassDescription *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pPreserveAttachments)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSubpassDescription_getsetters[] = {
                    
                        { "inputAttachmentCount", (getter)PyVkSubpassDescription_getinputAttachmentCount, (setter)PyVkSubpassDescription_setinputAttachmentCount, "", NULL},
                    
                        { "colorAttachmentCount", (getter)PyVkSubpassDescription_getcolorAttachmentCount, (setter)PyVkSubpassDescription_setcolorAttachmentCount, "", NULL},
                    
                        { "preserveAttachmentCount", (getter)PyVkSubpassDescription_getpreserveAttachmentCount, (setter)PyVkSubpassDescription_setpreserveAttachmentCount, "", NULL},
                    
                        { "pPreserveAttachments", (getter)PyVkSubpassDescription_getpPreserveAttachments, (setter)PyVkSubpassDescription_setpPreserveAttachments, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSubpassDescriptionType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSubpassDescription", sizeof(PyVkSubpassDescription), 0,
                    (destructor)PyVkSubpassDescription_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSubpassDescription object",0,0,0,0,0,0,0,0,
                    PyVkSubpassDescription_getsetters,0,0,0,0,0,0,0,PyVkSubpassDescription_new,};
            
                typedef struct { PyObject_HEAD VkSubpassDependency *base; }
                PyVkSubpassDependency;
                
                static void PyVkSubpassDependency_del(PyVkSubpassDependency* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSubpassDependency_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSubpassDependency *self;
                    self = (PyVkSubpassDependency *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSubpassDependency));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSubpassDependency");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSubpassDependency_setsrcSubpass(PyVkSubpassDependency *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with srcSubpass");
                        return -1;
                    }
                (self->base)->srcSubpass = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubpassDependency_getsrcSubpass(PyVkSubpassDependency *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->srcSubpass);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubpassDependency_setdstSubpass(PyVkSubpassDependency *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dstSubpass");
                        return -1;
                    }
                (self->base)->dstSubpass = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubpassDependency_getdstSubpass(PyVkSubpassDependency *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dstSubpass);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSubpassDependency_getsetters[] = {
                    
                        { "srcSubpass", (getter)PyVkSubpassDependency_getsrcSubpass, (setter)PyVkSubpassDependency_setsrcSubpass, "", NULL},
                    
                        { "dstSubpass", (getter)PyVkSubpassDependency_getdstSubpass, (setter)PyVkSubpassDependency_setdstSubpass, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSubpassDependencyType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSubpassDependency", sizeof(PyVkSubpassDependency), 0,
                    (destructor)PyVkSubpassDependency_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSubpassDependency object",0,0,0,0,0,0,0,0,
                    PyVkSubpassDependency_getsetters,0,0,0,0,0,0,0,PyVkSubpassDependency_new,};
            
                typedef struct { PyObject_HEAD VkRenderPassCreateInfo *base; }
                PyVkRenderPassCreateInfo;
                
                static void PyVkRenderPassCreateInfo_del(PyVkRenderPassCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkRenderPassCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkRenderPassCreateInfo *self;
                    self = (PyVkRenderPassCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkRenderPassCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkRenderPassCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkRenderPassCreateInfo_setpNext(PyVkRenderPassCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkRenderPassCreateInfo_getpNext(PyVkRenderPassCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkRenderPassCreateInfo_setattachmentCount(PyVkRenderPassCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with attachmentCount");
                        return -1;
                    }
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkRenderPassCreateInfo_getattachmentCount(PyVkRenderPassCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkRenderPassCreateInfo_setsubpassCount(PyVkRenderPassCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subpassCount");
                        return -1;
                    }
                (self->base)->subpassCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkRenderPassCreateInfo_getsubpassCount(PyVkRenderPassCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subpassCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkRenderPassCreateInfo_setdependencyCount(PyVkRenderPassCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dependencyCount");
                        return -1;
                    }
                (self->base)->dependencyCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkRenderPassCreateInfo_getdependencyCount(PyVkRenderPassCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->dependencyCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkRenderPassCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkRenderPassCreateInfo_getpNext, (setter)PyVkRenderPassCreateInfo_setpNext, "", NULL},
                    
                        { "attachmentCount", (getter)PyVkRenderPassCreateInfo_getattachmentCount, (setter)PyVkRenderPassCreateInfo_setattachmentCount, "", NULL},
                    
                        { "subpassCount", (getter)PyVkRenderPassCreateInfo_getsubpassCount, (setter)PyVkRenderPassCreateInfo_setsubpassCount, "", NULL},
                    
                        { "dependencyCount", (getter)PyVkRenderPassCreateInfo_getdependencyCount, (setter)PyVkRenderPassCreateInfo_setdependencyCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkRenderPassCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkRenderPassCreateInfo", sizeof(PyVkRenderPassCreateInfo), 0,
                    (destructor)PyVkRenderPassCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkRenderPassCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkRenderPassCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkRenderPassCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkEventCreateInfo *base; }
                PyVkEventCreateInfo;
                
                static void PyVkEventCreateInfo_del(PyVkEventCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkEventCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkEventCreateInfo *self;
                    self = (PyVkEventCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkEventCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkEventCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkEventCreateInfo_setpNext(PyVkEventCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkEventCreateInfo_getpNext(PyVkEventCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkEventCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkEventCreateInfo_getpNext, (setter)PyVkEventCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkEventCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkEventCreateInfo", sizeof(PyVkEventCreateInfo), 0,
                    (destructor)PyVkEventCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkEventCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkEventCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkEventCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkFenceCreateInfo *base; }
                PyVkFenceCreateInfo;
                
                static void PyVkFenceCreateInfo_del(PyVkFenceCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkFenceCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkFenceCreateInfo *self;
                    self = (PyVkFenceCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkFenceCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkFenceCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkFenceCreateInfo_setpNext(PyVkFenceCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkFenceCreateInfo_getpNext(PyVkFenceCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkFenceCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkFenceCreateInfo_getpNext, (setter)PyVkFenceCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkFenceCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkFenceCreateInfo", sizeof(PyVkFenceCreateInfo), 0,
                    (destructor)PyVkFenceCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkFenceCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkFenceCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkFenceCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkPhysicalDeviceFeatures *base; }
                PyVkPhysicalDeviceFeatures;
                
                static void PyVkPhysicalDeviceFeatures_del(PyVkPhysicalDeviceFeatures* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPhysicalDeviceFeatures_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPhysicalDeviceFeatures *self;
                    self = (PyVkPhysicalDeviceFeatures *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPhysicalDeviceFeatures));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPhysicalDeviceFeatures");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkPhysicalDeviceFeatures_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkPhysicalDeviceFeaturesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPhysicalDeviceFeatures", sizeof(PyVkPhysicalDeviceFeatures), 0,
                    (destructor)PyVkPhysicalDeviceFeatures_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPhysicalDeviceFeatures object",0,0,0,0,0,0,0,0,
                    PyVkPhysicalDeviceFeatures_getsetters,0,0,0,0,0,0,0,PyVkPhysicalDeviceFeatures_new,};
            
                typedef struct { PyObject_HEAD VkPhysicalDeviceSparseProperties *base; }
                PyVkPhysicalDeviceSparseProperties;
                
                static void PyVkPhysicalDeviceSparseProperties_del(PyVkPhysicalDeviceSparseProperties* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPhysicalDeviceSparseProperties_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPhysicalDeviceSparseProperties *self;
                    self = (PyVkPhysicalDeviceSparseProperties *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPhysicalDeviceSparseProperties));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPhysicalDeviceSparseProperties");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkPhysicalDeviceSparseProperties_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkPhysicalDeviceSparsePropertiesType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPhysicalDeviceSparseProperties", sizeof(PyVkPhysicalDeviceSparseProperties), 0,
                    (destructor)PyVkPhysicalDeviceSparseProperties_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPhysicalDeviceSparseProperties object",0,0,0,0,0,0,0,0,
                    PyVkPhysicalDeviceSparseProperties_getsetters,0,0,0,0,0,0,0,PyVkPhysicalDeviceSparseProperties_new,};
            
                typedef struct { PyObject_HEAD VkPhysicalDeviceLimits *base; }
                PyVkPhysicalDeviceLimits;
                
                static void PyVkPhysicalDeviceLimits_del(PyVkPhysicalDeviceLimits* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPhysicalDeviceLimits_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPhysicalDeviceLimits *self;
                    self = (PyVkPhysicalDeviceLimits *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPhysicalDeviceLimits));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPhysicalDeviceLimits");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxImageDimension1D(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageDimension1D");
                        return -1;
                    }
                (self->base)->maxImageDimension1D = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension1D(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension1D);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxImageDimension2D(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageDimension2D");
                        return -1;
                    }
                (self->base)->maxImageDimension2D = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension2D(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension2D);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxImageDimension3D(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageDimension3D");
                        return -1;
                    }
                (self->base)->maxImageDimension3D = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimension3D(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimension3D);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxImageDimensionCube(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageDimensionCube");
                        return -1;
                    }
                (self->base)->maxImageDimensionCube = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxImageDimensionCube(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageDimensionCube);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxImageArrayLayers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageArrayLayers");
                        return -1;
                    }
                (self->base)->maxImageArrayLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxImageArrayLayers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTexelBufferElements(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTexelBufferElements");
                        return -1;
                    }
                (self->base)->maxTexelBufferElements = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelBufferElements(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelBufferElements);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxUniformBufferRange(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxUniformBufferRange");
                        return -1;
                    }
                (self->base)->maxUniformBufferRange = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxUniformBufferRange(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxUniformBufferRange);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxStorageBufferRange(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxStorageBufferRange");
                        return -1;
                    }
                (self->base)->maxStorageBufferRange = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxStorageBufferRange(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxStorageBufferRange);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPushConstantsSize(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPushConstantsSize");
                        return -1;
                    }
                (self->base)->maxPushConstantsSize = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPushConstantsSize(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPushConstantsSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxMemoryAllocationCount(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxMemoryAllocationCount");
                        return -1;
                    }
                (self->base)->maxMemoryAllocationCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxMemoryAllocationCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxSamplerAllocationCount(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxSamplerAllocationCount");
                        return -1;
                    }
                (self->base)->maxSamplerAllocationCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxSamplerAllocationCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxBoundDescriptorSets(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxBoundDescriptorSets");
                        return -1;
                    }
                (self->base)->maxBoundDescriptorSets = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxBoundDescriptorSets);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorSamplers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorSamplers");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorSamplers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSamplers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorUniformBuffers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorUniformBuffers");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorUniformBuffers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorUniformBuffers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorStorageBuffers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorStorageBuffers");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorStorageBuffers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageBuffers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorSampledImages(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorSampledImages");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorSampledImages = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorSampledImages);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorStorageImages(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorStorageImages");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorStorageImages = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorStorageImages);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorInputAttachments(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageDescriptorInputAttachments");
                        return -1;
                    }
                (self->base)->maxPerStageDescriptorInputAttachments = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageDescriptorInputAttachments);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxPerStageResources(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxPerStageResources");
                        return -1;
                    }
                (self->base)->maxPerStageResources = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxPerStageResources(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxPerStageResources);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetSamplers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetSamplers");
                        return -1;
                    }
                (self->base)->maxDescriptorSetSamplers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSamplers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetUniformBuffers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetUniformBuffers");
                        return -1;
                    }
                (self->base)->maxDescriptorSetUniformBuffers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetUniformBuffersDynamic(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetUniformBuffersDynamic");
                        return -1;
                    }
                (self->base)->maxDescriptorSetUniformBuffersDynamic = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetUniformBuffersDynamic);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageBuffers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetStorageBuffers");
                        return -1;
                    }
                (self->base)->maxDescriptorSetStorageBuffers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageBuffersDynamic(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetStorageBuffersDynamic");
                        return -1;
                    }
                (self->base)->maxDescriptorSetStorageBuffersDynamic = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageBuffersDynamic);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetSampledImages(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetSampledImages");
                        return -1;
                    }
                (self->base)->maxDescriptorSetSampledImages = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetSampledImages);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageImages(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetStorageImages");
                        return -1;
                    }
                (self->base)->maxDescriptorSetStorageImages = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetStorageImages);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDescriptorSetInputAttachments(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDescriptorSetInputAttachments");
                        return -1;
                    }
                (self->base)->maxDescriptorSetInputAttachments = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDescriptorSetInputAttachments);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxVertexInputAttributes(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxVertexInputAttributes");
                        return -1;
                    }
                (self->base)->maxVertexInputAttributes = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributes);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxVertexInputBindings(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxVertexInputBindings");
                        return -1;
                    }
                (self->base)->maxVertexInputBindings = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindings(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindings);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxVertexInputAttributeOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxVertexInputAttributeOffset");
                        return -1;
                    }
                (self->base)->maxVertexInputAttributeOffset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputAttributeOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxVertexInputBindingStride(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxVertexInputBindingStride");
                        return -1;
                    }
                (self->base)->maxVertexInputBindingStride = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexInputBindingStride);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxVertexOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxVertexOutputComponents");
                        return -1;
                    }
                (self->base)->maxVertexOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxVertexOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationGenerationLevel(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationGenerationLevel");
                        return -1;
                    }
                (self->base)->maxTessellationGenerationLevel = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationGenerationLevel);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationPatchSize(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationPatchSize");
                        return -1;
                    }
                (self->base)->maxTessellationPatchSize = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationPatchSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationControlPerVertexInputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationControlPerVertexInputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationControlPerVertexInputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexInputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationControlPerVertexOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationControlPerVertexOutputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationControlPerVertexOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerVertexOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationControlPerPatchOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationControlPerPatchOutputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationControlPerPatchOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlPerPatchOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationControlTotalOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationControlTotalOutputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationControlTotalOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationControlTotalOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationEvaluationInputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationEvaluationInputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationEvaluationInputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationInputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTessellationEvaluationOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTessellationEvaluationOutputComponents");
                        return -1;
                    }
                (self->base)->maxTessellationEvaluationOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTessellationEvaluationOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxGeometryShaderInvocations(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxGeometryShaderInvocations");
                        return -1;
                    }
                (self->base)->maxGeometryShaderInvocations = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryShaderInvocations);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxGeometryInputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxGeometryInputComponents");
                        return -1;
                    }
                (self->base)->maxGeometryInputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryInputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxGeometryOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxGeometryOutputComponents");
                        return -1;
                    }
                (self->base)->maxGeometryOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxGeometryOutputVertices(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxGeometryOutputVertices");
                        return -1;
                    }
                (self->base)->maxGeometryOutputVertices = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryOutputVertices);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxGeometryTotalOutputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxGeometryTotalOutputComponents");
                        return -1;
                    }
                (self->base)->maxGeometryTotalOutputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxGeometryTotalOutputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFragmentInputComponents(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFragmentInputComponents");
                        return -1;
                    }
                (self->base)->maxFragmentInputComponents = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentInputComponents);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFragmentOutputAttachments(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFragmentOutputAttachments");
                        return -1;
                    }
                (self->base)->maxFragmentOutputAttachments = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentOutputAttachments);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFragmentDualSrcAttachments(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFragmentDualSrcAttachments");
                        return -1;
                    }
                (self->base)->maxFragmentDualSrcAttachments = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentDualSrcAttachments);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFragmentCombinedOutputResources(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFragmentCombinedOutputResources");
                        return -1;
                    }
                (self->base)->maxFragmentCombinedOutputResources = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFragmentCombinedOutputResources);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxComputeSharedMemorySize(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxComputeSharedMemorySize");
                        return -1;
                    }
                (self->base)->maxComputeSharedMemorySize = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeSharedMemorySize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupCount(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxComputeWorkGroupCount");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                uint32_t tmp = (uint32_t) PyLong_AsLong(PyList_GetItem(value, i));
                ((self->base)->maxComputeWorkGroupCount)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->maxComputeWorkGroupCount) / sizeof((self->base)->maxComputeWorkGroupCount[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupCount[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupInvocations(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxComputeWorkGroupInvocations");
                        return -1;
                    }
                (self->base)->maxComputeWorkGroupInvocations = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupInvocations);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupSize(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxComputeWorkGroupSize");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                uint32_t tmp = (uint32_t) PyLong_AsLong(PyList_GetItem(value, i));
                ((self->base)->maxComputeWorkGroupSize)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->maxComputeWorkGroupSize) / sizeof((self->base)->maxComputeWorkGroupSize[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxComputeWorkGroupSize[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setsubPixelPrecisionBits(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subPixelPrecisionBits");
                        return -1;
                    }
                (self->base)->subPixelPrecisionBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subPixelPrecisionBits);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setsubTexelPrecisionBits(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subTexelPrecisionBits");
                        return -1;
                    }
                (self->base)->subTexelPrecisionBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subTexelPrecisionBits);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmipmapPrecisionBits(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with mipmapPrecisionBits");
                        return -1;
                    }
                (self->base)->mipmapPrecisionBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmipmapPrecisionBits(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->mipmapPrecisionBits);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDrawIndexedIndexValue(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDrawIndexedIndexValue");
                        return -1;
                    }
                (self->base)->maxDrawIndexedIndexValue = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndexedIndexValue);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxDrawIndirectCount(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxDrawIndirectCount");
                        return -1;
                    }
                (self->base)->maxDrawIndirectCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxDrawIndirectCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxSamplerLodBias(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxSamplerLodBias");
                        return -1;
                    }
                (self->base)->maxSamplerLodBias = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerLodBias(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerLodBias);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxSamplerAnisotropy(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxSamplerAnisotropy");
                        return -1;
                    }
                (self->base)->maxSamplerAnisotropy = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxSamplerAnisotropy);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxViewports(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxViewports");
                        return -1;
                    }
                (self->base)->maxViewports = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxViewports(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxViewports);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxViewportDimensions(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxViewportDimensions");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                uint32_t tmp = (uint32_t) PyLong_AsLong(PyList_GetItem(value, i));
                ((self->base)->maxViewportDimensions)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxViewportDimensions(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->maxViewportDimensions) / sizeof((self->base)->maxViewportDimensions[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyLong_FromLong((long) (self->base)->maxViewportDimensions[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setviewportBoundsRange(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with viewportBoundsRange");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                float tmp = (float) PyFloat_AsDouble(PyList_GetItem(value, i));
                ((self->base)->viewportBoundsRange)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getviewportBoundsRange(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->viewportBoundsRange) / sizeof((self->base)->viewportBoundsRange[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->viewportBoundsRange[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setviewportSubPixelBits(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with viewportSubPixelBits");
                        return -1;
                    }
                (self->base)->viewportSubPixelBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getviewportSubPixelBits(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->viewportSubPixelBits);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setminMemoryMapAlignment(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minMemoryMapAlignment");
                        return -1;
                    }
                (self->base)->minMemoryMapAlignment = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getminMemoryMapAlignment(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->minMemoryMapAlignment);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setminTexelOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minTexelOffset");
                        return -1;
                    }
                (self->base)->minTexelOffset = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getminTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->minTexelOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTexelOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTexelOffset");
                        return -1;
                    }
                (self->base)->maxTexelOffset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setminTexelGatherOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minTexelGatherOffset");
                        return -1;
                    }
                (self->base)->minTexelGatherOffset = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getminTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->minTexelGatherOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxTexelGatherOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxTexelGatherOffset");
                        return -1;
                    }
                (self->base)->maxTexelGatherOffset = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxTexelGatherOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setminInterpolationOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minInterpolationOffset");
                        return -1;
                    }
                (self->base)->minInterpolationOffset = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getminInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->minInterpolationOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxInterpolationOffset(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxInterpolationOffset");
                        return -1;
                    }
                (self->base)->maxInterpolationOffset = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxInterpolationOffset(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->maxInterpolationOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setsubPixelInterpolationOffsetBits(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with subPixelInterpolationOffsetBits");
                        return -1;
                    }
                (self->base)->subPixelInterpolationOffsetBits = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->subPixelInterpolationOffsetBits);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFramebufferWidth(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFramebufferWidth");
                        return -1;
                    }
                (self->base)->maxFramebufferWidth = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferWidth(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferWidth);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFramebufferHeight(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFramebufferHeight");
                        return -1;
                    }
                (self->base)->maxFramebufferHeight = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferHeight(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferHeight);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxFramebufferLayers(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxFramebufferLayers");
                        return -1;
                    }
                (self->base)->maxFramebufferLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxFramebufferLayers(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxFramebufferLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxColorAttachments(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxColorAttachments");
                        return -1;
                    }
                (self->base)->maxColorAttachments = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxColorAttachments(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxColorAttachments);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxSampleMaskWords(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxSampleMaskWords");
                        return -1;
                    }
                (self->base)->maxSampleMaskWords = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxSampleMaskWords(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxSampleMaskWords);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_settimestampPeriod(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with timestampPeriod");
                        return -1;
                    }
                (self->base)->timestampPeriod = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_gettimestampPeriod(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->timestampPeriod);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxClipDistances(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxClipDistances");
                        return -1;
                    }
                (self->base)->maxClipDistances = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxClipDistances(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxClipDistances);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxCullDistances(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxCullDistances");
                        return -1;
                    }
                (self->base)->maxCullDistances = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxCullDistances(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxCullDistances);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setmaxCombinedClipAndCullDistances(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxCombinedClipAndCullDistances");
                        return -1;
                    }
                (self->base)->maxCombinedClipAndCullDistances = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxCombinedClipAndCullDistances);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setdiscreteQueuePriorities(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with discreteQueuePriorities");
                        return -1;
                    }
                (self->base)->discreteQueuePriorities = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->discreteQueuePriorities);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setpointSizeRange(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pointSizeRange");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                float tmp = (float) PyFloat_AsDouble(PyList_GetItem(value, i));
                ((self->base)->pointSizeRange)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getpointSizeRange(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->pointSizeRange) / sizeof((self->base)->pointSizeRange[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->pointSizeRange[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setlineWidthRange(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with lineWidthRange");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                float tmp = (float) PyFloat_AsDouble(PyList_GetItem(value, i));
                ((self->base)->lineWidthRange)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getlineWidthRange(PyVkPhysicalDeviceLimits *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->lineWidthRange) / sizeof((self->base)->lineWidthRange[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->lineWidthRange[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setpointSizeGranularity(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pointSizeGranularity");
                        return -1;
                    }
                (self->base)->pointSizeGranularity = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getpointSizeGranularity(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->pointSizeGranularity);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPhysicalDeviceLimits_setlineWidthGranularity(PyVkPhysicalDeviceLimits *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with lineWidthGranularity");
                        return -1;
                    }
                (self->base)->lineWidthGranularity = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkPhysicalDeviceLimits_getlineWidthGranularity(PyVkPhysicalDeviceLimits *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->lineWidthGranularity);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPhysicalDeviceLimits_getsetters[] = {
                    
                        { "maxImageDimension1D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension1D, (setter)PyVkPhysicalDeviceLimits_setmaxImageDimension1D, "", NULL},
                    
                        { "maxImageDimension2D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension2D, (setter)PyVkPhysicalDeviceLimits_setmaxImageDimension2D, "", NULL},
                    
                        { "maxImageDimension3D", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimension3D, (setter)PyVkPhysicalDeviceLimits_setmaxImageDimension3D, "", NULL},
                    
                        { "maxImageDimensionCube", (getter)PyVkPhysicalDeviceLimits_getmaxImageDimensionCube, (setter)PyVkPhysicalDeviceLimits_setmaxImageDimensionCube, "", NULL},
                    
                        { "maxImageArrayLayers", (getter)PyVkPhysicalDeviceLimits_getmaxImageArrayLayers, (setter)PyVkPhysicalDeviceLimits_setmaxImageArrayLayers, "", NULL},
                    
                        { "maxTexelBufferElements", (getter)PyVkPhysicalDeviceLimits_getmaxTexelBufferElements, (setter)PyVkPhysicalDeviceLimits_setmaxTexelBufferElements, "", NULL},
                    
                        { "maxUniformBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxUniformBufferRange, (setter)PyVkPhysicalDeviceLimits_setmaxUniformBufferRange, "", NULL},
                    
                        { "maxStorageBufferRange", (getter)PyVkPhysicalDeviceLimits_getmaxStorageBufferRange, (setter)PyVkPhysicalDeviceLimits_setmaxStorageBufferRange, "", NULL},
                    
                        { "maxPushConstantsSize", (getter)PyVkPhysicalDeviceLimits_getmaxPushConstantsSize, (setter)PyVkPhysicalDeviceLimits_setmaxPushConstantsSize, "", NULL},
                    
                        { "maxMemoryAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxMemoryAllocationCount, (setter)PyVkPhysicalDeviceLimits_setmaxMemoryAllocationCount, "", NULL},
                    
                        { "maxSamplerAllocationCount", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAllocationCount, (setter)PyVkPhysicalDeviceLimits_setmaxSamplerAllocationCount, "", NULL},
                    
                        { "maxBoundDescriptorSets", (getter)PyVkPhysicalDeviceLimits_getmaxBoundDescriptorSets, (setter)PyVkPhysicalDeviceLimits_setmaxBoundDescriptorSets, "", NULL},
                    
                        { "maxPerStageDescriptorSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSamplers, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorSamplers, "", NULL},
                    
                        { "maxPerStageDescriptorUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorUniformBuffers, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorUniformBuffers, "", NULL},
                    
                        { "maxPerStageDescriptorStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageBuffers, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorStorageBuffers, "", NULL},
                    
                        { "maxPerStageDescriptorSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorSampledImages, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorSampledImages, "", NULL},
                    
                        { "maxPerStageDescriptorStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorStorageImages, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorStorageImages, "", NULL},
                    
                        { "maxPerStageDescriptorInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageDescriptorInputAttachments, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageDescriptorInputAttachments, "", NULL},
                    
                        { "maxPerStageResources", (getter)PyVkPhysicalDeviceLimits_getmaxPerStageResources, (setter)PyVkPhysicalDeviceLimits_setmaxPerStageResources, "", NULL},
                    
                        { "maxDescriptorSetSamplers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSamplers, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetSamplers, "", NULL},
                    
                        { "maxDescriptorSetUniformBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffers, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetUniformBuffers, "", NULL},
                    
                        { "maxDescriptorSetUniformBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetUniformBuffersDynamic, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetUniformBuffersDynamic, "", NULL},
                    
                        { "maxDescriptorSetStorageBuffers", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffers, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageBuffers, "", NULL},
                    
                        { "maxDescriptorSetStorageBuffersDynamic", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageBuffersDynamic, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageBuffersDynamic, "", NULL},
                    
                        { "maxDescriptorSetSampledImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetSampledImages, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetSampledImages, "", NULL},
                    
                        { "maxDescriptorSetStorageImages", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetStorageImages, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetStorageImages, "", NULL},
                    
                        { "maxDescriptorSetInputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxDescriptorSetInputAttachments, (setter)PyVkPhysicalDeviceLimits_setmaxDescriptorSetInputAttachments, "", NULL},
                    
                        { "maxVertexInputAttributes", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributes, (setter)PyVkPhysicalDeviceLimits_setmaxVertexInputAttributes, "", NULL},
                    
                        { "maxVertexInputBindings", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindings, (setter)PyVkPhysicalDeviceLimits_setmaxVertexInputBindings, "", NULL},
                    
                        { "maxVertexInputAttributeOffset", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputAttributeOffset, (setter)PyVkPhysicalDeviceLimits_setmaxVertexInputAttributeOffset, "", NULL},
                    
                        { "maxVertexInputBindingStride", (getter)PyVkPhysicalDeviceLimits_getmaxVertexInputBindingStride, (setter)PyVkPhysicalDeviceLimits_setmaxVertexInputBindingStride, "", NULL},
                    
                        { "maxVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxVertexOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxVertexOutputComponents, "", NULL},
                    
                        { "maxTessellationGenerationLevel", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationGenerationLevel, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationGenerationLevel, "", NULL},
                    
                        { "maxTessellationPatchSize", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationPatchSize, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationPatchSize, "", NULL},
                    
                        { "maxTessellationControlPerVertexInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexInputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationControlPerVertexInputComponents, "", NULL},
                    
                        { "maxTessellationControlPerVertexOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerVertexOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationControlPerVertexOutputComponents, "", NULL},
                    
                        { "maxTessellationControlPerPatchOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlPerPatchOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationControlPerPatchOutputComponents, "", NULL},
                    
                        { "maxTessellationControlTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationControlTotalOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationControlTotalOutputComponents, "", NULL},
                    
                        { "maxTessellationEvaluationInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationInputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationEvaluationInputComponents, "", NULL},
                    
                        { "maxTessellationEvaluationOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxTessellationEvaluationOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxTessellationEvaluationOutputComponents, "", NULL},
                    
                        { "maxGeometryShaderInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryShaderInvocations, (setter)PyVkPhysicalDeviceLimits_setmaxGeometryShaderInvocations, "", NULL},
                    
                        { "maxGeometryInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryInputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxGeometryInputComponents, "", NULL},
                    
                        { "maxGeometryOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxGeometryOutputComponents, "", NULL},
                    
                        { "maxGeometryOutputVertices", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryOutputVertices, (setter)PyVkPhysicalDeviceLimits_setmaxGeometryOutputVertices, "", NULL},
                    
                        { "maxGeometryTotalOutputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxGeometryTotalOutputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxGeometryTotalOutputComponents, "", NULL},
                    
                        { "maxFragmentInputComponents", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentInputComponents, (setter)PyVkPhysicalDeviceLimits_setmaxFragmentInputComponents, "", NULL},
                    
                        { "maxFragmentOutputAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentOutputAttachments, (setter)PyVkPhysicalDeviceLimits_setmaxFragmentOutputAttachments, "", NULL},
                    
                        { "maxFragmentDualSrcAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentDualSrcAttachments, (setter)PyVkPhysicalDeviceLimits_setmaxFragmentDualSrcAttachments, "", NULL},
                    
                        { "maxFragmentCombinedOutputResources", (getter)PyVkPhysicalDeviceLimits_getmaxFragmentCombinedOutputResources, (setter)PyVkPhysicalDeviceLimits_setmaxFragmentCombinedOutputResources, "", NULL},
                    
                        { "maxComputeSharedMemorySize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeSharedMemorySize, (setter)PyVkPhysicalDeviceLimits_setmaxComputeSharedMemorySize, "", NULL},
                    
                        { "maxComputeWorkGroupCount", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupCount, (setter)PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupCount, "", NULL},
                    
                        { "maxComputeWorkGroupInvocations", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupInvocations, (setter)PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupInvocations, "", NULL},
                    
                        { "maxComputeWorkGroupSize", (getter)PyVkPhysicalDeviceLimits_getmaxComputeWorkGroupSize, (setter)PyVkPhysicalDeviceLimits_setmaxComputeWorkGroupSize, "", NULL},
                    
                        { "subPixelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelPrecisionBits, (setter)PyVkPhysicalDeviceLimits_setsubPixelPrecisionBits, "", NULL},
                    
                        { "subTexelPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getsubTexelPrecisionBits, (setter)PyVkPhysicalDeviceLimits_setsubTexelPrecisionBits, "", NULL},
                    
                        { "mipmapPrecisionBits", (getter)PyVkPhysicalDeviceLimits_getmipmapPrecisionBits, (setter)PyVkPhysicalDeviceLimits_setmipmapPrecisionBits, "", NULL},
                    
                        { "maxDrawIndexedIndexValue", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndexedIndexValue, (setter)PyVkPhysicalDeviceLimits_setmaxDrawIndexedIndexValue, "", NULL},
                    
                        { "maxDrawIndirectCount", (getter)PyVkPhysicalDeviceLimits_getmaxDrawIndirectCount, (setter)PyVkPhysicalDeviceLimits_setmaxDrawIndirectCount, "", NULL},
                    
                        { "maxSamplerLodBias", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerLodBias, (setter)PyVkPhysicalDeviceLimits_setmaxSamplerLodBias, "", NULL},
                    
                        { "maxSamplerAnisotropy", (getter)PyVkPhysicalDeviceLimits_getmaxSamplerAnisotropy, (setter)PyVkPhysicalDeviceLimits_setmaxSamplerAnisotropy, "", NULL},
                    
                        { "maxViewports", (getter)PyVkPhysicalDeviceLimits_getmaxViewports, (setter)PyVkPhysicalDeviceLimits_setmaxViewports, "", NULL},
                    
                        { "maxViewportDimensions", (getter)PyVkPhysicalDeviceLimits_getmaxViewportDimensions, (setter)PyVkPhysicalDeviceLimits_setmaxViewportDimensions, "", NULL},
                    
                        { "viewportBoundsRange", (getter)PyVkPhysicalDeviceLimits_getviewportBoundsRange, (setter)PyVkPhysicalDeviceLimits_setviewportBoundsRange, "", NULL},
                    
                        { "viewportSubPixelBits", (getter)PyVkPhysicalDeviceLimits_getviewportSubPixelBits, (setter)PyVkPhysicalDeviceLimits_setviewportSubPixelBits, "", NULL},
                    
                        { "minMemoryMapAlignment", (getter)PyVkPhysicalDeviceLimits_getminMemoryMapAlignment, (setter)PyVkPhysicalDeviceLimits_setminMemoryMapAlignment, "", NULL},
                    
                        { "minTexelOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelOffset, (setter)PyVkPhysicalDeviceLimits_setminTexelOffset, "", NULL},
                    
                        { "maxTexelOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelOffset, (setter)PyVkPhysicalDeviceLimits_setmaxTexelOffset, "", NULL},
                    
                        { "minTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getminTexelGatherOffset, (setter)PyVkPhysicalDeviceLimits_setminTexelGatherOffset, "", NULL},
                    
                        { "maxTexelGatherOffset", (getter)PyVkPhysicalDeviceLimits_getmaxTexelGatherOffset, (setter)PyVkPhysicalDeviceLimits_setmaxTexelGatherOffset, "", NULL},
                    
                        { "minInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getminInterpolationOffset, (setter)PyVkPhysicalDeviceLimits_setminInterpolationOffset, "", NULL},
                    
                        { "maxInterpolationOffset", (getter)PyVkPhysicalDeviceLimits_getmaxInterpolationOffset, (setter)PyVkPhysicalDeviceLimits_setmaxInterpolationOffset, "", NULL},
                    
                        { "subPixelInterpolationOffsetBits", (getter)PyVkPhysicalDeviceLimits_getsubPixelInterpolationOffsetBits, (setter)PyVkPhysicalDeviceLimits_setsubPixelInterpolationOffsetBits, "", NULL},
                    
                        { "maxFramebufferWidth", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferWidth, (setter)PyVkPhysicalDeviceLimits_setmaxFramebufferWidth, "", NULL},
                    
                        { "maxFramebufferHeight", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferHeight, (setter)PyVkPhysicalDeviceLimits_setmaxFramebufferHeight, "", NULL},
                    
                        { "maxFramebufferLayers", (getter)PyVkPhysicalDeviceLimits_getmaxFramebufferLayers, (setter)PyVkPhysicalDeviceLimits_setmaxFramebufferLayers, "", NULL},
                    
                        { "maxColorAttachments", (getter)PyVkPhysicalDeviceLimits_getmaxColorAttachments, (setter)PyVkPhysicalDeviceLimits_setmaxColorAttachments, "", NULL},
                    
                        { "maxSampleMaskWords", (getter)PyVkPhysicalDeviceLimits_getmaxSampleMaskWords, (setter)PyVkPhysicalDeviceLimits_setmaxSampleMaskWords, "", NULL},
                    
                        { "timestampPeriod", (getter)PyVkPhysicalDeviceLimits_gettimestampPeriod, (setter)PyVkPhysicalDeviceLimits_settimestampPeriod, "", NULL},
                    
                        { "maxClipDistances", (getter)PyVkPhysicalDeviceLimits_getmaxClipDistances, (setter)PyVkPhysicalDeviceLimits_setmaxClipDistances, "", NULL},
                    
                        { "maxCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCullDistances, (setter)PyVkPhysicalDeviceLimits_setmaxCullDistances, "", NULL},
                    
                        { "maxCombinedClipAndCullDistances", (getter)PyVkPhysicalDeviceLimits_getmaxCombinedClipAndCullDistances, (setter)PyVkPhysicalDeviceLimits_setmaxCombinedClipAndCullDistances, "", NULL},
                    
                        { "discreteQueuePriorities", (getter)PyVkPhysicalDeviceLimits_getdiscreteQueuePriorities, (setter)PyVkPhysicalDeviceLimits_setdiscreteQueuePriorities, "", NULL},
                    
                        { "pointSizeRange", (getter)PyVkPhysicalDeviceLimits_getpointSizeRange, (setter)PyVkPhysicalDeviceLimits_setpointSizeRange, "", NULL},
                    
                        { "lineWidthRange", (getter)PyVkPhysicalDeviceLimits_getlineWidthRange, (setter)PyVkPhysicalDeviceLimits_setlineWidthRange, "", NULL},
                    
                        { "pointSizeGranularity", (getter)PyVkPhysicalDeviceLimits_getpointSizeGranularity, (setter)PyVkPhysicalDeviceLimits_setpointSizeGranularity, "", NULL},
                    
                        { "lineWidthGranularity", (getter)PyVkPhysicalDeviceLimits_getlineWidthGranularity, (setter)PyVkPhysicalDeviceLimits_setlineWidthGranularity, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPhysicalDeviceLimitsType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPhysicalDeviceLimits", sizeof(PyVkPhysicalDeviceLimits), 0,
                    (destructor)PyVkPhysicalDeviceLimits_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPhysicalDeviceLimits object",0,0,0,0,0,0,0,0,
                    PyVkPhysicalDeviceLimits_getsetters,0,0,0,0,0,0,0,PyVkPhysicalDeviceLimits_new,};
            
                typedef struct { PyObject_HEAD VkSemaphoreCreateInfo *base; }
                PyVkSemaphoreCreateInfo;
                
                static void PyVkSemaphoreCreateInfo_del(PyVkSemaphoreCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSemaphoreCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSemaphoreCreateInfo *self;
                    self = (PyVkSemaphoreCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSemaphoreCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSemaphoreCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSemaphoreCreateInfo_setpNext(PyVkSemaphoreCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkSemaphoreCreateInfo_getpNext(PyVkSemaphoreCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSemaphoreCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkSemaphoreCreateInfo_getpNext, (setter)PyVkSemaphoreCreateInfo_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSemaphoreCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSemaphoreCreateInfo", sizeof(PyVkSemaphoreCreateInfo), 0,
                    (destructor)PyVkSemaphoreCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSemaphoreCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkSemaphoreCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkSemaphoreCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkQueryPoolCreateInfo *base; }
                PyVkQueryPoolCreateInfo;
                
                static void PyVkQueryPoolCreateInfo_del(PyVkQueryPoolCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkQueryPoolCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkQueryPoolCreateInfo *self;
                    self = (PyVkQueryPoolCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkQueryPoolCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkQueryPoolCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkQueryPoolCreateInfo_setpNext(PyVkQueryPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkQueryPoolCreateInfo_getpNext(PyVkQueryPoolCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkQueryPoolCreateInfo_setqueryCount(PyVkQueryPoolCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queryCount");
                        return -1;
                    }
                (self->base)->queryCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkQueryPoolCreateInfo_getqueryCount(PyVkQueryPoolCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queryCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkQueryPoolCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkQueryPoolCreateInfo_getpNext, (setter)PyVkQueryPoolCreateInfo_setpNext, "", NULL},
                    
                        { "queryCount", (getter)PyVkQueryPoolCreateInfo_getqueryCount, (setter)PyVkQueryPoolCreateInfo_setqueryCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkQueryPoolCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkQueryPoolCreateInfo", sizeof(PyVkQueryPoolCreateInfo), 0,
                    (destructor)PyVkQueryPoolCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkQueryPoolCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkQueryPoolCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkQueryPoolCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkFramebufferCreateInfo *base; }
                PyVkFramebufferCreateInfo;
                
                static void PyVkFramebufferCreateInfo_del(PyVkFramebufferCreateInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkFramebufferCreateInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkFramebufferCreateInfo *self;
                    self = (PyVkFramebufferCreateInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkFramebufferCreateInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkFramebufferCreateInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkFramebufferCreateInfo_setpNext(PyVkFramebufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkFramebufferCreateInfo_getpNext(PyVkFramebufferCreateInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkFramebufferCreateInfo_setattachmentCount(PyVkFramebufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with attachmentCount");
                        return -1;
                    }
                (self->base)->attachmentCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkFramebufferCreateInfo_getattachmentCount(PyVkFramebufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->attachmentCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkFramebufferCreateInfo_setwidth(PyVkFramebufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with width");
                        return -1;
                    }
                (self->base)->width = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkFramebufferCreateInfo_getwidth(PyVkFramebufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->width);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkFramebufferCreateInfo_setheight(PyVkFramebufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with height");
                        return -1;
                    }
                (self->base)->height = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkFramebufferCreateInfo_getheight(PyVkFramebufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->height);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkFramebufferCreateInfo_setlayers(PyVkFramebufferCreateInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with layers");
                        return -1;
                    }
                (self->base)->layers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkFramebufferCreateInfo_getlayers(PyVkFramebufferCreateInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->layers);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkFramebufferCreateInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkFramebufferCreateInfo_getpNext, (setter)PyVkFramebufferCreateInfo_setpNext, "", NULL},
                    
                        { "attachmentCount", (getter)PyVkFramebufferCreateInfo_getattachmentCount, (setter)PyVkFramebufferCreateInfo_setattachmentCount, "", NULL},
                    
                        { "width", (getter)PyVkFramebufferCreateInfo_getwidth, (setter)PyVkFramebufferCreateInfo_setwidth, "", NULL},
                    
                        { "height", (getter)PyVkFramebufferCreateInfo_getheight, (setter)PyVkFramebufferCreateInfo_setheight, "", NULL},
                    
                        { "layers", (getter)PyVkFramebufferCreateInfo_getlayers, (setter)PyVkFramebufferCreateInfo_setlayers, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkFramebufferCreateInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkFramebufferCreateInfo", sizeof(PyVkFramebufferCreateInfo), 0,
                    (destructor)PyVkFramebufferCreateInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkFramebufferCreateInfo object",0,0,0,0,0,0,0,0,
                    PyVkFramebufferCreateInfo_getsetters,0,0,0,0,0,0,0,PyVkFramebufferCreateInfo_new,};
            
                typedef struct { PyObject_HEAD VkDrawIndirectCommand *base; }
                PyVkDrawIndirectCommand;
                
                static void PyVkDrawIndirectCommand_del(PyVkDrawIndirectCommand* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDrawIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDrawIndirectCommand *self;
                    self = (PyVkDrawIndirectCommand *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDrawIndirectCommand));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDrawIndirectCommand");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDrawIndirectCommand_setvertexCount(PyVkDrawIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with vertexCount");
                        return -1;
                    }
                (self->base)->vertexCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndirectCommand_getvertexCount(PyVkDrawIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->vertexCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndirectCommand_setinstanceCount(PyVkDrawIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with instanceCount");
                        return -1;
                    }
                (self->base)->instanceCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndirectCommand_getinstanceCount(PyVkDrawIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndirectCommand_setfirstVertex(PyVkDrawIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with firstVertex");
                        return -1;
                    }
                (self->base)->firstVertex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndirectCommand_getfirstVertex(PyVkDrawIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->firstVertex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndirectCommand_setfirstInstance(PyVkDrawIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with firstInstance");
                        return -1;
                    }
                (self->base)->firstInstance = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndirectCommand_getfirstInstance(PyVkDrawIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDrawIndirectCommand_getsetters[] = {
                    
                        { "vertexCount", (getter)PyVkDrawIndirectCommand_getvertexCount, (setter)PyVkDrawIndirectCommand_setvertexCount, "", NULL},
                    
                        { "instanceCount", (getter)PyVkDrawIndirectCommand_getinstanceCount, (setter)PyVkDrawIndirectCommand_setinstanceCount, "", NULL},
                    
                        { "firstVertex", (getter)PyVkDrawIndirectCommand_getfirstVertex, (setter)PyVkDrawIndirectCommand_setfirstVertex, "", NULL},
                    
                        { "firstInstance", (getter)PyVkDrawIndirectCommand_getfirstInstance, (setter)PyVkDrawIndirectCommand_setfirstInstance, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDrawIndirectCommandType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDrawIndirectCommand", sizeof(PyVkDrawIndirectCommand), 0,
                    (destructor)PyVkDrawIndirectCommand_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDrawIndirectCommand object",0,0,0,0,0,0,0,0,
                    PyVkDrawIndirectCommand_getsetters,0,0,0,0,0,0,0,PyVkDrawIndirectCommand_new,};
            
                typedef struct { PyObject_HEAD VkDrawIndexedIndirectCommand *base; }
                PyVkDrawIndexedIndirectCommand;
                
                static void PyVkDrawIndexedIndirectCommand_del(PyVkDrawIndexedIndirectCommand* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDrawIndexedIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDrawIndexedIndirectCommand *self;
                    self = (PyVkDrawIndexedIndirectCommand *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDrawIndexedIndirectCommand));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDrawIndexedIndirectCommand");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDrawIndexedIndirectCommand_setindexCount(PyVkDrawIndexedIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with indexCount");
                        return -1;
                    }
                (self->base)->indexCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndexedIndirectCommand_getindexCount(PyVkDrawIndexedIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->indexCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndexedIndirectCommand_setinstanceCount(PyVkDrawIndexedIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with instanceCount");
                        return -1;
                    }
                (self->base)->instanceCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndexedIndirectCommand_getinstanceCount(PyVkDrawIndexedIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->instanceCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndexedIndirectCommand_setfirstIndex(PyVkDrawIndexedIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with firstIndex");
                        return -1;
                    }
                (self->base)->firstIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndexedIndirectCommand_getfirstIndex(PyVkDrawIndexedIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->firstIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndexedIndirectCommand_setvertexOffset(PyVkDrawIndexedIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with vertexOffset");
                        return -1;
                    }
                (self->base)->vertexOffset = (int32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndexedIndirectCommand_getvertexOffset(PyVkDrawIndexedIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->vertexOffset);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDrawIndexedIndirectCommand_setfirstInstance(PyVkDrawIndexedIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with firstInstance");
                        return -1;
                    }
                (self->base)->firstInstance = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDrawIndexedIndirectCommand_getfirstInstance(PyVkDrawIndexedIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->firstInstance);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDrawIndexedIndirectCommand_getsetters[] = {
                    
                        { "indexCount", (getter)PyVkDrawIndexedIndirectCommand_getindexCount, (setter)PyVkDrawIndexedIndirectCommand_setindexCount, "", NULL},
                    
                        { "instanceCount", (getter)PyVkDrawIndexedIndirectCommand_getinstanceCount, (setter)PyVkDrawIndexedIndirectCommand_setinstanceCount, "", NULL},
                    
                        { "firstIndex", (getter)PyVkDrawIndexedIndirectCommand_getfirstIndex, (setter)PyVkDrawIndexedIndirectCommand_setfirstIndex, "", NULL},
                    
                        { "vertexOffset", (getter)PyVkDrawIndexedIndirectCommand_getvertexOffset, (setter)PyVkDrawIndexedIndirectCommand_setvertexOffset, "", NULL},
                    
                        { "firstInstance", (getter)PyVkDrawIndexedIndirectCommand_getfirstInstance, (setter)PyVkDrawIndexedIndirectCommand_setfirstInstance, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDrawIndexedIndirectCommandType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDrawIndexedIndirectCommand", sizeof(PyVkDrawIndexedIndirectCommand), 0,
                    (destructor)PyVkDrawIndexedIndirectCommand_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDrawIndexedIndirectCommand object",0,0,0,0,0,0,0,0,
                    PyVkDrawIndexedIndirectCommand_getsetters,0,0,0,0,0,0,0,PyVkDrawIndexedIndirectCommand_new,};
            
                typedef struct { PyObject_HEAD VkDispatchIndirectCommand *base; }
                PyVkDispatchIndirectCommand;
                
                static void PyVkDispatchIndirectCommand_del(PyVkDispatchIndirectCommand* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDispatchIndirectCommand_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDispatchIndirectCommand *self;
                    self = (PyVkDispatchIndirectCommand *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDispatchIndirectCommand));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDispatchIndirectCommand");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDispatchIndirectCommand_setx(PyVkDispatchIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with x");
                        return -1;
                    }
                (self->base)->x = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDispatchIndirectCommand_getx(PyVkDispatchIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->x);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDispatchIndirectCommand_sety(PyVkDispatchIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with y");
                        return -1;
                    }
                (self->base)->y = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDispatchIndirectCommand_gety(PyVkDispatchIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->y);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDispatchIndirectCommand_setz(PyVkDispatchIndirectCommand *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with z");
                        return -1;
                    }
                (self->base)->z = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDispatchIndirectCommand_getz(PyVkDispatchIndirectCommand *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->z);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDispatchIndirectCommand_getsetters[] = {
                    
                        { "x", (getter)PyVkDispatchIndirectCommand_getx, (setter)PyVkDispatchIndirectCommand_setx, "", NULL},
                    
                        { "y", (getter)PyVkDispatchIndirectCommand_gety, (setter)PyVkDispatchIndirectCommand_sety, "", NULL},
                    
                        { "z", (getter)PyVkDispatchIndirectCommand_getz, (setter)PyVkDispatchIndirectCommand_setz, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDispatchIndirectCommandType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDispatchIndirectCommand", sizeof(PyVkDispatchIndirectCommand), 0,
                    (destructor)PyVkDispatchIndirectCommand_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDispatchIndirectCommand object",0,0,0,0,0,0,0,0,
                    PyVkDispatchIndirectCommand_getsetters,0,0,0,0,0,0,0,PyVkDispatchIndirectCommand_new,};
            
                typedef struct { PyObject_HEAD VkSubmitInfo *base; }
                PyVkSubmitInfo;
                
                static void PyVkSubmitInfo_del(PyVkSubmitInfo* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSubmitInfo_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSubmitInfo *self;
                    self = (PyVkSubmitInfo *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSubmitInfo));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSubmitInfo");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSubmitInfo_setpNext(PyVkSubmitInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkSubmitInfo_getpNext(PyVkSubmitInfo *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubmitInfo_setwaitSemaphoreCount(PyVkSubmitInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with waitSemaphoreCount");
                        return -1;
                    }
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubmitInfo_getwaitSemaphoreCount(PyVkSubmitInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubmitInfo_setcommandBufferCount(PyVkSubmitInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with commandBufferCount");
                        return -1;
                    }
                (self->base)->commandBufferCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubmitInfo_getcommandBufferCount(PyVkSubmitInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->commandBufferCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSubmitInfo_setsignalSemaphoreCount(PyVkSubmitInfo *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with signalSemaphoreCount");
                        return -1;
                    }
                (self->base)->signalSemaphoreCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSubmitInfo_getsignalSemaphoreCount(PyVkSubmitInfo *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->signalSemaphoreCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSubmitInfo_getsetters[] = {
                    
                        { "pNext", (getter)PyVkSubmitInfo_getpNext, (setter)PyVkSubmitInfo_setpNext, "", NULL},
                    
                        { "waitSemaphoreCount", (getter)PyVkSubmitInfo_getwaitSemaphoreCount, (setter)PyVkSubmitInfo_setwaitSemaphoreCount, "", NULL},
                    
                        { "commandBufferCount", (getter)PyVkSubmitInfo_getcommandBufferCount, (setter)PyVkSubmitInfo_setcommandBufferCount, "", NULL},
                    
                        { "signalSemaphoreCount", (getter)PyVkSubmitInfo_getsignalSemaphoreCount, (setter)PyVkSubmitInfo_setsignalSemaphoreCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSubmitInfoType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSubmitInfo", sizeof(PyVkSubmitInfo), 0,
                    (destructor)PyVkSubmitInfo_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSubmitInfo object",0,0,0,0,0,0,0,0,
                    PyVkSubmitInfo_getsetters,0,0,0,0,0,0,0,PyVkSubmitInfo_new,};
            
                typedef struct { PyObject_HEAD VkDisplayPropertiesKHR *base; }
                PyVkDisplayPropertiesKHR;
                
                static void PyVkDisplayPropertiesKHR_del(PyVkDisplayPropertiesKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayPropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayPropertiesKHR *self;
                    self = (PyVkDisplayPropertiesKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayPropertiesKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayPropertiesKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplayPropertiesKHR_setdisplayName(PyVkDisplayPropertiesKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with displayName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->displayName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkDisplayPropertiesKHR_getdisplayName(PyVkDisplayPropertiesKHR *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->displayName);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplayPropertiesKHR_getsetters[] = {
                    
                        { "displayName", (getter)PyVkDisplayPropertiesKHR_getdisplayName, (setter)PyVkDisplayPropertiesKHR_setdisplayName, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplayPropertiesKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayPropertiesKHR", sizeof(PyVkDisplayPropertiesKHR), 0,
                    (destructor)PyVkDisplayPropertiesKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayPropertiesKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayPropertiesKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayPropertiesKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayPlanePropertiesKHR *base; }
                PyVkDisplayPlanePropertiesKHR;
                
                static void PyVkDisplayPlanePropertiesKHR_del(PyVkDisplayPlanePropertiesKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayPlanePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayPlanePropertiesKHR *self;
                    self = (PyVkDisplayPlanePropertiesKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayPlanePropertiesKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayPlanePropertiesKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplayPlanePropertiesKHR_setcurrentStackIndex(PyVkDisplayPlanePropertiesKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with currentStackIndex");
                        return -1;
                    }
                (self->base)->currentStackIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex(PyVkDisplayPlanePropertiesKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->currentStackIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplayPlanePropertiesKHR_getsetters[] = {
                    
                        { "currentStackIndex", (getter)PyVkDisplayPlanePropertiesKHR_getcurrentStackIndex, (setter)PyVkDisplayPlanePropertiesKHR_setcurrentStackIndex, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplayPlanePropertiesKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayPlanePropertiesKHR", sizeof(PyVkDisplayPlanePropertiesKHR), 0,
                    (destructor)PyVkDisplayPlanePropertiesKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayPlanePropertiesKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayPlanePropertiesKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayPlanePropertiesKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayModeParametersKHR *base; }
                PyVkDisplayModeParametersKHR;
                
                static void PyVkDisplayModeParametersKHR_del(PyVkDisplayModeParametersKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayModeParametersKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayModeParametersKHR *self;
                    self = (PyVkDisplayModeParametersKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayModeParametersKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayModeParametersKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplayModeParametersKHR_setrefreshRate(PyVkDisplayModeParametersKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with refreshRate");
                        return -1;
                    }
                (self->base)->refreshRate = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDisplayModeParametersKHR_getrefreshRate(PyVkDisplayModeParametersKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->refreshRate);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplayModeParametersKHR_getsetters[] = {
                    
                        { "refreshRate", (getter)PyVkDisplayModeParametersKHR_getrefreshRate, (setter)PyVkDisplayModeParametersKHR_setrefreshRate, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplayModeParametersKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayModeParametersKHR", sizeof(PyVkDisplayModeParametersKHR), 0,
                    (destructor)PyVkDisplayModeParametersKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayModeParametersKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayModeParametersKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayModeParametersKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayModePropertiesKHR *base; }
                PyVkDisplayModePropertiesKHR;
                
                static void PyVkDisplayModePropertiesKHR_del(PyVkDisplayModePropertiesKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayModePropertiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayModePropertiesKHR *self;
                    self = (PyVkDisplayModePropertiesKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayModePropertiesKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayModePropertiesKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkDisplayModePropertiesKHR_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkDisplayModePropertiesKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayModePropertiesKHR", sizeof(PyVkDisplayModePropertiesKHR), 0,
                    (destructor)PyVkDisplayModePropertiesKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayModePropertiesKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayModePropertiesKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayModePropertiesKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayModeCreateInfoKHR *base; }
                PyVkDisplayModeCreateInfoKHR;
                
                static void PyVkDisplayModeCreateInfoKHR_del(PyVkDisplayModeCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayModeCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayModeCreateInfoKHR *self;
                    self = (PyVkDisplayModeCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayModeCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayModeCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplayModeCreateInfoKHR_setpNext(PyVkDisplayModeCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDisplayModeCreateInfoKHR_getpNext(PyVkDisplayModeCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplayModeCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDisplayModeCreateInfoKHR_getpNext, (setter)PyVkDisplayModeCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplayModeCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayModeCreateInfoKHR", sizeof(PyVkDisplayModeCreateInfoKHR), 0,
                    (destructor)PyVkDisplayModeCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayModeCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayModeCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayModeCreateInfoKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayPlaneCapabilitiesKHR *base; }
                PyVkDisplayPlaneCapabilitiesKHR;
                
                static void PyVkDisplayPlaneCapabilitiesKHR_del(PyVkDisplayPlaneCapabilitiesKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayPlaneCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayPlaneCapabilitiesKHR *self;
                    self = (PyVkDisplayPlaneCapabilitiesKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayPlaneCapabilitiesKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkDisplayPlaneCapabilitiesKHR_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkDisplayPlaneCapabilitiesKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayPlaneCapabilitiesKHR", sizeof(PyVkDisplayPlaneCapabilitiesKHR), 0,
                    (destructor)PyVkDisplayPlaneCapabilitiesKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayPlaneCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayPlaneCapabilitiesKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayPlaneCapabilitiesKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplaySurfaceCreateInfoKHR *base; }
                PyVkDisplaySurfaceCreateInfoKHR;
                
                static void PyVkDisplaySurfaceCreateInfoKHR_del(PyVkDisplaySurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplaySurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplaySurfaceCreateInfoKHR *self;
                    self = (PyVkDisplaySurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplaySurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplaySurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplaySurfaceCreateInfoKHR_setpNext(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getpNext(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDisplaySurfaceCreateInfoKHR_setplaneIndex(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with planeIndex");
                        return -1;
                    }
                (self->base)->planeIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->planeIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDisplaySurfaceCreateInfoKHR_setplaneStackIndex(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with planeStackIndex");
                        return -1;
                    }
                (self->base)->planeStackIndex = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->planeStackIndex);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDisplaySurfaceCreateInfoKHR_setglobalAlpha(PyVkDisplaySurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with globalAlpha");
                        return -1;
                    }
                (self->base)->globalAlpha = (float) PyFloat_AsDouble(value);
                    return 0;
                }
                
                static PyObject * PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha(PyVkDisplaySurfaceCreateInfoKHR *self, void *closure){
                PyObject* value = PyFloat_FromDouble((double) (self->base)->globalAlpha);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplaySurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDisplaySurfaceCreateInfoKHR_getpNext, (setter)PyVkDisplaySurfaceCreateInfoKHR_setpNext, "", NULL},
                    
                        { "planeIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneIndex, (setter)PyVkDisplaySurfaceCreateInfoKHR_setplaneIndex, "", NULL},
                    
                        { "planeStackIndex", (getter)PyVkDisplaySurfaceCreateInfoKHR_getplaneStackIndex, (setter)PyVkDisplaySurfaceCreateInfoKHR_setplaneStackIndex, "", NULL},
                    
                        { "globalAlpha", (getter)PyVkDisplaySurfaceCreateInfoKHR_getglobalAlpha, (setter)PyVkDisplaySurfaceCreateInfoKHR_setglobalAlpha, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplaySurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplaySurfaceCreateInfoKHR", sizeof(PyVkDisplaySurfaceCreateInfoKHR), 0,
                    (destructor)PyVkDisplaySurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplaySurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplaySurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplaySurfaceCreateInfoKHR_new,};
            
                typedef struct { PyObject_HEAD VkDisplayPresentInfoKHR *base; }
                PyVkDisplayPresentInfoKHR;
                
                static void PyVkDisplayPresentInfoKHR_del(PyVkDisplayPresentInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDisplayPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDisplayPresentInfoKHR *self;
                    self = (PyVkDisplayPresentInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDisplayPresentInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDisplayPresentInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDisplayPresentInfoKHR_setpNext(PyVkDisplayPresentInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDisplayPresentInfoKHR_getpNext(PyVkDisplayPresentInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDisplayPresentInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDisplayPresentInfoKHR_getpNext, (setter)PyVkDisplayPresentInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDisplayPresentInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDisplayPresentInfoKHR", sizeof(PyVkDisplayPresentInfoKHR), 0,
                    (destructor)PyVkDisplayPresentInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDisplayPresentInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkDisplayPresentInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkDisplayPresentInfoKHR_new,};
            
                typedef struct { PyObject_HEAD VkSurfaceCapabilitiesKHR *base; }
                PyVkSurfaceCapabilitiesKHR;
                
                static void PyVkSurfaceCapabilitiesKHR_del(PyVkSurfaceCapabilitiesKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSurfaceCapabilitiesKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSurfaceCapabilitiesKHR *self;
                    self = (PyVkSurfaceCapabilitiesKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSurfaceCapabilitiesKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSurfaceCapabilitiesKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSurfaceCapabilitiesKHR_setminImageCount(PyVkSurfaceCapabilitiesKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minImageCount");
                        return -1;
                    }
                (self->base)->minImageCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSurfaceCapabilitiesKHR_getminImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSurfaceCapabilitiesKHR_setmaxImageCount(PyVkSurfaceCapabilitiesKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageCount");
                        return -1;
                    }
                (self->base)->maxImageCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageCount(PyVkSurfaceCapabilitiesKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSurfaceCapabilitiesKHR_setmaxImageArrayLayers(PyVkSurfaceCapabilitiesKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with maxImageArrayLayers");
                        return -1;
                    }
                (self->base)->maxImageArrayLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers(PyVkSurfaceCapabilitiesKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->maxImageArrayLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSurfaceCapabilitiesKHR_getsetters[] = {
                    
                        { "minImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getminImageCount, (setter)PyVkSurfaceCapabilitiesKHR_setminImageCount, "", NULL},
                    
                        { "maxImageCount", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageCount, (setter)PyVkSurfaceCapabilitiesKHR_setmaxImageCount, "", NULL},
                    
                        { "maxImageArrayLayers", (getter)PyVkSurfaceCapabilitiesKHR_getmaxImageArrayLayers, (setter)PyVkSurfaceCapabilitiesKHR_setmaxImageArrayLayers, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSurfaceCapabilitiesKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSurfaceCapabilitiesKHR", sizeof(PyVkSurfaceCapabilitiesKHR), 0,
                    (destructor)PyVkSurfaceCapabilitiesKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSurfaceCapabilitiesKHR object",0,0,0,0,0,0,0,0,
                    PyVkSurfaceCapabilitiesKHR_getsetters,0,0,0,0,0,0,0,PyVkSurfaceCapabilitiesKHR_new,};
            
#ifdef VK_USE_PLATFORM_ANDROID_KHR

                typedef struct { PyObject_HEAD VkAndroidSurfaceCreateInfoKHR *base; }
                PyVkAndroidSurfaceCreateInfoKHR;
                
                static void PyVkAndroidSurfaceCreateInfoKHR_del(PyVkAndroidSurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkAndroidSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkAndroidSurfaceCreateInfoKHR *self;
                    self = (PyVkAndroidSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkAndroidSurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkAndroidSurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkAndroidSurfaceCreateInfoKHR_setpNext(PyVkAndroidSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkAndroidSurfaceCreateInfoKHR_getpNext(PyVkAndroidSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkAndroidSurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkAndroidSurfaceCreateInfoKHR_getpNext, (setter)PyVkAndroidSurfaceCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkAndroidSurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkAndroidSurfaceCreateInfoKHR", sizeof(PyVkAndroidSurfaceCreateInfoKHR), 0,
                    (destructor)PyVkAndroidSurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkAndroidSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkAndroidSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkAndroidSurfaceCreateInfoKHR_new,};
            
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

                typedef struct { PyObject_HEAD VkMirSurfaceCreateInfoKHR *base; }
                PyVkMirSurfaceCreateInfoKHR;
                
                static void PyVkMirSurfaceCreateInfoKHR_del(PyVkMirSurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkMirSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkMirSurfaceCreateInfoKHR *self;
                    self = (PyVkMirSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkMirSurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkMirSurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkMirSurfaceCreateInfoKHR_setpNext(PyVkMirSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkMirSurfaceCreateInfoKHR_getpNext(PyVkMirSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkMirSurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkMirSurfaceCreateInfoKHR_getpNext, (setter)PyVkMirSurfaceCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkMirSurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkMirSurfaceCreateInfoKHR", sizeof(PyVkMirSurfaceCreateInfoKHR), 0,
                    (destructor)PyVkMirSurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkMirSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkMirSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkMirSurfaceCreateInfoKHR_new,};
            
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

                typedef struct { PyObject_HEAD VkWaylandSurfaceCreateInfoKHR *base; }
                PyVkWaylandSurfaceCreateInfoKHR;
                
                static void PyVkWaylandSurfaceCreateInfoKHR_del(PyVkWaylandSurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkWaylandSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkWaylandSurfaceCreateInfoKHR *self;
                    self = (PyVkWaylandSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkWaylandSurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkWaylandSurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkWaylandSurfaceCreateInfoKHR_setpNext(PyVkWaylandSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkWaylandSurfaceCreateInfoKHR_getpNext(PyVkWaylandSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkWaylandSurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkWaylandSurfaceCreateInfoKHR_getpNext, (setter)PyVkWaylandSurfaceCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkWaylandSurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkWaylandSurfaceCreateInfoKHR", sizeof(PyVkWaylandSurfaceCreateInfoKHR), 0,
                    (destructor)PyVkWaylandSurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkWaylandSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkWaylandSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkWaylandSurfaceCreateInfoKHR_new,};
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                typedef struct { PyObject_HEAD VkWin32SurfaceCreateInfoKHR *base; }
                PyVkWin32SurfaceCreateInfoKHR;
                
                static void PyVkWin32SurfaceCreateInfoKHR_del(PyVkWin32SurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkWin32SurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkWin32SurfaceCreateInfoKHR *self;
                    self = (PyVkWin32SurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkWin32SurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkWin32SurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkWin32SurfaceCreateInfoKHR_setpNext(PyVkWin32SurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkWin32SurfaceCreateInfoKHR_getpNext(PyVkWin32SurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkWin32SurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkWin32SurfaceCreateInfoKHR_getpNext, (setter)PyVkWin32SurfaceCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkWin32SurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkWin32SurfaceCreateInfoKHR", sizeof(PyVkWin32SurfaceCreateInfoKHR), 0,
                    (destructor)PyVkWin32SurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkWin32SurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkWin32SurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkWin32SurfaceCreateInfoKHR_new,};
            
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

                typedef struct { PyObject_HEAD VkXlibSurfaceCreateInfoKHR *base; }
                PyVkXlibSurfaceCreateInfoKHR;
                
                static void PyVkXlibSurfaceCreateInfoKHR_del(PyVkXlibSurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkXlibSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkXlibSurfaceCreateInfoKHR *self;
                    self = (PyVkXlibSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkXlibSurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkXlibSurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkXlibSurfaceCreateInfoKHR_setpNext(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkXlibSurfaceCreateInfoKHR_getpNext(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkXlibSurfaceCreateInfoKHR_setdpy(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with dpy");
                        return -1;
                    }
                (self->base)->dpy = (Display *) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkXlibSurfaceCreateInfoKHR_getdpy(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkXlibSurfaceCreateInfoKHR_setwindow(PyVkXlibSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with window");
                        return -1;
                    }
                (self->base)->window = (XID) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkXlibSurfaceCreateInfoKHR_getwindow(PyVkXlibSurfaceCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->window);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkXlibSurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkXlibSurfaceCreateInfoKHR_getpNext, (setter)PyVkXlibSurfaceCreateInfoKHR_setpNext, "", NULL},
                    
                        { "dpy", (getter)PyVkXlibSurfaceCreateInfoKHR_getdpy, (setter)PyVkXlibSurfaceCreateInfoKHR_setdpy, "", NULL},
                    
                        { "window", (getter)PyVkXlibSurfaceCreateInfoKHR_getwindow, (setter)PyVkXlibSurfaceCreateInfoKHR_setwindow, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkXlibSurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkXlibSurfaceCreateInfoKHR", sizeof(PyVkXlibSurfaceCreateInfoKHR), 0,
                    (destructor)PyVkXlibSurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkXlibSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkXlibSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkXlibSurfaceCreateInfoKHR_new,};
            
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

                typedef struct { PyObject_HEAD VkXcbSurfaceCreateInfoKHR *base; }
                PyVkXcbSurfaceCreateInfoKHR;
                
                static void PyVkXcbSurfaceCreateInfoKHR_del(PyVkXcbSurfaceCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkXcbSurfaceCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkXcbSurfaceCreateInfoKHR *self;
                    self = (PyVkXcbSurfaceCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkXcbSurfaceCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkXcbSurfaceCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkXcbSurfaceCreateInfoKHR_setpNext(PyVkXcbSurfaceCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkXcbSurfaceCreateInfoKHR_getpNext(PyVkXcbSurfaceCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkXcbSurfaceCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkXcbSurfaceCreateInfoKHR_getpNext, (setter)PyVkXcbSurfaceCreateInfoKHR_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkXcbSurfaceCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkXcbSurfaceCreateInfoKHR", sizeof(PyVkXcbSurfaceCreateInfoKHR), 0,
                    (destructor)PyVkXcbSurfaceCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkXcbSurfaceCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkXcbSurfaceCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkXcbSurfaceCreateInfoKHR_new,};
            
#endif

                typedef struct { PyObject_HEAD VkSurfaceFormatKHR *base; }
                PyVkSurfaceFormatKHR;
                
                static void PyVkSurfaceFormatKHR_del(PyVkSurfaceFormatKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSurfaceFormatKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSurfaceFormatKHR *self;
                    self = (PyVkSurfaceFormatKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSurfaceFormatKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSurfaceFormatKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkSurfaceFormatKHR_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkSurfaceFormatKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSurfaceFormatKHR", sizeof(PyVkSurfaceFormatKHR), 0,
                    (destructor)PyVkSurfaceFormatKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSurfaceFormatKHR object",0,0,0,0,0,0,0,0,
                    PyVkSurfaceFormatKHR_getsetters,0,0,0,0,0,0,0,PyVkSurfaceFormatKHR_new,};
            
                typedef struct { PyObject_HEAD VkSwapchainCreateInfoKHR *base; }
                PyVkSwapchainCreateInfoKHR;
                
                static void PyVkSwapchainCreateInfoKHR_del(PyVkSwapchainCreateInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkSwapchainCreateInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkSwapchainCreateInfoKHR *self;
                    self = (PyVkSwapchainCreateInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkSwapchainCreateInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkSwapchainCreateInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkSwapchainCreateInfoKHR_setpNext(PyVkSwapchainCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkSwapchainCreateInfoKHR_getpNext(PyVkSwapchainCreateInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSwapchainCreateInfoKHR_setminImageCount(PyVkSwapchainCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with minImageCount");
                        return -1;
                    }
                (self->base)->minImageCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSwapchainCreateInfoKHR_getminImageCount(PyVkSwapchainCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->minImageCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSwapchainCreateInfoKHR_setimageArrayLayers(PyVkSwapchainCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with imageArrayLayers");
                        return -1;
                    }
                (self->base)->imageArrayLayers = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSwapchainCreateInfoKHR_getimageArrayLayers(PyVkSwapchainCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->imageArrayLayers);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSwapchainCreateInfoKHR_setqueueFamilyIndexCount(PyVkSwapchainCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with queueFamilyIndexCount");
                        return -1;
                    }
                (self->base)->queueFamilyIndexCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount(PyVkSwapchainCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->queueFamilyIndexCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkSwapchainCreateInfoKHR_setpQueueFamilyIndices(PyVkSwapchainCreateInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pQueueFamilyIndices");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pQueueFamilyIndices = t;
            
                    return 0;
                }
                
                static PyObject * PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices(PyVkSwapchainCreateInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pQueueFamilyIndices)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkSwapchainCreateInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkSwapchainCreateInfoKHR_getpNext, (setter)PyVkSwapchainCreateInfoKHR_setpNext, "", NULL},
                    
                        { "minImageCount", (getter)PyVkSwapchainCreateInfoKHR_getminImageCount, (setter)PyVkSwapchainCreateInfoKHR_setminImageCount, "", NULL},
                    
                        { "imageArrayLayers", (getter)PyVkSwapchainCreateInfoKHR_getimageArrayLayers, (setter)PyVkSwapchainCreateInfoKHR_setimageArrayLayers, "", NULL},
                    
                        { "queueFamilyIndexCount", (getter)PyVkSwapchainCreateInfoKHR_getqueueFamilyIndexCount, (setter)PyVkSwapchainCreateInfoKHR_setqueueFamilyIndexCount, "", NULL},
                    
                        { "pQueueFamilyIndices", (getter)PyVkSwapchainCreateInfoKHR_getpQueueFamilyIndices, (setter)PyVkSwapchainCreateInfoKHR_setpQueueFamilyIndices, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkSwapchainCreateInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkSwapchainCreateInfoKHR", sizeof(PyVkSwapchainCreateInfoKHR), 0,
                    (destructor)PyVkSwapchainCreateInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkSwapchainCreateInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkSwapchainCreateInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkSwapchainCreateInfoKHR_new,};
            
                typedef struct { PyObject_HEAD VkPresentInfoKHR *base; }
                PyVkPresentInfoKHR;
                
                static void PyVkPresentInfoKHR_del(PyVkPresentInfoKHR* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPresentInfoKHR_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPresentInfoKHR *self;
                    self = (PyVkPresentInfoKHR *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPresentInfoKHR));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPresentInfoKHR");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPresentInfoKHR_setpNext(PyVkPresentInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPresentInfoKHR_getpNext(PyVkPresentInfoKHR *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPresentInfoKHR_setwaitSemaphoreCount(PyVkPresentInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with waitSemaphoreCount");
                        return -1;
                    }
                (self->base)->waitSemaphoreCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPresentInfoKHR_getwaitSemaphoreCount(PyVkPresentInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->waitSemaphoreCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPresentInfoKHR_setswapchainCount(PyVkPresentInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with swapchainCount");
                        return -1;
                    }
                (self->base)->swapchainCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkPresentInfoKHR_getswapchainCount(PyVkPresentInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->swapchainCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkPresentInfoKHR_setpImageIndices(PyVkPresentInfoKHR *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pImageIndices");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pImageIndices = t;
            
                    return 0;
                }
                
                static PyObject * PyVkPresentInfoKHR_getpImageIndices(PyVkPresentInfoKHR *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pImageIndices)));
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPresentInfoKHR_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPresentInfoKHR_getpNext, (setter)PyVkPresentInfoKHR_setpNext, "", NULL},
                    
                        { "waitSemaphoreCount", (getter)PyVkPresentInfoKHR_getwaitSemaphoreCount, (setter)PyVkPresentInfoKHR_setwaitSemaphoreCount, "", NULL},
                    
                        { "swapchainCount", (getter)PyVkPresentInfoKHR_getswapchainCount, (setter)PyVkPresentInfoKHR_setswapchainCount, "", NULL},
                    
                        { "pImageIndices", (getter)PyVkPresentInfoKHR_getpImageIndices, (setter)PyVkPresentInfoKHR_setpImageIndices, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPresentInfoKHRType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPresentInfoKHR", sizeof(PyVkPresentInfoKHR), 0,
                    (destructor)PyVkPresentInfoKHR_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPresentInfoKHR object",0,0,0,0,0,0,0,0,
                    PyVkPresentInfoKHR_getsetters,0,0,0,0,0,0,0,PyVkPresentInfoKHR_new,};
            
                typedef struct { PyObject_HEAD VkDebugReportCallbackCreateInfoEXT *base; }
                PyVkDebugReportCallbackCreateInfoEXT;
                
                static void PyVkDebugReportCallbackCreateInfoEXT_del(PyVkDebugReportCallbackCreateInfoEXT* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDebugReportCallbackCreateInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDebugReportCallbackCreateInfoEXT *self;
                    self = (PyVkDebugReportCallbackCreateInfoEXT *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDebugReportCallbackCreateInfoEXT));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDebugReportCallbackCreateInfoEXT");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDebugReportCallbackCreateInfoEXT_setpNext(PyVkDebugReportCallbackCreateInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpNext(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugReportCallbackCreateInfoEXT_setpUserData(PyVkDebugReportCallbackCreateInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pUserData");
                        return -1;
                    }
                (self->base)->pUserData = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugReportCallbackCreateInfoEXT_getpUserData(PyVkDebugReportCallbackCreateInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDebugReportCallbackCreateInfoEXT_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpNext, (setter)PyVkDebugReportCallbackCreateInfoEXT_setpNext, "", NULL},
                    
                        { "pUserData", (getter)PyVkDebugReportCallbackCreateInfoEXT_getpUserData, (setter)PyVkDebugReportCallbackCreateInfoEXT_setpUserData, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDebugReportCallbackCreateInfoEXTType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDebugReportCallbackCreateInfoEXT", sizeof(PyVkDebugReportCallbackCreateInfoEXT), 0,
                    (destructor)PyVkDebugReportCallbackCreateInfoEXT_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDebugReportCallbackCreateInfoEXT object",0,0,0,0,0,0,0,0,
                    PyVkDebugReportCallbackCreateInfoEXT_getsetters,0,0,0,0,0,0,0,PyVkDebugReportCallbackCreateInfoEXT_new,};
            
                typedef struct { PyObject_HEAD VkDebugReportLayerFlagsEXT *base; }
                PyVkDebugReportLayerFlagsEXT;
                
                static void PyVkDebugReportLayerFlagsEXT_del(PyVkDebugReportLayerFlagsEXT* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDebugReportLayerFlagsEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDebugReportLayerFlagsEXT *self;
                    self = (PyVkDebugReportLayerFlagsEXT *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDebugReportLayerFlagsEXT));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDebugReportLayerFlagsEXT");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDebugReportLayerFlagsEXT_setpNext(PyVkDebugReportLayerFlagsEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugReportLayerFlagsEXT_getpNext(PyVkDebugReportLayerFlagsEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugReportLayerFlagsEXT_setenabledValidationFlags(PyVkDebugReportLayerFlagsEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with enabledValidationFlags");
                        return -1;
                    }
                (self->base)->enabledValidationFlags = (uint64_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDebugReportLayerFlagsEXT_getenabledValidationFlags(PyVkDebugReportLayerFlagsEXT *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->enabledValidationFlags);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDebugReportLayerFlagsEXT_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDebugReportLayerFlagsEXT_getpNext, (setter)PyVkDebugReportLayerFlagsEXT_setpNext, "", NULL},
                    
                        { "enabledValidationFlags", (getter)PyVkDebugReportLayerFlagsEXT_getenabledValidationFlags, (setter)PyVkDebugReportLayerFlagsEXT_setenabledValidationFlags, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDebugReportLayerFlagsEXTType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDebugReportLayerFlagsEXT", sizeof(PyVkDebugReportLayerFlagsEXT), 0,
                    (destructor)PyVkDebugReportLayerFlagsEXT_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDebugReportLayerFlagsEXT object",0,0,0,0,0,0,0,0,
                    PyVkDebugReportLayerFlagsEXT_getsetters,0,0,0,0,0,0,0,PyVkDebugReportLayerFlagsEXT_new,};
            
                typedef struct { PyObject_HEAD VkPipelineRasterizationStateRasterizationOrderAMD *base; }
                PyVkPipelineRasterizationStateRasterizationOrderAMD;
                
                static void PyVkPipelineRasterizationStateRasterizationOrderAMD_del(PyVkPipelineRasterizationStateRasterizationOrderAMD* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkPipelineRasterizationStateRasterizationOrderAMD_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkPipelineRasterizationStateRasterizationOrderAMD *self;
                    self = (PyVkPipelineRasterizationStateRasterizationOrderAMD *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkPipelineRasterizationStateRasterizationOrderAMD");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkPipelineRasterizationStateRasterizationOrderAMD_setpNext(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext(PyVkPipelineRasterizationStateRasterizationOrderAMD *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters[] = {
                    
                        { "pNext", (getter)PyVkPipelineRasterizationStateRasterizationOrderAMD_getpNext, (setter)PyVkPipelineRasterizationStateRasterizationOrderAMD_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkPipelineRasterizationStateRasterizationOrderAMDType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkPipelineRasterizationStateRasterizationOrderAMD", sizeof(PyVkPipelineRasterizationStateRasterizationOrderAMD), 0,
                    (destructor)PyVkPipelineRasterizationStateRasterizationOrderAMD_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkPipelineRasterizationStateRasterizationOrderAMD object",0,0,0,0,0,0,0,0,
                    PyVkPipelineRasterizationStateRasterizationOrderAMD_getsetters,0,0,0,0,0,0,0,PyVkPipelineRasterizationStateRasterizationOrderAMD_new,};
            
                typedef struct { PyObject_HEAD VkDebugMarkerObjectNameInfoEXT *base; }
                PyVkDebugMarkerObjectNameInfoEXT;
                
                static void PyVkDebugMarkerObjectNameInfoEXT_del(PyVkDebugMarkerObjectNameInfoEXT* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDebugMarkerObjectNameInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDebugMarkerObjectNameInfoEXT *self;
                    self = (PyVkDebugMarkerObjectNameInfoEXT *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDebugMarkerObjectNameInfoEXT));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDebugMarkerObjectNameInfoEXT");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDebugMarkerObjectNameInfoEXT_setpNext(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpNext(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectNameInfoEXT_setobject(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with object");
                        return -1;
                    }
                (self->base)->object = (uint64_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getobject(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->object);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectNameInfoEXT_setpObjectName(PyVkDebugMarkerObjectNameInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pObjectName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->pObjectName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectNameInfoEXT_getpObjectName(PyVkDebugMarkerObjectNameInfoEXT *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->pObjectName);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDebugMarkerObjectNameInfoEXT_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpNext, (setter)PyVkDebugMarkerObjectNameInfoEXT_setpNext, "", NULL},
                    
                        { "object", (getter)PyVkDebugMarkerObjectNameInfoEXT_getobject, (setter)PyVkDebugMarkerObjectNameInfoEXT_setobject, "", NULL},
                    
                        { "pObjectName", (getter)PyVkDebugMarkerObjectNameInfoEXT_getpObjectName, (setter)PyVkDebugMarkerObjectNameInfoEXT_setpObjectName, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDebugMarkerObjectNameInfoEXTType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDebugMarkerObjectNameInfoEXT", sizeof(PyVkDebugMarkerObjectNameInfoEXT), 0,
                    (destructor)PyVkDebugMarkerObjectNameInfoEXT_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDebugMarkerObjectNameInfoEXT object",0,0,0,0,0,0,0,0,
                    PyVkDebugMarkerObjectNameInfoEXT_getsetters,0,0,0,0,0,0,0,PyVkDebugMarkerObjectNameInfoEXT_new,};
            
                typedef struct { PyObject_HEAD VkDebugMarkerObjectTagInfoEXT *base; }
                PyVkDebugMarkerObjectTagInfoEXT;
                
                static void PyVkDebugMarkerObjectTagInfoEXT_del(PyVkDebugMarkerObjectTagInfoEXT* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDebugMarkerObjectTagInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDebugMarkerObjectTagInfoEXT *self;
                    self = (PyVkDebugMarkerObjectTagInfoEXT *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDebugMarkerObjectTagInfoEXT));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDebugMarkerObjectTagInfoEXT");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDebugMarkerObjectTagInfoEXT_setpNext(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpNext(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectTagInfoEXT_setobject(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with object");
                        return -1;
                    }
                (self->base)->object = (uint64_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getobject(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->object);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectTagInfoEXT_settagName(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with tagName");
                        return -1;
                    }
                (self->base)->tagName = (uint64_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagName(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->tagName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectTagInfoEXT_settagSize(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with tagSize");
                        return -1;
                    }
                (self->base)->tagSize = (size_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectTagInfoEXT_gettagSize(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->tagSize);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerObjectTagInfoEXT_setpTag(PyVkDebugMarkerObjectTagInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pTag");
                        return -1;
                    }
                (self->base)->pTag = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerObjectTagInfoEXT_getpTag(PyVkDebugMarkerObjectTagInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDebugMarkerObjectTagInfoEXT_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpNext, (setter)PyVkDebugMarkerObjectTagInfoEXT_setpNext, "", NULL},
                    
                        { "object", (getter)PyVkDebugMarkerObjectTagInfoEXT_getobject, (setter)PyVkDebugMarkerObjectTagInfoEXT_setobject, "", NULL},
                    
                        { "tagName", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagName, (setter)PyVkDebugMarkerObjectTagInfoEXT_settagName, "", NULL},
                    
                        { "tagSize", (getter)PyVkDebugMarkerObjectTagInfoEXT_gettagSize, (setter)PyVkDebugMarkerObjectTagInfoEXT_settagSize, "", NULL},
                    
                        { "pTag", (getter)PyVkDebugMarkerObjectTagInfoEXT_getpTag, (setter)PyVkDebugMarkerObjectTagInfoEXT_setpTag, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDebugMarkerObjectTagInfoEXTType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDebugMarkerObjectTagInfoEXT", sizeof(PyVkDebugMarkerObjectTagInfoEXT), 0,
                    (destructor)PyVkDebugMarkerObjectTagInfoEXT_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDebugMarkerObjectTagInfoEXT object",0,0,0,0,0,0,0,0,
                    PyVkDebugMarkerObjectTagInfoEXT_getsetters,0,0,0,0,0,0,0,PyVkDebugMarkerObjectTagInfoEXT_new,};
            
                typedef struct { PyObject_HEAD VkDebugMarkerMarkerInfoEXT *base; }
                PyVkDebugMarkerMarkerInfoEXT;
                
                static void PyVkDebugMarkerMarkerInfoEXT_del(PyVkDebugMarkerMarkerInfoEXT* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDebugMarkerMarkerInfoEXT_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDebugMarkerMarkerInfoEXT *self;
                    self = (PyVkDebugMarkerMarkerInfoEXT *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDebugMarkerMarkerInfoEXT));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDebugMarkerMarkerInfoEXT");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDebugMarkerMarkerInfoEXT_setpNext(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpNext(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerMarkerInfoEXT_setpMarkerName(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pMarkerName");
                        return -1;
                    }
                
            PyObject * ascii_str = PyUnicode_AsASCIIString(value);
            char* tmp = PyBytes_AsString(ascii_str);
            (self->base)->pMarkerName = strdup(tmp);
            Py_DECREF(ascii_str);
            
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerMarkerInfoEXT_getpMarkerName(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
                PyObject* value = PyUnicode_FromString((const char *) (self->base)->pMarkerName);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkDebugMarkerMarkerInfoEXT_setcolor(PyVkDebugMarkerMarkerInfoEXT *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with color");
                        return -1;
                    }
                
            int nb = PyList_Size(value);
            int i;
            for (i = 0; i < nb; i++) {
                float tmp = (float) PyFloat_AsDouble(PyList_GetItem(value, i));
                ((self->base)->color)[i] = tmp;
            }
            
                    return 0;
                }
                
                static PyObject * PyVkDebugMarkerMarkerInfoEXT_getcolor(PyVkDebugMarkerMarkerInfoEXT *self, void *closure){
                
            PyObject* value = PyList_New(0);
            int nb = sizeof((self->base)->color) / sizeof((self->base)->color[0]);
            int i = 0;
            for (i = 0; i < nb; i++) {
                PyObject* py_tmp = PyFloat_FromDouble((double) (self->base)->color[i]);
                PyList_Append(value, py_tmp);
            }
            
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDebugMarkerMarkerInfoEXT_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDebugMarkerMarkerInfoEXT_getpNext, (setter)PyVkDebugMarkerMarkerInfoEXT_setpNext, "", NULL},
                    
                        { "pMarkerName", (getter)PyVkDebugMarkerMarkerInfoEXT_getpMarkerName, (setter)PyVkDebugMarkerMarkerInfoEXT_setpMarkerName, "", NULL},
                    
                        { "color", (getter)PyVkDebugMarkerMarkerInfoEXT_getcolor, (setter)PyVkDebugMarkerMarkerInfoEXT_setcolor, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDebugMarkerMarkerInfoEXTType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDebugMarkerMarkerInfoEXT", sizeof(PyVkDebugMarkerMarkerInfoEXT), 0,
                    (destructor)PyVkDebugMarkerMarkerInfoEXT_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDebugMarkerMarkerInfoEXT object",0,0,0,0,0,0,0,0,
                    PyVkDebugMarkerMarkerInfoEXT_getsetters,0,0,0,0,0,0,0,PyVkDebugMarkerMarkerInfoEXT_new,};
            
                typedef struct { PyObject_HEAD VkDedicatedAllocationImageCreateInfoNV *base; }
                PyVkDedicatedAllocationImageCreateInfoNV;
                
                static void PyVkDedicatedAllocationImageCreateInfoNV_del(PyVkDedicatedAllocationImageCreateInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDedicatedAllocationImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDedicatedAllocationImageCreateInfoNV *self;
                    self = (PyVkDedicatedAllocationImageCreateInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDedicatedAllocationImageCreateInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDedicatedAllocationImageCreateInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDedicatedAllocationImageCreateInfoNV_setpNext(PyVkDedicatedAllocationImageCreateInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDedicatedAllocationImageCreateInfoNV_getpNext(PyVkDedicatedAllocationImageCreateInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDedicatedAllocationImageCreateInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDedicatedAllocationImageCreateInfoNV_getpNext, (setter)PyVkDedicatedAllocationImageCreateInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDedicatedAllocationImageCreateInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDedicatedAllocationImageCreateInfoNV", sizeof(PyVkDedicatedAllocationImageCreateInfoNV), 0,
                    (destructor)PyVkDedicatedAllocationImageCreateInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDedicatedAllocationImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkDedicatedAllocationImageCreateInfoNV_getsetters,0,0,0,0,0,0,0,PyVkDedicatedAllocationImageCreateInfoNV_new,};
            
                typedef struct { PyObject_HEAD VkDedicatedAllocationBufferCreateInfoNV *base; }
                PyVkDedicatedAllocationBufferCreateInfoNV;
                
                static void PyVkDedicatedAllocationBufferCreateInfoNV_del(PyVkDedicatedAllocationBufferCreateInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDedicatedAllocationBufferCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDedicatedAllocationBufferCreateInfoNV *self;
                    self = (PyVkDedicatedAllocationBufferCreateInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDedicatedAllocationBufferCreateInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDedicatedAllocationBufferCreateInfoNV_setpNext(PyVkDedicatedAllocationBufferCreateInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDedicatedAllocationBufferCreateInfoNV_getpNext(PyVkDedicatedAllocationBufferCreateInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDedicatedAllocationBufferCreateInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDedicatedAllocationBufferCreateInfoNV_getpNext, (setter)PyVkDedicatedAllocationBufferCreateInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDedicatedAllocationBufferCreateInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDedicatedAllocationBufferCreateInfoNV", sizeof(PyVkDedicatedAllocationBufferCreateInfoNV), 0,
                    (destructor)PyVkDedicatedAllocationBufferCreateInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDedicatedAllocationBufferCreateInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkDedicatedAllocationBufferCreateInfoNV_getsetters,0,0,0,0,0,0,0,PyVkDedicatedAllocationBufferCreateInfoNV_new,};
            
                typedef struct { PyObject_HEAD VkDedicatedAllocationMemoryAllocateInfoNV *base; }
                PyVkDedicatedAllocationMemoryAllocateInfoNV;
                
                static void PyVkDedicatedAllocationMemoryAllocateInfoNV_del(PyVkDedicatedAllocationMemoryAllocateInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkDedicatedAllocationMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkDedicatedAllocationMemoryAllocateInfoNV *self;
                    self = (PyVkDedicatedAllocationMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkDedicatedAllocationMemoryAllocateInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkDedicatedAllocationMemoryAllocateInfoNV_setpNext(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext(PyVkDedicatedAllocationMemoryAllocateInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkDedicatedAllocationMemoryAllocateInfoNV_getpNext, (setter)PyVkDedicatedAllocationMemoryAllocateInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkDedicatedAllocationMemoryAllocateInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkDedicatedAllocationMemoryAllocateInfoNV", sizeof(PyVkDedicatedAllocationMemoryAllocateInfoNV), 0,
                    (destructor)PyVkDedicatedAllocationMemoryAllocateInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkDedicatedAllocationMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkDedicatedAllocationMemoryAllocateInfoNV_getsetters,0,0,0,0,0,0,0,PyVkDedicatedAllocationMemoryAllocateInfoNV_new,};
            
                typedef struct { PyObject_HEAD VkExternalImageFormatPropertiesNV *base; }
                PyVkExternalImageFormatPropertiesNV;
                
                static void PyVkExternalImageFormatPropertiesNV_del(PyVkExternalImageFormatPropertiesNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExternalImageFormatPropertiesNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExternalImageFormatPropertiesNV *self;
                    self = (PyVkExternalImageFormatPropertiesNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExternalImageFormatPropertiesNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExternalImageFormatPropertiesNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                    static PyGetSetDef PyVkExternalImageFormatPropertiesNV_getsetters[] = {
                    {NULL}};

                static PyTypeObject PyVkExternalImageFormatPropertiesNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExternalImageFormatPropertiesNV", sizeof(PyVkExternalImageFormatPropertiesNV), 0,
                    (destructor)PyVkExternalImageFormatPropertiesNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExternalImageFormatPropertiesNV object",0,0,0,0,0,0,0,0,
                    PyVkExternalImageFormatPropertiesNV_getsetters,0,0,0,0,0,0,0,PyVkExternalImageFormatPropertiesNV_new,};
            
                typedef struct { PyObject_HEAD VkExternalMemoryImageCreateInfoNV *base; }
                PyVkExternalMemoryImageCreateInfoNV;
                
                static void PyVkExternalMemoryImageCreateInfoNV_del(PyVkExternalMemoryImageCreateInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExternalMemoryImageCreateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExternalMemoryImageCreateInfoNV *self;
                    self = (PyVkExternalMemoryImageCreateInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExternalMemoryImageCreateInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExternalMemoryImageCreateInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExternalMemoryImageCreateInfoNV_setpNext(PyVkExternalMemoryImageCreateInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkExternalMemoryImageCreateInfoNV_getpNext(PyVkExternalMemoryImageCreateInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExternalMemoryImageCreateInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkExternalMemoryImageCreateInfoNV_getpNext, (setter)PyVkExternalMemoryImageCreateInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExternalMemoryImageCreateInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExternalMemoryImageCreateInfoNV", sizeof(PyVkExternalMemoryImageCreateInfoNV), 0,
                    (destructor)PyVkExternalMemoryImageCreateInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExternalMemoryImageCreateInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkExternalMemoryImageCreateInfoNV_getsetters,0,0,0,0,0,0,0,PyVkExternalMemoryImageCreateInfoNV_new,};
            
                typedef struct { PyObject_HEAD VkExportMemoryAllocateInfoNV *base; }
                PyVkExportMemoryAllocateInfoNV;
                
                static void PyVkExportMemoryAllocateInfoNV_del(PyVkExportMemoryAllocateInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExportMemoryAllocateInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExportMemoryAllocateInfoNV *self;
                    self = (PyVkExportMemoryAllocateInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExportMemoryAllocateInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExportMemoryAllocateInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExportMemoryAllocateInfoNV_setpNext(PyVkExportMemoryAllocateInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkExportMemoryAllocateInfoNV_getpNext(PyVkExportMemoryAllocateInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExportMemoryAllocateInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkExportMemoryAllocateInfoNV_getpNext, (setter)PyVkExportMemoryAllocateInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExportMemoryAllocateInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExportMemoryAllocateInfoNV", sizeof(PyVkExportMemoryAllocateInfoNV), 0,
                    (destructor)PyVkExportMemoryAllocateInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExportMemoryAllocateInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkExportMemoryAllocateInfoNV_getsetters,0,0,0,0,0,0,0,PyVkExportMemoryAllocateInfoNV_new,};
            
#ifdef VK_USE_PLATFORM_WIN32_KHR

                typedef struct { PyObject_HEAD VkImportMemoryWin32HandleInfoNV *base; }
                PyVkImportMemoryWin32HandleInfoNV;
                
                static void PyVkImportMemoryWin32HandleInfoNV_del(PyVkImportMemoryWin32HandleInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkImportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkImportMemoryWin32HandleInfoNV *self;
                    self = (PyVkImportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkImportMemoryWin32HandleInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkImportMemoryWin32HandleInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkImportMemoryWin32HandleInfoNV_setpNext(PyVkImportMemoryWin32HandleInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkImportMemoryWin32HandleInfoNV_getpNext(PyVkImportMemoryWin32HandleInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkImportMemoryWin32HandleInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkImportMemoryWin32HandleInfoNV_getpNext, (setter)PyVkImportMemoryWin32HandleInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkImportMemoryWin32HandleInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkImportMemoryWin32HandleInfoNV", sizeof(PyVkImportMemoryWin32HandleInfoNV), 0,
                    (destructor)PyVkImportMemoryWin32HandleInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkImportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkImportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,0,0,PyVkImportMemoryWin32HandleInfoNV_new,};
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                typedef struct { PyObject_HEAD VkExportMemoryWin32HandleInfoNV *base; }
                PyVkExportMemoryWin32HandleInfoNV;
                
                static void PyVkExportMemoryWin32HandleInfoNV_del(PyVkExportMemoryWin32HandleInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkExportMemoryWin32HandleInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkExportMemoryWin32HandleInfoNV *self;
                    self = (PyVkExportMemoryWin32HandleInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkExportMemoryWin32HandleInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkExportMemoryWin32HandleInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkExportMemoryWin32HandleInfoNV_setpNext(PyVkExportMemoryWin32HandleInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkExportMemoryWin32HandleInfoNV_getpNext(PyVkExportMemoryWin32HandleInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkExportMemoryWin32HandleInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkExportMemoryWin32HandleInfoNV_getpNext, (setter)PyVkExportMemoryWin32HandleInfoNV_setpNext, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkExportMemoryWin32HandleInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkExportMemoryWin32HandleInfoNV", sizeof(PyVkExportMemoryWin32HandleInfoNV), 0,
                    (destructor)PyVkExportMemoryWin32HandleInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkExportMemoryWin32HandleInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkExportMemoryWin32HandleInfoNV_getsetters,0,0,0,0,0,0,0,PyVkExportMemoryWin32HandleInfoNV_new,};
            
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                typedef struct { PyObject_HEAD VkWin32KeyedMutexAcquireReleaseInfoNV *base; }
                PyVkWin32KeyedMutexAcquireReleaseInfoNV;
                
                static void PyVkWin32KeyedMutexAcquireReleaseInfoNV_del(PyVkWin32KeyedMutexAcquireReleaseInfoNV* self) {
                    Py_TYPE(self)->tp_free((PyObject*)self); }
                
                static PyObject *
                PyVkWin32KeyedMutexAcquireReleaseInfoNV_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
                {
                    PyVkWin32KeyedMutexAcquireReleaseInfoNV *self;
                    self = (PyVkWin32KeyedMutexAcquireReleaseInfoNV *)type->tp_alloc(type, 0);
                    if (self != NULL) {
                        self->base = malloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV));
                        if (self->base == NULL) {
                            PyErr_SetString(PyExc_MemoryError,
                                "Cannot allocate memory for VkWin32KeyedMutexAcquireReleaseInfoNV");
                            return NULL;
                        }
                    }

                    return (PyObject *)self;
                }
                
                static int PyVkWin32KeyedMutexAcquireReleaseInfoNV_setpNext(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pNext");
                        return -1;
                    }
                (self->base)->pNext = NULL;
                    return 0;
                }
                
                static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
                Py_INCREF(Py_None);PyObject* value = Py_None;
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWin32KeyedMutexAcquireReleaseInfoNV_setacquireCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with acquireCount");
                        return -1;
                    }
                (self->base)->acquireCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->acquireCount);
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWin32KeyedMutexAcquireReleaseInfoNV_setpAcquireTimeoutMilliseconds(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with pAcquireTimeoutMilliseconds");
                        return -1;
                    }
                
            uint32_t tmp = (uint32_t) PyLong_AsLong(value);
            uint32_t *t = malloc(sizeof(uint32_t));
            memcpy(t, &tmp, sizeof(uint32_t));
            (self->base)->pAcquireTimeoutMilliseconds = t;
            
                    return 0;
                }
                
                static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (*((self->base)->pAcquireTimeoutMilliseconds)));
                    Py_INCREF(value);
                    return value;
                }
                
                static int PyVkWin32KeyedMutexAcquireReleaseInfoNV_setreleaseCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, PyObject *value,
                                        void *closure) {
                    if (value == NULL) {
                        PyErr_SetString(PyExc_TypeError, "Error with releaseCount");
                        return -1;
                    }
                (self->base)->releaseCount = (uint32_t) PyLong_AsLong(value);
                    return 0;
                }
                
                static PyObject * PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount(PyVkWin32KeyedMutexAcquireReleaseInfoNV *self, void *closure){
                PyObject* value = PyLong_FromLong((long) (self->base)->releaseCount);
                    Py_INCREF(value);
                    return value;
                }
                
                    static PyGetSetDef PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters[] = {
                    
                        { "pNext", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpNext, (setter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_setpNext, "", NULL},
                    
                        { "acquireCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getacquireCount, (setter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_setacquireCount, "", NULL},
                    
                        { "pAcquireTimeoutMilliseconds", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getpAcquireTimeoutMilliseconds, (setter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_setpAcquireTimeoutMilliseconds, "", NULL},
                    
                        { "releaseCount", (getter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_getreleaseCount, (setter)PyVkWin32KeyedMutexAcquireReleaseInfoNV_setreleaseCount, "", NULL},
                    {NULL}};

                static PyTypeObject PyVkWin32KeyedMutexAcquireReleaseInfoNVType = {
                    PyVarObject_HEAD_INIT(NULL, 0)
                    "vulkan.VkWin32KeyedMutexAcquireReleaseInfoNV", sizeof(PyVkWin32KeyedMutexAcquireReleaseInfoNV), 0,
                    (destructor)PyVkWin32KeyedMutexAcquireReleaseInfoNV_del,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,Py_TPFLAGS_DEFAULT,
                    "VkWin32KeyedMutexAcquireReleaseInfoNV object",0,0,0,0,0,0,0,0,
                    PyVkWin32KeyedMutexAcquireReleaseInfoNV_getsetters,0,0,0,0,0,0,0,PyVkWin32KeyedMutexAcquireReleaseInfoNV_new,};
            
#endif

static PyMethodDef VulkanMethods[] = {
{"load_sdk", load_sdk, METH_NOARGS, "Load SDK"},

{NULL, NULL, 0, NULL} };

            static struct PyModuleDef vulkanmodule = {
                PyModuleDef_HEAD_INIT, "vulkan", "Vulkan module", -1, VulkanMethods};
            

PyMODINIT_FUNC PyInit_vulkan(void) {

            PyObject* module;
            module = PyModule_Create(&vulkanmodule);
            if (module == NULL) return NULL;
        

PyModule_AddIntConstant(module, "VK_MAX_PHYSICAL_DEVICE_NAME_SIZE", 256);
PyModule_AddIntConstant(module, "VK_UUID_SIZE", 16);
PyModule_AddIntConstant(module, "VK_MAX_EXTENSION_NAME_SIZE", 256);
PyModule_AddIntConstant(module, "VK_MAX_DESCRIPTION_SIZE", 256);
PyModule_AddIntConstant(module, "VK_MAX_MEMORY_TYPES", 32);
PyModule_AddIntConstant(module, "VK_MAX_MEMORY_HEAPS", 16);
PyModule_AddIntConstant(module, "VK_LOD_CLAMP_NONE", 1000.0f);
PyModule_AddIntConstant(module, "VK_REMAINING_MIP_LEVELS", (~0U));
PyModule_AddIntConstant(module, "VK_REMAINING_ARRAY_LAYERS", (~0U));
PyModule_AddIntConstant(module, "VK_WHOLE_SIZE", (~0ULL));
PyModule_AddIntConstant(module, "VK_ATTACHMENT_UNUSED", (~0U));
PyModule_AddIntConstant(module, "VK_TRUE", 1);
PyModule_AddIntConstant(module, "VK_FALSE", 0);
PyModule_AddIntConstant(module, "VK_QUEUE_FAMILY_IGNORED", (~0U));
PyModule_AddIntConstant(module, "VK_SUBPASS_EXTERNAL", (~0U));
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_UNDEFINED", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_GENERAL", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 3);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", 4);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", 5);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL", 6);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL", 7);
PyModule_AddIntConstant(module, "VK_IMAGE_LAYOUT_PREINITIALIZED", 8);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_LOAD", 0);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_CLEAR", 1);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_LOAD_OP_DONT_CARE", 2);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_STORE", 0);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_STORE_OP_DONT_CARE", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_1D", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_2D", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_TYPE_3D", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_TILING_OPTIMAL", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_TILING_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D", 0);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D", 1);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_3D", 2);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE", 3);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_1D_ARRAY", 4);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_2D_ARRAY", 5);
PyModule_AddIntConstant(module, "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", 6);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_PRIMARY", 0);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_LEVEL_SECONDARY", 1);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_IDENTITY", 0);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ZERO", 1);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_ONE", 2);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_R", 3);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_G", 4);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_B", 5);
PyModule_AddIntConstant(module, "VK_COMPONENT_SWIZZLE_A", 6);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLER", 0);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", 1);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE", 2);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE", 3);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER", 4);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER", 5);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER", 6);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER", 7);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", 8);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", 9);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT", 10);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_OCCLUSION", 0);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_PIPELINE_STATISTICS", 1);
PyModule_AddIntConstant(module, "VK_QUERY_TYPE_TIMESTAMP", 2);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK", 0);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK", 1);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK", 2);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_BLACK", 3);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE", 4);
PyModule_AddIntConstant(module, "VK_BORDER_COLOR_INT_OPAQUE_WHITE", 5);
PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_GRAPHICS", 0);
PyModule_AddIntConstant(module, "VK_PIPELINE_BIND_POINT_COMPUTE", 1);
PyModule_AddIntConstant(module, "VK_PIPELINE_CACHE_HEADER_VERSION_ONE", 1);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_POINT_LIST", 0);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST", 1);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP", 2);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST", 3);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP", 4);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", 5);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY", 6);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY", 7);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY", 8);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY", 9);
PyModule_AddIntConstant(module, "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", 10);
PyModule_AddIntConstant(module, "VK_SHARING_MODE_EXCLUSIVE", 0);
PyModule_AddIntConstant(module, "VK_SHARING_MODE_CONCURRENT", 1);
PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT16", 0);
PyModule_AddIntConstant(module, "VK_INDEX_TYPE_UINT32", 1);
PyModule_AddIntConstant(module, "VK_FILTER_NEAREST", 0);
PyModule_AddIntConstant(module, "VK_FILTER_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_NEAREST", 0);
PyModule_AddIntConstant(module, "VK_SAMPLER_MIPMAP_MODE_LINEAR", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_REPEAT", 0);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT", 1);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", 2);
PyModule_AddIntConstant(module, "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", 3);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_NEVER", 0);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS", 1);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_EQUAL", 2);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_LESS_OR_EQUAL", 3);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER", 4);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_NOT_EQUAL", 5);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_GREATER_OR_EQUAL", 6);
PyModule_AddIntConstant(module, "VK_COMPARE_OP_ALWAYS", 7);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_FILL", 0);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_LINE", 1);
PyModule_AddIntConstant(module, "VK_POLYGON_MODE_POINT", 2);
PyModule_AddIntConstant(module, "VK_CULL_MODE_NONE", 0);
PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_CULL_MODE_BACK_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_CULL_MODE_FRONT_AND_BACK", 0x00000003);
PyModule_AddIntConstant(module, "VK_FRONT_FACE_COUNTER_CLOCKWISE", 0);
PyModule_AddIntConstant(module, "VK_FRONT_FACE_CLOCKWISE", 1);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ZERO", 0);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE", 1);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_COLOR", 2);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR", 3);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_COLOR", 4);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR", 5);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA", 6);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA", 7);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_DST_ALPHA", 8);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA", 9);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_COLOR", 10);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR", 11);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_CONSTANT_ALPHA", 12);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", 13);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE", 14);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_COLOR", 15);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR", 16);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_SRC1_ALPHA", 17);
PyModule_AddIntConstant(module, "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", 18);
PyModule_AddIntConstant(module, "VK_BLEND_OP_ADD", 0);
PyModule_AddIntConstant(module, "VK_BLEND_OP_SUBTRACT", 1);
PyModule_AddIntConstant(module, "VK_BLEND_OP_REVERSE_SUBTRACT", 2);
PyModule_AddIntConstant(module, "VK_BLEND_OP_MIN", 3);
PyModule_AddIntConstant(module, "VK_BLEND_OP_MAX", 4);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_KEEP", 0);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_ZERO", 1);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_REPLACE", 2);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_CLAMP", 3);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_CLAMP", 4);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INVERT", 5);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_INCREMENT_AND_WRAP", 6);
PyModule_AddIntConstant(module, "VK_STENCIL_OP_DECREMENT_AND_WRAP", 7);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_CLEAR", 0);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND", 1);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_REVERSE", 2);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY", 3);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_AND_INVERTED", 4);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NO_OP", 5);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_XOR", 6);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR", 7);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NOR", 8);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_EQUIVALENT", 9);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_INVERT", 10);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_REVERSE", 11);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_COPY_INVERTED", 12);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_OR_INVERTED", 13);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_NAND", 14);
PyModule_AddIntConstant(module, "VK_LOGIC_OP_SET", 15);
PyModule_AddIntConstant(module, "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE", 0);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND", 0);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT", 1);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_CACHE", 2);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE", 3);
PyModule_AddIntConstant(module, "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE", 4);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_OTHER", 0);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU", 1);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU", 2);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU", 3);
PyModule_AddIntConstant(module, "VK_PHYSICAL_DEVICE_TYPE_CPU", 4);
PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_VERTEX", 0);
PyModule_AddIntConstant(module, "VK_VERTEX_INPUT_RATE_INSTANCE", 1);
PyModule_AddIntConstant(module, "VK_FORMAT_UNDEFINED", 0);
PyModule_AddIntConstant(module, "VK_FORMAT_R4G4_UNORM_PACK8", 1);
PyModule_AddIntConstant(module, "VK_FORMAT_R4G4B4A4_UNORM_PACK16", 2);
PyModule_AddIntConstant(module, "VK_FORMAT_B4G4R4A4_UNORM_PACK16", 3);
PyModule_AddIntConstant(module, "VK_FORMAT_R5G6B5_UNORM_PACK16", 4);
PyModule_AddIntConstant(module, "VK_FORMAT_B5G6R5_UNORM_PACK16", 5);
PyModule_AddIntConstant(module, "VK_FORMAT_R5G5B5A1_UNORM_PACK16", 6);
PyModule_AddIntConstant(module, "VK_FORMAT_B5G5R5A1_UNORM_PACK16", 7);
PyModule_AddIntConstant(module, "VK_FORMAT_A1R5G5B5_UNORM_PACK16", 8);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_UNORM", 9);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SNORM", 10);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_USCALED", 11);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SSCALED", 12);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_UINT", 13);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SINT", 14);
PyModule_AddIntConstant(module, "VK_FORMAT_R8_SRGB", 15);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UNORM", 16);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SNORM", 17);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_USCALED", 18);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SSCALED", 19);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_UINT", 20);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SINT", 21);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8_SRGB", 22);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UNORM", 23);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SNORM", 24);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_USCALED", 25);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SSCALED", 26);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_UINT", 27);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SINT", 28);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8_SRGB", 29);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UNORM", 30);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SNORM", 31);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_USCALED", 32);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SSCALED", 33);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_UINT", 34);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SINT", 35);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8_SRGB", 36);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UNORM", 37);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SNORM", 38);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_USCALED", 39);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SSCALED", 40);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_UINT", 41);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SINT", 42);
PyModule_AddIntConstant(module, "VK_FORMAT_R8G8B8A8_SRGB", 43);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UNORM", 44);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SNORM", 45);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_USCALED", 46);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SSCALED", 47);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_UINT", 48);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SINT", 49);
PyModule_AddIntConstant(module, "VK_FORMAT_B8G8R8A8_SRGB", 50);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UNORM_PACK32", 51);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SNORM_PACK32", 52);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_USCALED_PACK32", 53);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32", 54);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_UINT_PACK32", 55);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SINT_PACK32", 56);
PyModule_AddIntConstant(module, "VK_FORMAT_A8B8G8R8_SRGB_PACK32", 57);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UNORM_PACK32", 58);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SNORM_PACK32", 59);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_USCALED_PACK32", 60);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32", 61);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_UINT_PACK32", 62);
PyModule_AddIntConstant(module, "VK_FORMAT_A2R10G10B10_SINT_PACK32", 63);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UNORM_PACK32", 64);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SNORM_PACK32", 65);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_USCALED_PACK32", 66);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32", 67);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_UINT_PACK32", 68);
PyModule_AddIntConstant(module, "VK_FORMAT_A2B10G10R10_SINT_PACK32", 69);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_UNORM", 70);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SNORM", 71);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_USCALED", 72);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SSCALED", 73);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_UINT", 74);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SINT", 75);
PyModule_AddIntConstant(module, "VK_FORMAT_R16_SFLOAT", 76);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UNORM", 77);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SNORM", 78);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_USCALED", 79);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SSCALED", 80);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_UINT", 81);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SINT", 82);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16_SFLOAT", 83);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UNORM", 84);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SNORM", 85);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_USCALED", 86);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SSCALED", 87);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_UINT", 88);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SINT", 89);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16_SFLOAT", 90);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UNORM", 91);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SNORM", 92);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_USCALED", 93);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SSCALED", 94);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_UINT", 95);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SINT", 96);
PyModule_AddIntConstant(module, "VK_FORMAT_R16G16B16A16_SFLOAT", 97);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_UINT", 98);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_SINT", 99);
PyModule_AddIntConstant(module, "VK_FORMAT_R32_SFLOAT", 100);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_UINT", 101);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SINT", 102);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32_SFLOAT", 103);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_UINT", 104);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SINT", 105);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32_SFLOAT", 106);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_UINT", 107);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SINT", 108);
PyModule_AddIntConstant(module, "VK_FORMAT_R32G32B32A32_SFLOAT", 109);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_UINT", 110);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_SINT", 111);
PyModule_AddIntConstant(module, "VK_FORMAT_R64_SFLOAT", 112);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_UINT", 113);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SINT", 114);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64_SFLOAT", 115);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_UINT", 116);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SINT", 117);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64_SFLOAT", 118);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_UINT", 119);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SINT", 120);
PyModule_AddIntConstant(module, "VK_FORMAT_R64G64B64A64_SFLOAT", 121);
PyModule_AddIntConstant(module, "VK_FORMAT_B10G11R11_UFLOAT_PACK32", 122);
PyModule_AddIntConstant(module, "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", 123);
PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM", 124);
PyModule_AddIntConstant(module, "VK_FORMAT_X8_D24_UNORM_PACK32", 125);
PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT", 126);
PyModule_AddIntConstant(module, "VK_FORMAT_S8_UINT", 127);
PyModule_AddIntConstant(module, "VK_FORMAT_D16_UNORM_S8_UINT", 128);
PyModule_AddIntConstant(module, "VK_FORMAT_D24_UNORM_S8_UINT", 129);
PyModule_AddIntConstant(module, "VK_FORMAT_D32_SFLOAT_S8_UINT", 130);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_UNORM_BLOCK", 131);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGB_SRGB_BLOCK", 132);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_UNORM_BLOCK", 133);
PyModule_AddIntConstant(module, "VK_FORMAT_BC1_RGBA_SRGB_BLOCK", 134);
PyModule_AddIntConstant(module, "VK_FORMAT_BC2_UNORM_BLOCK", 135);
PyModule_AddIntConstant(module, "VK_FORMAT_BC2_SRGB_BLOCK", 136);
PyModule_AddIntConstant(module, "VK_FORMAT_BC3_UNORM_BLOCK", 137);
PyModule_AddIntConstant(module, "VK_FORMAT_BC3_SRGB_BLOCK", 138);
PyModule_AddIntConstant(module, "VK_FORMAT_BC4_UNORM_BLOCK", 139);
PyModule_AddIntConstant(module, "VK_FORMAT_BC4_SNORM_BLOCK", 140);
PyModule_AddIntConstant(module, "VK_FORMAT_BC5_UNORM_BLOCK", 141);
PyModule_AddIntConstant(module, "VK_FORMAT_BC5_SNORM_BLOCK", 142);
PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_UFLOAT_BLOCK", 143);
PyModule_AddIntConstant(module, "VK_FORMAT_BC6H_SFLOAT_BLOCK", 144);
PyModule_AddIntConstant(module, "VK_FORMAT_BC7_UNORM_BLOCK", 145);
PyModule_AddIntConstant(module, "VK_FORMAT_BC7_SRGB_BLOCK", 146);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", 147);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", 148);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", 149);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", 150);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", 151);
PyModule_AddIntConstant(module, "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", 152);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_UNORM_BLOCK", 153);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11_SNORM_BLOCK", 154);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_UNORM_BLOCK", 155);
PyModule_AddIntConstant(module, "VK_FORMAT_EAC_R11G11_SNORM_BLOCK", 156);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_UNORM_BLOCK", 157);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_4x4_SRGB_BLOCK", 158);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_UNORM_BLOCK", 159);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x4_SRGB_BLOCK", 160);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_UNORM_BLOCK", 161);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_5x5_SRGB_BLOCK", 162);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_UNORM_BLOCK", 163);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x5_SRGB_BLOCK", 164);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_UNORM_BLOCK", 165);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_6x6_SRGB_BLOCK", 166);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_UNORM_BLOCK", 167);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x5_SRGB_BLOCK", 168);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_UNORM_BLOCK", 169);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x6_SRGB_BLOCK", 170);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_UNORM_BLOCK", 171);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_8x8_SRGB_BLOCK", 172);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_UNORM_BLOCK", 173);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x5_SRGB_BLOCK", 174);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_UNORM_BLOCK", 175);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x6_SRGB_BLOCK", 176);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_UNORM_BLOCK", 177);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x8_SRGB_BLOCK", 178);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_UNORM_BLOCK", 179);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_10x10_SRGB_BLOCK", 180);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_UNORM_BLOCK", 181);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x10_SRGB_BLOCK", 182);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_UNORM_BLOCK", 183);
PyModule_AddIntConstant(module, "VK_FORMAT_ASTC_12x12_SRGB_BLOCK", 184);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_APPLICATION_INFO", 0);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", 1);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", 2);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", 3);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SUBMIT_INFO", 4);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", 5);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", 6);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", 7);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", 8);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", 9);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", 10);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", 11);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", 12);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", 13);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", 14);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", 15);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", 16);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", 17);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", 18);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", 19);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", 20);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO", 21);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO", 22);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", 23);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", 24);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO", 25);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO", 26);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", 27);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", 28);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", 29);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", 30);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", 31);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", 32);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", 33);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", 34);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", 35);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", 36);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", 37);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", 38);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", 39);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", 40);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", 41);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", 42);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", 43);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", 44);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", 45);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_MEMORY_BARRIER", 46);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO", 47);
PyModule_AddIntConstant(module, "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO", 48);
PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_INLINE", 0);
PyModule_AddIntConstant(module, "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", 1);
PyModule_AddIntConstant(module, "VK_SUCCESS", 0);
PyModule_AddIntConstant(module, "VK_NOT_READY", 1);
PyModule_AddIntConstant(module, "VK_TIMEOUT", 2);
PyModule_AddIntConstant(module, "VK_EVENT_SET", 3);
PyModule_AddIntConstant(module, "VK_EVENT_RESET", 4);
PyModule_AddIntConstant(module, "VK_INCOMPLETE", 5);
PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_HOST_MEMORY", -1);
PyModule_AddIntConstant(module, "VK_ERROR_OUT_OF_DEVICE_MEMORY", -2);
PyModule_AddIntConstant(module, "VK_ERROR_INITIALIZATION_FAILED", -3);
PyModule_AddIntConstant(module, "VK_ERROR_DEVICE_LOST", -4);
PyModule_AddIntConstant(module, "VK_ERROR_MEMORY_MAP_FAILED", -5);
PyModule_AddIntConstant(module, "VK_ERROR_LAYER_NOT_PRESENT", -6);
PyModule_AddIntConstant(module, "VK_ERROR_EXTENSION_NOT_PRESENT", -7);
PyModule_AddIntConstant(module, "VK_ERROR_FEATURE_NOT_PRESENT", -8);
PyModule_AddIntConstant(module, "VK_ERROR_INCOMPATIBLE_DRIVER", -9);
PyModule_AddIntConstant(module, "VK_ERROR_TOO_MANY_OBJECTS", -10);
PyModule_AddIntConstant(module, "VK_ERROR_FORMAT_NOT_SUPPORTED", -11);
PyModule_AddIntConstant(module, "VK_ERROR_FRAGMENTED_POOL", -12);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_VIEWPORT", 0);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_SCISSOR", 1);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_LINE_WIDTH", 2);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BIAS", 3);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_BLEND_CONSTANTS", 4);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_DEPTH_BOUNDS", 5);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK", 6);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK", 7);
PyModule_AddIntConstant(module, "VK_DYNAMIC_STATE_STENCIL_REFERENCE", 8);
PyModule_AddIntConstant(module, "VK_QUEUE_GRAPHICS_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUEUE_COMPUTE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUEUE_TRANSFER_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUEUE_SPARSE_BINDING_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_HOST_CACHED_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_ACCESS_INDIRECT_COMMAND_READ_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_ACCESS_INDEX_READ_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_ACCESS_UNIFORM_READ_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_READ_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_ACCESS_SHADER_WRITE_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_READ_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_ACCESS_TRANSFER_WRITE_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_ACCESS_HOST_READ_BIT", 0x00000014);
PyModule_AddIntConstant(module, "VK_ACCESS_HOST_WRITE_BIT", 0x00000015);
PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_READ_BIT", 0x00000016);
PyModule_AddIntConstant(module, "VK_ACCESS_MEMORY_WRITE_BIT", 0x00000017);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_SRC_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_TRANSFER_DST_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDEX_BUFFER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_BINDING_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_VERTEX_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_GEOMETRY_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_FRAGMENT_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_COMPUTE_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL_GRAPHICS", 0x0000001F);
PyModule_AddIntConstant(module, "VK_SHADER_STAGE_ALL", 0x7FFFFFFF);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_SRC_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSFER_DST_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_SAMPLED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_STORAGE_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_BINDING_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_PIPELINE_CREATE_DERIVATIVE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_R_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_G_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_B_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_COLOR_COMPONENT_A_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_FENCE_CREATE_SIGNALED_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_SRC_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_BLIT_DST_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_QUERY_CONTROL_PRECISE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_64_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WAIT_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_RESULT_PARTIAL_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_COLOR_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_DEPTH_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_STENCIL_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_IMAGE_ASPECT_METADATA_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SPARSE_MEMORY_BIND_METADATA_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", 0x00000008);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", 0x00000009);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", 0x00000010);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", 0x00000011);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", 0x00000012);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_TRANSFER_BIT", 0x00000013);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", 0x00000014);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_HOST_BIT", 0x00000015);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", 0x00000016);
PyModule_AddIntConstant(module, "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", 0x00000017);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_1_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_2_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_4_BIT", 0x00000003);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_8_BIT", 0x00000004);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_16_BIT", 0x00000005);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_32_BIT", 0x00000006);
PyModule_AddIntConstant(module, "VK_SAMPLE_COUNT_64_BIT", 0x00000007);
PyModule_AddIntConstant(module, "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_STENCIL_FACE_FRONT_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_STENCIL_FACE_BACK_BIT", 0x00000002);
PyModule_AddIntConstant(module, "VK_STENCIL_FRONT_AND_BACK", 0x00000003);
PyModule_AddIntConstant(module, "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_DEPENDENCY_BY_REGION_BIT", 0x00000001);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_IMMEDIATE_KHR", 0);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_MAILBOX_KHR", 1);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_KHR", 2);
PyModule_AddIntConstant(module, "VK_PRESENT_MODE_FIFO_RELAXED_KHR", 3);
PyModule_AddIntConstant(module, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR", 0);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR", 0x00000001);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR", 0x00000002);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR", 0x00000003);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", 0x00000004);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR", 0x00000005);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR", 0x00000006);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR", 0x00000007);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR", 0x00000008);
PyModule_AddIntConstant(module, "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR", 0x00000009);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_INFORMATION_BIT_EXT", 0x00000001);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_WARNING_BIT_EXT", 0x00000002);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT", 0x00000003);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_BIT_EXT", 0x00000004);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_DEBUG_BIT_EXT", 0x00000005);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", 0);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT", 1);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT", 2);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT", 3);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT", 4);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT", 5);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT", 6);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT", 7);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT", 8);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT", 9);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT", 10);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT", 11);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT", 12);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT", 13);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT", 14);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT", 15);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT", 16);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT", 17);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT", 18);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT", 19);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT", 20);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT", 21);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT", 22);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT", 23);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT", 24);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT", 25);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT", 26);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT", 27);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT", 28);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_NONE_EXT", 0);
PyModule_AddIntConstant(module, "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT", 1);
PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_STRICT_AMD", 0);
PyModule_AddIntConstant(module, "VK_RASTERIZATION_ORDER_RELAXED_AMD", 1);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV", 0x00000001);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV", 0x00000002);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV", 0x00000004);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV", 0x00000008);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV", 0x00000001);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV", 0x00000002);
PyModule_AddIntConstant(module, "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV", 0x00000004);

                    if (PyType_Ready(&PyVkOffset2DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkOffset2DType);
                    PyModule_AddObject(module, "VkOffset2D", (PyObject *)&PyVkOffset2DType);
                
                    if (PyType_Ready(&PyVkOffset3DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkOffset3DType);
                    PyModule_AddObject(module, "VkOffset3D", (PyObject *)&PyVkOffset3DType);
                
                    if (PyType_Ready(&PyVkExtent2DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExtent2DType);
                    PyModule_AddObject(module, "VkExtent2D", (PyObject *)&PyVkExtent2DType);
                
                    if (PyType_Ready(&PyVkExtent3DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExtent3DType);
                    PyModule_AddObject(module, "VkExtent3D", (PyObject *)&PyVkExtent3DType);
                
                    if (PyType_Ready(&PyVkViewportType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkViewportType);
                    PyModule_AddObject(module, "VkViewport", (PyObject *)&PyVkViewportType);
                
                    if (PyType_Ready(&PyVkRect2DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkRect2DType);
                    PyModule_AddObject(module, "VkRect2D", (PyObject *)&PyVkRect2DType);
                
#ifdef hackdefine

                    if (PyType_Ready(&PyVkRect3DType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkRect3DType);
                    PyModule_AddObject(module, "VkRect3D", (PyObject *)&PyVkRect3DType);
                
#endif

                    if (PyType_Ready(&PyVkClearRectType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkClearRectType);
                    PyModule_AddObject(module, "VkClearRect", (PyObject *)&PyVkClearRectType);
                
                    if (PyType_Ready(&PyVkComponentMappingType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkComponentMappingType);
                    PyModule_AddObject(module, "VkComponentMapping", (PyObject *)&PyVkComponentMappingType);
                
                    if (PyType_Ready(&PyVkPhysicalDevicePropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPhysicalDevicePropertiesType);
                    PyModule_AddObject(module, "VkPhysicalDeviceProperties", (PyObject *)&PyVkPhysicalDevicePropertiesType);
                
                    if (PyType_Ready(&PyVkExtensionPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExtensionPropertiesType);
                    PyModule_AddObject(module, "VkExtensionProperties", (PyObject *)&PyVkExtensionPropertiesType);
                
                    if (PyType_Ready(&PyVkLayerPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkLayerPropertiesType);
                    PyModule_AddObject(module, "VkLayerProperties", (PyObject *)&PyVkLayerPropertiesType);
                
                    if (PyType_Ready(&PyVkApplicationInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkApplicationInfoType);
                    PyModule_AddObject(module, "VkApplicationInfo", (PyObject *)&PyVkApplicationInfoType);
                
                    if (PyType_Ready(&PyVkAllocationCallbacksType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkAllocationCallbacksType);
                    PyModule_AddObject(module, "VkAllocationCallbacks", (PyObject *)&PyVkAllocationCallbacksType);
                
                    if (PyType_Ready(&PyVkDeviceQueueCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDeviceQueueCreateInfoType);
                    PyModule_AddObject(module, "VkDeviceQueueCreateInfo", (PyObject *)&PyVkDeviceQueueCreateInfoType);
                
                    if (PyType_Ready(&PyVkDeviceCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDeviceCreateInfoType);
                    PyModule_AddObject(module, "VkDeviceCreateInfo", (PyObject *)&PyVkDeviceCreateInfoType);
                
                    if (PyType_Ready(&PyVkInstanceCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkInstanceCreateInfoType);
                    PyModule_AddObject(module, "VkInstanceCreateInfo", (PyObject *)&PyVkInstanceCreateInfoType);
                
                    if (PyType_Ready(&PyVkQueueFamilyPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkQueueFamilyPropertiesType);
                    PyModule_AddObject(module, "VkQueueFamilyProperties", (PyObject *)&PyVkQueueFamilyPropertiesType);
                
                    if (PyType_Ready(&PyVkPhysicalDeviceMemoryPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPhysicalDeviceMemoryPropertiesType);
                    PyModule_AddObject(module, "VkPhysicalDeviceMemoryProperties", (PyObject *)&PyVkPhysicalDeviceMemoryPropertiesType);
                
                    if (PyType_Ready(&PyVkMemoryAllocateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMemoryAllocateInfoType);
                    PyModule_AddObject(module, "VkMemoryAllocateInfo", (PyObject *)&PyVkMemoryAllocateInfoType);
                
                    if (PyType_Ready(&PyVkMemoryRequirementsType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMemoryRequirementsType);
                    PyModule_AddObject(module, "VkMemoryRequirements", (PyObject *)&PyVkMemoryRequirementsType);
                
                    if (PyType_Ready(&PyVkSparseImageFormatPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseImageFormatPropertiesType);
                    PyModule_AddObject(module, "VkSparseImageFormatProperties", (PyObject *)&PyVkSparseImageFormatPropertiesType);
                
                    if (PyType_Ready(&PyVkSparseImageMemoryRequirementsType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseImageMemoryRequirementsType);
                    PyModule_AddObject(module, "VkSparseImageMemoryRequirements", (PyObject *)&PyVkSparseImageMemoryRequirementsType);
                
                    if (PyType_Ready(&PyVkMemoryTypeType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMemoryTypeType);
                    PyModule_AddObject(module, "VkMemoryType", (PyObject *)&PyVkMemoryTypeType);
                
                    if (PyType_Ready(&PyVkMemoryHeapType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMemoryHeapType);
                    PyModule_AddObject(module, "VkMemoryHeap", (PyObject *)&PyVkMemoryHeapType);
                
                    if (PyType_Ready(&PyVkMappedMemoryRangeType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMappedMemoryRangeType);
                    PyModule_AddObject(module, "VkMappedMemoryRange", (PyObject *)&PyVkMappedMemoryRangeType);
                
                    if (PyType_Ready(&PyVkFormatPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkFormatPropertiesType);
                    PyModule_AddObject(module, "VkFormatProperties", (PyObject *)&PyVkFormatPropertiesType);
                
                    if (PyType_Ready(&PyVkImageFormatPropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageFormatPropertiesType);
                    PyModule_AddObject(module, "VkImageFormatProperties", (PyObject *)&PyVkImageFormatPropertiesType);
                
                    if (PyType_Ready(&PyVkDescriptorBufferInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorBufferInfoType);
                    PyModule_AddObject(module, "VkDescriptorBufferInfo", (PyObject *)&PyVkDescriptorBufferInfoType);
                
                    if (PyType_Ready(&PyVkDescriptorImageInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorImageInfoType);
                    PyModule_AddObject(module, "VkDescriptorImageInfo", (PyObject *)&PyVkDescriptorImageInfoType);
                
                    if (PyType_Ready(&PyVkWriteDescriptorSetType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkWriteDescriptorSetType);
                    PyModule_AddObject(module, "VkWriteDescriptorSet", (PyObject *)&PyVkWriteDescriptorSetType);
                
                    if (PyType_Ready(&PyVkCopyDescriptorSetType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkCopyDescriptorSetType);
                    PyModule_AddObject(module, "VkCopyDescriptorSet", (PyObject *)&PyVkCopyDescriptorSetType);
                
                    if (PyType_Ready(&PyVkBufferCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBufferCreateInfoType);
                    PyModule_AddObject(module, "VkBufferCreateInfo", (PyObject *)&PyVkBufferCreateInfoType);
                
                    if (PyType_Ready(&PyVkBufferViewCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBufferViewCreateInfoType);
                    PyModule_AddObject(module, "VkBufferViewCreateInfo", (PyObject *)&PyVkBufferViewCreateInfoType);
                
                    if (PyType_Ready(&PyVkImageSubresourceType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageSubresourceType);
                    PyModule_AddObject(module, "VkImageSubresource", (PyObject *)&PyVkImageSubresourceType);
                
                    if (PyType_Ready(&PyVkImageSubresourceLayersType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageSubresourceLayersType);
                    PyModule_AddObject(module, "VkImageSubresourceLayers", (PyObject *)&PyVkImageSubresourceLayersType);
                
                    if (PyType_Ready(&PyVkImageSubresourceRangeType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageSubresourceRangeType);
                    PyModule_AddObject(module, "VkImageSubresourceRange", (PyObject *)&PyVkImageSubresourceRangeType);
                
                    if (PyType_Ready(&PyVkMemoryBarrierType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMemoryBarrierType);
                    PyModule_AddObject(module, "VkMemoryBarrier", (PyObject *)&PyVkMemoryBarrierType);
                
                    if (PyType_Ready(&PyVkBufferMemoryBarrierType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBufferMemoryBarrierType);
                    PyModule_AddObject(module, "VkBufferMemoryBarrier", (PyObject *)&PyVkBufferMemoryBarrierType);
                
                    if (PyType_Ready(&PyVkImageMemoryBarrierType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageMemoryBarrierType);
                    PyModule_AddObject(module, "VkImageMemoryBarrier", (PyObject *)&PyVkImageMemoryBarrierType);
                
                    if (PyType_Ready(&PyVkImageCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageCreateInfoType);
                    PyModule_AddObject(module, "VkImageCreateInfo", (PyObject *)&PyVkImageCreateInfoType);
                
                    if (PyType_Ready(&PyVkSubresourceLayoutType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSubresourceLayoutType);
                    PyModule_AddObject(module, "VkSubresourceLayout", (PyObject *)&PyVkSubresourceLayoutType);
                
                    if (PyType_Ready(&PyVkImageViewCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageViewCreateInfoType);
                    PyModule_AddObject(module, "VkImageViewCreateInfo", (PyObject *)&PyVkImageViewCreateInfoType);
                
                    if (PyType_Ready(&PyVkBufferCopyType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBufferCopyType);
                    PyModule_AddObject(module, "VkBufferCopy", (PyObject *)&PyVkBufferCopyType);
                
                    if (PyType_Ready(&PyVkSparseMemoryBindType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseMemoryBindType);
                    PyModule_AddObject(module, "VkSparseMemoryBind", (PyObject *)&PyVkSparseMemoryBindType);
                
                    if (PyType_Ready(&PyVkSparseImageMemoryBindType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseImageMemoryBindType);
                    PyModule_AddObject(module, "VkSparseImageMemoryBind", (PyObject *)&PyVkSparseImageMemoryBindType);
                
                    if (PyType_Ready(&PyVkSparseBufferMemoryBindInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseBufferMemoryBindInfoType);
                    PyModule_AddObject(module, "VkSparseBufferMemoryBindInfo", (PyObject *)&PyVkSparseBufferMemoryBindInfoType);
                
                    if (PyType_Ready(&PyVkSparseImageOpaqueMemoryBindInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseImageOpaqueMemoryBindInfoType);
                    PyModule_AddObject(module, "VkSparseImageOpaqueMemoryBindInfo", (PyObject *)&PyVkSparseImageOpaqueMemoryBindInfoType);
                
                    if (PyType_Ready(&PyVkSparseImageMemoryBindInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSparseImageMemoryBindInfoType);
                    PyModule_AddObject(module, "VkSparseImageMemoryBindInfo", (PyObject *)&PyVkSparseImageMemoryBindInfoType);
                
                    if (PyType_Ready(&PyVkBindSparseInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBindSparseInfoType);
                    PyModule_AddObject(module, "VkBindSparseInfo", (PyObject *)&PyVkBindSparseInfoType);
                
                    if (PyType_Ready(&PyVkImageCopyType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageCopyType);
                    PyModule_AddObject(module, "VkImageCopy", (PyObject *)&PyVkImageCopyType);
                
                    if (PyType_Ready(&PyVkImageBlitType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageBlitType);
                    PyModule_AddObject(module, "VkImageBlit", (PyObject *)&PyVkImageBlitType);
                
                    if (PyType_Ready(&PyVkBufferImageCopyType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkBufferImageCopyType);
                    PyModule_AddObject(module, "VkBufferImageCopy", (PyObject *)&PyVkBufferImageCopyType);
                
                    if (PyType_Ready(&PyVkImageResolveType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImageResolveType);
                    PyModule_AddObject(module, "VkImageResolve", (PyObject *)&PyVkImageResolveType);
                
                    if (PyType_Ready(&PyVkShaderModuleCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkShaderModuleCreateInfoType);
                    PyModule_AddObject(module, "VkShaderModuleCreateInfo", (PyObject *)&PyVkShaderModuleCreateInfoType);
                
                    if (PyType_Ready(&PyVkDescriptorSetLayoutBindingType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorSetLayoutBindingType);
                    PyModule_AddObject(module, "VkDescriptorSetLayoutBinding", (PyObject *)&PyVkDescriptorSetLayoutBindingType);
                
                    if (PyType_Ready(&PyVkDescriptorSetLayoutCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorSetLayoutCreateInfoType);
                    PyModule_AddObject(module, "VkDescriptorSetLayoutCreateInfo", (PyObject *)&PyVkDescriptorSetLayoutCreateInfoType);
                
                    if (PyType_Ready(&PyVkDescriptorPoolSizeType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorPoolSizeType);
                    PyModule_AddObject(module, "VkDescriptorPoolSize", (PyObject *)&PyVkDescriptorPoolSizeType);
                
                    if (PyType_Ready(&PyVkDescriptorPoolCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorPoolCreateInfoType);
                    PyModule_AddObject(module, "VkDescriptorPoolCreateInfo", (PyObject *)&PyVkDescriptorPoolCreateInfoType);
                
                    if (PyType_Ready(&PyVkDescriptorSetAllocateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDescriptorSetAllocateInfoType);
                    PyModule_AddObject(module, "VkDescriptorSetAllocateInfo", (PyObject *)&PyVkDescriptorSetAllocateInfoType);
                
                    if (PyType_Ready(&PyVkSpecializationMapEntryType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSpecializationMapEntryType);
                    PyModule_AddObject(module, "VkSpecializationMapEntry", (PyObject *)&PyVkSpecializationMapEntryType);
                
                    if (PyType_Ready(&PyVkSpecializationInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSpecializationInfoType);
                    PyModule_AddObject(module, "VkSpecializationInfo", (PyObject *)&PyVkSpecializationInfoType);
                
                    if (PyType_Ready(&PyVkPipelineShaderStageCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineShaderStageCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineShaderStageCreateInfo", (PyObject *)&PyVkPipelineShaderStageCreateInfoType);
                
                    if (PyType_Ready(&PyVkComputePipelineCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkComputePipelineCreateInfoType);
                    PyModule_AddObject(module, "VkComputePipelineCreateInfo", (PyObject *)&PyVkComputePipelineCreateInfoType);
                
                    if (PyType_Ready(&PyVkVertexInputBindingDescriptionType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkVertexInputBindingDescriptionType);
                    PyModule_AddObject(module, "VkVertexInputBindingDescription", (PyObject *)&PyVkVertexInputBindingDescriptionType);
                
                    if (PyType_Ready(&PyVkVertexInputAttributeDescriptionType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkVertexInputAttributeDescriptionType);
                    PyModule_AddObject(module, "VkVertexInputAttributeDescription", (PyObject *)&PyVkVertexInputAttributeDescriptionType);
                
                    if (PyType_Ready(&PyVkPipelineVertexInputStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineVertexInputStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineVertexInputStateCreateInfo", (PyObject *)&PyVkPipelineVertexInputStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineInputAssemblyStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineInputAssemblyStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineInputAssemblyStateCreateInfo", (PyObject *)&PyVkPipelineInputAssemblyStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineTessellationStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineTessellationStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineTessellationStateCreateInfo", (PyObject *)&PyVkPipelineTessellationStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineViewportStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineViewportStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineViewportStateCreateInfo", (PyObject *)&PyVkPipelineViewportStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineRasterizationStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineRasterizationStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineRasterizationStateCreateInfo", (PyObject *)&PyVkPipelineRasterizationStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineMultisampleStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineMultisampleStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineMultisampleStateCreateInfo", (PyObject *)&PyVkPipelineMultisampleStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineColorBlendAttachmentStateType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineColorBlendAttachmentStateType);
                    PyModule_AddObject(module, "VkPipelineColorBlendAttachmentState", (PyObject *)&PyVkPipelineColorBlendAttachmentStateType);
                
                    if (PyType_Ready(&PyVkPipelineColorBlendStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineColorBlendStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineColorBlendStateCreateInfo", (PyObject *)&PyVkPipelineColorBlendStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineDynamicStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineDynamicStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineDynamicStateCreateInfo", (PyObject *)&PyVkPipelineDynamicStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkStencilOpStateType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkStencilOpStateType);
                    PyModule_AddObject(module, "VkStencilOpState", (PyObject *)&PyVkStencilOpStateType);
                
                    if (PyType_Ready(&PyVkPipelineDepthStencilStateCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineDepthStencilStateCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineDepthStencilStateCreateInfo", (PyObject *)&PyVkPipelineDepthStencilStateCreateInfoType);
                
                    if (PyType_Ready(&PyVkGraphicsPipelineCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkGraphicsPipelineCreateInfoType);
                    PyModule_AddObject(module, "VkGraphicsPipelineCreateInfo", (PyObject *)&PyVkGraphicsPipelineCreateInfoType);
                
                    if (PyType_Ready(&PyVkPipelineCacheCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineCacheCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineCacheCreateInfo", (PyObject *)&PyVkPipelineCacheCreateInfoType);
                
                    if (PyType_Ready(&PyVkPushConstantRangeType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPushConstantRangeType);
                    PyModule_AddObject(module, "VkPushConstantRange", (PyObject *)&PyVkPushConstantRangeType);
                
                    if (PyType_Ready(&PyVkPipelineLayoutCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineLayoutCreateInfoType);
                    PyModule_AddObject(module, "VkPipelineLayoutCreateInfo", (PyObject *)&PyVkPipelineLayoutCreateInfoType);
                
                    if (PyType_Ready(&PyVkSamplerCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSamplerCreateInfoType);
                    PyModule_AddObject(module, "VkSamplerCreateInfo", (PyObject *)&PyVkSamplerCreateInfoType);
                
                    if (PyType_Ready(&PyVkCommandPoolCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkCommandPoolCreateInfoType);
                    PyModule_AddObject(module, "VkCommandPoolCreateInfo", (PyObject *)&PyVkCommandPoolCreateInfoType);
                
                    if (PyType_Ready(&PyVkCommandBufferAllocateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkCommandBufferAllocateInfoType);
                    PyModule_AddObject(module, "VkCommandBufferAllocateInfo", (PyObject *)&PyVkCommandBufferAllocateInfoType);
                
                    if (PyType_Ready(&PyVkCommandBufferInheritanceInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkCommandBufferInheritanceInfoType);
                    PyModule_AddObject(module, "VkCommandBufferInheritanceInfo", (PyObject *)&PyVkCommandBufferInheritanceInfoType);
                
                    if (PyType_Ready(&PyVkCommandBufferBeginInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkCommandBufferBeginInfoType);
                    PyModule_AddObject(module, "VkCommandBufferBeginInfo", (PyObject *)&PyVkCommandBufferBeginInfoType);
                
                    if (PyType_Ready(&PyVkRenderPassBeginInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkRenderPassBeginInfoType);
                    PyModule_AddObject(module, "VkRenderPassBeginInfo", (PyObject *)&PyVkRenderPassBeginInfoType);
                
                    if (PyType_Ready(&PyVkClearDepthStencilValueType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkClearDepthStencilValueType);
                    PyModule_AddObject(module, "VkClearDepthStencilValue", (PyObject *)&PyVkClearDepthStencilValueType);
                
                    if (PyType_Ready(&PyVkClearAttachmentType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkClearAttachmentType);
                    PyModule_AddObject(module, "VkClearAttachment", (PyObject *)&PyVkClearAttachmentType);
                
                    if (PyType_Ready(&PyVkAttachmentDescriptionType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkAttachmentDescriptionType);
                    PyModule_AddObject(module, "VkAttachmentDescription", (PyObject *)&PyVkAttachmentDescriptionType);
                
                    if (PyType_Ready(&PyVkAttachmentReferenceType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkAttachmentReferenceType);
                    PyModule_AddObject(module, "VkAttachmentReference", (PyObject *)&PyVkAttachmentReferenceType);
                
                    if (PyType_Ready(&PyVkSubpassDescriptionType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSubpassDescriptionType);
                    PyModule_AddObject(module, "VkSubpassDescription", (PyObject *)&PyVkSubpassDescriptionType);
                
                    if (PyType_Ready(&PyVkSubpassDependencyType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSubpassDependencyType);
                    PyModule_AddObject(module, "VkSubpassDependency", (PyObject *)&PyVkSubpassDependencyType);
                
                    if (PyType_Ready(&PyVkRenderPassCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkRenderPassCreateInfoType);
                    PyModule_AddObject(module, "VkRenderPassCreateInfo", (PyObject *)&PyVkRenderPassCreateInfoType);
                
                    if (PyType_Ready(&PyVkEventCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkEventCreateInfoType);
                    PyModule_AddObject(module, "VkEventCreateInfo", (PyObject *)&PyVkEventCreateInfoType);
                
                    if (PyType_Ready(&PyVkFenceCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkFenceCreateInfoType);
                    PyModule_AddObject(module, "VkFenceCreateInfo", (PyObject *)&PyVkFenceCreateInfoType);
                
                    if (PyType_Ready(&PyVkPhysicalDeviceFeaturesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPhysicalDeviceFeaturesType);
                    PyModule_AddObject(module, "VkPhysicalDeviceFeatures", (PyObject *)&PyVkPhysicalDeviceFeaturesType);
                
                    if (PyType_Ready(&PyVkPhysicalDeviceSparsePropertiesType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPhysicalDeviceSparsePropertiesType);
                    PyModule_AddObject(module, "VkPhysicalDeviceSparseProperties", (PyObject *)&PyVkPhysicalDeviceSparsePropertiesType);
                
                    if (PyType_Ready(&PyVkPhysicalDeviceLimitsType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPhysicalDeviceLimitsType);
                    PyModule_AddObject(module, "VkPhysicalDeviceLimits", (PyObject *)&PyVkPhysicalDeviceLimitsType);
                
                    if (PyType_Ready(&PyVkSemaphoreCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSemaphoreCreateInfoType);
                    PyModule_AddObject(module, "VkSemaphoreCreateInfo", (PyObject *)&PyVkSemaphoreCreateInfoType);
                
                    if (PyType_Ready(&PyVkQueryPoolCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkQueryPoolCreateInfoType);
                    PyModule_AddObject(module, "VkQueryPoolCreateInfo", (PyObject *)&PyVkQueryPoolCreateInfoType);
                
                    if (PyType_Ready(&PyVkFramebufferCreateInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkFramebufferCreateInfoType);
                    PyModule_AddObject(module, "VkFramebufferCreateInfo", (PyObject *)&PyVkFramebufferCreateInfoType);
                
                    if (PyType_Ready(&PyVkDrawIndirectCommandType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDrawIndirectCommandType);
                    PyModule_AddObject(module, "VkDrawIndirectCommand", (PyObject *)&PyVkDrawIndirectCommandType);
                
                    if (PyType_Ready(&PyVkDrawIndexedIndirectCommandType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDrawIndexedIndirectCommandType);
                    PyModule_AddObject(module, "VkDrawIndexedIndirectCommand", (PyObject *)&PyVkDrawIndexedIndirectCommandType);
                
                    if (PyType_Ready(&PyVkDispatchIndirectCommandType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDispatchIndirectCommandType);
                    PyModule_AddObject(module, "VkDispatchIndirectCommand", (PyObject *)&PyVkDispatchIndirectCommandType);
                
                    if (PyType_Ready(&PyVkSubmitInfoType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSubmitInfoType);
                    PyModule_AddObject(module, "VkSubmitInfo", (PyObject *)&PyVkSubmitInfoType);
                
                    if (PyType_Ready(&PyVkDisplayPropertiesKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayPropertiesKHRType);
                    PyModule_AddObject(module, "VkDisplayPropertiesKHR", (PyObject *)&PyVkDisplayPropertiesKHRType);
                
                    if (PyType_Ready(&PyVkDisplayPlanePropertiesKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayPlanePropertiesKHRType);
                    PyModule_AddObject(module, "VkDisplayPlanePropertiesKHR", (PyObject *)&PyVkDisplayPlanePropertiesKHRType);
                
                    if (PyType_Ready(&PyVkDisplayModeParametersKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayModeParametersKHRType);
                    PyModule_AddObject(module, "VkDisplayModeParametersKHR", (PyObject *)&PyVkDisplayModeParametersKHRType);
                
                    if (PyType_Ready(&PyVkDisplayModePropertiesKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayModePropertiesKHRType);
                    PyModule_AddObject(module, "VkDisplayModePropertiesKHR", (PyObject *)&PyVkDisplayModePropertiesKHRType);
                
                    if (PyType_Ready(&PyVkDisplayModeCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayModeCreateInfoKHRType);
                    PyModule_AddObject(module, "VkDisplayModeCreateInfoKHR", (PyObject *)&PyVkDisplayModeCreateInfoKHRType);
                
                    if (PyType_Ready(&PyVkDisplayPlaneCapabilitiesKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayPlaneCapabilitiesKHRType);
                    PyModule_AddObject(module, "VkDisplayPlaneCapabilitiesKHR", (PyObject *)&PyVkDisplayPlaneCapabilitiesKHRType);
                
                    if (PyType_Ready(&PyVkDisplaySurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplaySurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkDisplaySurfaceCreateInfoKHR", (PyObject *)&PyVkDisplaySurfaceCreateInfoKHRType);
                
                    if (PyType_Ready(&PyVkDisplayPresentInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDisplayPresentInfoKHRType);
                    PyModule_AddObject(module, "VkDisplayPresentInfoKHR", (PyObject *)&PyVkDisplayPresentInfoKHRType);
                
                    if (PyType_Ready(&PyVkSurfaceCapabilitiesKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSurfaceCapabilitiesKHRType);
                    PyModule_AddObject(module, "VkSurfaceCapabilitiesKHR", (PyObject *)&PyVkSurfaceCapabilitiesKHRType);
                
#ifdef VK_USE_PLATFORM_ANDROID_KHR

                    if (PyType_Ready(&PyVkAndroidSurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkAndroidSurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkAndroidSurfaceCreateInfoKHR", (PyObject *)&PyVkAndroidSurfaceCreateInfoKHRType);
                
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR

                    if (PyType_Ready(&PyVkMirSurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkMirSurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkMirSurfaceCreateInfoKHR", (PyObject *)&PyVkMirSurfaceCreateInfoKHRType);
                
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR

                    if (PyType_Ready(&PyVkWaylandSurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkWaylandSurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkWaylandSurfaceCreateInfoKHR", (PyObject *)&PyVkWaylandSurfaceCreateInfoKHRType);
                
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                    if (PyType_Ready(&PyVkWin32SurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkWin32SurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkWin32SurfaceCreateInfoKHR", (PyObject *)&PyVkWin32SurfaceCreateInfoKHRType);
                
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR

                    if (PyType_Ready(&PyVkXlibSurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkXlibSurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkXlibSurfaceCreateInfoKHR", (PyObject *)&PyVkXlibSurfaceCreateInfoKHRType);
                
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR

                    if (PyType_Ready(&PyVkXcbSurfaceCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkXcbSurfaceCreateInfoKHRType);
                    PyModule_AddObject(module, "VkXcbSurfaceCreateInfoKHR", (PyObject *)&PyVkXcbSurfaceCreateInfoKHRType);
                
#endif

                    if (PyType_Ready(&PyVkSurfaceFormatKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSurfaceFormatKHRType);
                    PyModule_AddObject(module, "VkSurfaceFormatKHR", (PyObject *)&PyVkSurfaceFormatKHRType);
                
                    if (PyType_Ready(&PyVkSwapchainCreateInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkSwapchainCreateInfoKHRType);
                    PyModule_AddObject(module, "VkSwapchainCreateInfoKHR", (PyObject *)&PyVkSwapchainCreateInfoKHRType);
                
                    if (PyType_Ready(&PyVkPresentInfoKHRType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPresentInfoKHRType);
                    PyModule_AddObject(module, "VkPresentInfoKHR", (PyObject *)&PyVkPresentInfoKHRType);
                
                    if (PyType_Ready(&PyVkDebugReportCallbackCreateInfoEXTType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDebugReportCallbackCreateInfoEXTType);
                    PyModule_AddObject(module, "VkDebugReportCallbackCreateInfoEXT", (PyObject *)&PyVkDebugReportCallbackCreateInfoEXTType);
                
                    if (PyType_Ready(&PyVkDebugReportLayerFlagsEXTType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDebugReportLayerFlagsEXTType);
                    PyModule_AddObject(module, "VkDebugReportLayerFlagsEXT", (PyObject *)&PyVkDebugReportLayerFlagsEXTType);
                
                    if (PyType_Ready(&PyVkPipelineRasterizationStateRasterizationOrderAMDType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
                    PyModule_AddObject(module, "VkPipelineRasterizationStateRasterizationOrderAMD", (PyObject *)&PyVkPipelineRasterizationStateRasterizationOrderAMDType);
                
                    if (PyType_Ready(&PyVkDebugMarkerObjectNameInfoEXTType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDebugMarkerObjectNameInfoEXTType);
                    PyModule_AddObject(module, "VkDebugMarkerObjectNameInfoEXT", (PyObject *)&PyVkDebugMarkerObjectNameInfoEXTType);
                
                    if (PyType_Ready(&PyVkDebugMarkerObjectTagInfoEXTType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDebugMarkerObjectTagInfoEXTType);
                    PyModule_AddObject(module, "VkDebugMarkerObjectTagInfoEXT", (PyObject *)&PyVkDebugMarkerObjectTagInfoEXTType);
                
                    if (PyType_Ready(&PyVkDebugMarkerMarkerInfoEXTType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDebugMarkerMarkerInfoEXTType);
                    PyModule_AddObject(module, "VkDebugMarkerMarkerInfoEXT", (PyObject *)&PyVkDebugMarkerMarkerInfoEXTType);
                
                    if (PyType_Ready(&PyVkDedicatedAllocationImageCreateInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDedicatedAllocationImageCreateInfoNVType);
                    PyModule_AddObject(module, "VkDedicatedAllocationImageCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationImageCreateInfoNVType);
                
                    if (PyType_Ready(&PyVkDedicatedAllocationBufferCreateInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDedicatedAllocationBufferCreateInfoNVType);
                    PyModule_AddObject(module, "VkDedicatedAllocationBufferCreateInfoNV", (PyObject *)&PyVkDedicatedAllocationBufferCreateInfoNVType);
                
                    if (PyType_Ready(&PyVkDedicatedAllocationMemoryAllocateInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
                    PyModule_AddObject(module, "VkDedicatedAllocationMemoryAllocateInfoNV", (PyObject *)&PyVkDedicatedAllocationMemoryAllocateInfoNVType);
                
                    if (PyType_Ready(&PyVkExternalImageFormatPropertiesNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExternalImageFormatPropertiesNVType);
                    PyModule_AddObject(module, "VkExternalImageFormatPropertiesNV", (PyObject *)&PyVkExternalImageFormatPropertiesNVType);
                
                    if (PyType_Ready(&PyVkExternalMemoryImageCreateInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExternalMemoryImageCreateInfoNVType);
                    PyModule_AddObject(module, "VkExternalMemoryImageCreateInfoNV", (PyObject *)&PyVkExternalMemoryImageCreateInfoNVType);
                
                    if (PyType_Ready(&PyVkExportMemoryAllocateInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExportMemoryAllocateInfoNVType);
                    PyModule_AddObject(module, "VkExportMemoryAllocateInfoNV", (PyObject *)&PyVkExportMemoryAllocateInfoNVType);
                
#ifdef VK_USE_PLATFORM_WIN32_KHR

                    if (PyType_Ready(&PyVkImportMemoryWin32HandleInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkImportMemoryWin32HandleInfoNVType);
                    PyModule_AddObject(module, "VkImportMemoryWin32HandleInfoNV", (PyObject *)&PyVkImportMemoryWin32HandleInfoNVType);
                
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                    if (PyType_Ready(&PyVkExportMemoryWin32HandleInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkExportMemoryWin32HandleInfoNVType);
                    PyModule_AddObject(module, "VkExportMemoryWin32HandleInfoNV", (PyObject *)&PyVkExportMemoryWin32HandleInfoNVType);
                
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR

                    if (PyType_Ready(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType) < 0)
                        return NULL;
                    Py_INCREF(&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
                    PyModule_AddObject(module, "VkWin32KeyedMutexAcquireReleaseInfoNV", (PyObject *)&PyVkWin32KeyedMutexAcquireReleaseInfoNVType);
                
#endif
return module;
}
